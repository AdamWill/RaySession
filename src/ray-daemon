#!/usr/bin/python3 -u

import os, sys, shutil, string, random, time, subprocess, signal, unicodedata, inspect, functools
from liblo import ServerThread, Address, make_method, Message
from PyQt5.QtCore import QCoreApplication, pyqtSignal, QObject, QTimer, QProcess, QProcessEnvironment, QSettings, QStandardPaths
from PyQt5.QtXml import QDomDocument

from shared import *



#ray-daemon doesn't really cares if jack is running or not
#but if jack is running, it just ask all jack ports between many clients launchs or stops
#It 'maybe' prevent some jack bugs
try:
    import dbus
    bus = dbus.SessionBus()
    jack_bus = bus.get_object('org.jackaudio.service', '/org/jackaudio/Controller')
except:
    jack_bus = None

NSM_API_VERSION_MAJOR = 1
NSM_API_VERSION_MINOR = 0

ERR_OK                =  0
ERR_GENERAL_ERROR     = -1
ERR_INCOMPATIBLE_API  = -2
ERR_BLACKLISTED       = -3
ERR_LAUNCH_FAILED     = -4
ERR_NO_SUCH_FILE      = -5
ERR_NO_SESSION_OPEN   = -6
ERR_UNSAVED_CHANGES   = -7
ERR_NOT_NOW           = -8
ERR_BAD_PROJECT       = -9
ERR_CREATE_FAILED     = -10
ERR_SESSION_LOCKED    = -11
ERR_OPERATION_PENDING = -12
ERR_COPY_RUNNING      = -13
ERR_NET_ROOT_RUNNING  = -14

COMMAND_NONE      = 0
COMMAND_QUIT      = 1
COMMAND_KILL      = 2
COMMAND_SAVE      = 3
COMMAND_OPEN      = 4
COMMAND_START     = 5
COMMAND_CLOSE     = 6
COMMAND_DUPLICATE = 7
COMMAND_NEW       = 8

WAIT_FOR_NONE     = 0
WAIT_FOR_STOP     = 1
WAIT_FOR_ANNOUNCE = 2
WAIT_FOR_REPLY    = 3
WAIT_FOR_DUPLICATE_START  = 4
WAIT_FOR_DUPLICATE_FINISH = 5

TEMPLATE_NONE             = 0
TEMPLATE_RENAME           = 1
TEMPLATE_SESSION_SAVE     = 2
TEMPLATE_SESSION_SAVE_NET = 3
TEMPLATE_SESSION_LOAD     = 4
TEMPLATE_SESSION_LOAD_NET = 5
TEMPLATE_CLIENT_SAVE      = 6
TEMPLATE_CLIENT_LOAD      = 7


debug = False
last_client_message = ''
known_as_non_active = []

def dirname(*args):
    return os.path.dirname(*args)

def basename(*args):
    return os.path.basename(*args)

def pathIsValid(path):
    return not bool('../' in path)

def signalHandler(sig, frame):
    if sig in (signal.SIGINT, signal.SIGTERM):
        session.terminate()
        
def remove_accents(input_str):
    nfkd_form = unicodedata.normalize('NFKD', input_str)
    return u"".join([c for c in nfkd_form if not unicodedata.combining(c)]).lower()    

def ifDebug(string):
    if debug:
        print(string, file=sys.stderr)

def isPIdChildOf(child_pid, parent_pid):
    ppid = child_pid
    this_pid = os.getpid()
    
    while ppid != parent_pid and ppid > 1 and ppid != this_pid:
        try:
            ppid = int(subprocess.check_output(['ps', '-o', 'ppid=', '-p', str(ppid)]))
        except:
            return False
        
    if ppid == parent_pid:
        return True
    
    return False

def MESSAGE(string):
    global last_client_message
    
    if last_client_message and last_client_message != 'daemon':
        sys.stderr.write('\n')
        
    sys.stderr.write('[\033[90mray-daemon\033[0m]\033[92m%s\033[0m\n' % string)
    
    last_client_message = 'daemon'

def CLIENT_MESSAGE(byte_string, client_name, client_id):
    global last_client_message
    
    client_str = "%s.%s" % (client_name, client_id)
    
    if not debug_only:
        if last_client_message != client_str:
            sys.stderr.write('\n[\033[90m%s-%s\033[0m]\n' % (client_name, client_id))
        sys.stderr.buffer.write(byte_string)
    
    last_client_message = client_str

def WARNING(string):
    print('[' + '\033[90m' + 'ray-daemon' + '\033[0m' + '] ' + '\033[93m' + string + '\033[0m', file=sys.stderr)

def waitForJack():
    pass
    #if jack_bus and jack_bus.IsStarted():
        #all_ports = jack_bus.GetAllPorts()
        #del all_ports
        
def quitRay(sig, frame):
    for client in session.clients:
        if client.isRunning():
            MESSAGE(_translate('GUIMSG', 'Good Bye ! Clients are still running.'))
            break
    else:
        MESSAGE(_translate('GUIMSG', 'Good Bye !'))
    app.quit()

class MultiDaemonFile(object):
    def __init__(self):
        self.file_path = '/tmp/RaySession/multi-daemon.xml'
        self.xml = QDomDocument()
    
    def pidExists(self, pid):
        if type(pid) == str:
            pid = int(pid)
        
        try:
            os.kill(pid, 0)
        except OSError:
            return False
        else:
            return True
    
    def removeFile(self):
        try:
            os.remove(self.file_path)
        except:
            return
    
    def openFile(self):
        if not os.path.exists(self.file_path):
            if not os.path.exists(dirname(self.file_path)):
                os.makedirs(dirname(self.file_path))
                
            return False
        
        try:
            file = open(self.file_path, 'r')
            self.xml.setContent(file.read())
            file.close()
            return True
            
        except:
            self.removeFile()
            return False
    
    def writeFile(self):
        try:
            file = open(self.file_path, 'w')
            file.write(self.xml.toString())
            file.close()
        except:
            return
    
    def setAttributes(self, element):
        element.setAttribute('net_daemon_id', server.net_daemon_id)
        element.setAttribute('root', session.root)
        element.setAttribute('session_path', session.path)
        element.setAttribute('pid', os.getpid())
        element.setAttribute('port', server.port)
        element.setAttribute('user', os.getenv('USER'))
    
    
    def update(self):
        if not self.openFile():
            ds = self.xml.createElement('Deamons')
            dm_xml = self.xml.createElement('Deamon')
            
            self.setAttributes(dm_xml)
            
            ds.appendChild(dm_xml)
            self.xml.appendChild(ds)
            
        else:
            found = False
            
            xml_content = self.xml.documentElement()
            node = xml_content.firstChild()
            while not node.isNull():
                dxe = node.toElement()
                pid = dxe.attribute('pid')
                
                if pid.isdigit() and pid == str(os.getpid()):
                    self.setAttributes(dxe)
                    found = True
                    
                node = node.nextSibling()
                
            if not found:
                dm_xml = self.xml.createElement('Deamon')
                self.setAttributes(dm_xml)
                self.xml.firstChild().appendChild(dm_xml)
                
        self.writeFile()
    
    def quit(self):
        if not self.openFile():
            return
        
        xml_content = self.xml.documentElement()
        node = xml_content.firstChild()
        
        while not node.isNull():
            dxe = node.toElement()
            pid = dxe.attribute('pid')
            
            if pid.isdigit() and pid == str(os.getpid()):
                break
            
            node = node.nextSibling()
        else:
            return

        xml_content.removeChild(node)
        self.writeFile()
        
    
    def isFreeForRoot(self, daemon_id, root_path):
        if not self.openFile():
            return True
        
        
        xml_content = self.xml.documentElement()
        node = xml_content.firstChild()
        
        while not node.isNull():
            dxe = node.toElement()
            if (dxe.attribute('net_daemon_id') == str(daemon_id) and
                dxe.attribute('root')      == root_path):
                    pid = dxe.attribute('pid')
                    if pid.isdigit() and self.pidExists(int(pid)):
                        return False
                    
            node = node.nextSibling()
            
        return True
    
    def isFreeForSession(self, session_path):
        if not self.openFile():
            return True
        
        xml_content = self.xml.documentElement()
        node = xml_content.firstChild()
        
        while not node.isNull():
            dxe = node.toElement()
            if dxe.attribute('session_path') == session_path:
                pid = dxe.attribute('pid')
                if pid.isdigit() and self.pidExists(int(pid)):
                    return False
                    
            node = node.nextSibling()
            
        return True
        
                
    
class ServerSender(QObject):
    def __init__(self):
        QObject.__init__(self)
        self.is_dummy = False
      
    def hasServer(self):
        if not 'server' in globals():
            return False
        
        return not self.is_dummy

    def send(self, *args):
        if not self.hasServer():
            return
        
        server.send(*args)
        
    def sendGui(self, *args):
        if not self.hasServer():
            return
        
        server.sendGui(*args)
        
    def sendGuiMessage(self, message):
        if not self.hasServer():
            return
    
        server.sendGui('/ray/gui/server/message', message)
        
    def setServerStatus(self, server_status):
        if not self.hasServer():
            return
        
        server.setServerStatus(server_status)
        
    def isNsmLocked(self):
        if not self.hasServer():
            return False
        
        return server.is_nsm_locked

class CopyFile(object):
    slots = ['orig_path',
             'dest_path',
             'state',
             'size']

class FileCopier(ServerSender):
    def __init__(self, session):
        ServerSender.__init__(self)
        self.session        = session
        self.client_id      = ''
        self.next_function  = None
        self.abort_function = None
        self.next_args      = []
        self.copy_files     = []
        self.copy_size      = 0
        self.aborted        = False
        self.is_active      = False
        
        self.process = QProcess()
        self.process.finished.connect(self.processFinished)
        if QT_VERSION >= (5, 6):
            self.process.errorOccurred.connect(self.errorOccurred)
        
        self.timer = QTimer()
        self.timer.setInterval(250)
        self.timer.setSingleShot(True)
        self.timer.timeout.connect(self.checkProgressSize)
        
    def informCopytoGui(self, copy_state):
        if not self.hasServer():
            return
        
        server.informCopytoGui(copy_state)
    
    def getFileSize(self, filepath):
        if not os.path.exists(filepath):
            return 0
        
        try:
            du_full = subprocess.check_output(['nice', '-n', '15', 'du', '-sb', filepath]).decode()
        except:
            du_full = ""
            
        if not du_full:
            return 0
        
        du_str = du_full.split('\t')[0]
        if not du_str.isdigit():
            return 0
        
        return int(du_str)
        
    def checkProgressSize(self):
        current_size = 0
        self.timer.stop()
        
        for copy_file in self.copy_files:
            if copy_file.state == 2:
                current_size += copy_file.size
            elif copy_file.state == 1:
                current_size += self.getFileSize(copy_file.dest_path)
                break

        if current_size and self.copy_size:
            progress = float(current_size/self.copy_size)
            
            if self.client_id:
                self.sendGui('/ray/client/progress', self.client_id, progress)
            else:
                self.sendGui('/ray/gui/server_progress', progress)
                
            self.session.oscReply('/ray/net_daemon/duplicate_state', progress)
        
        self.timer.start()
    
    def processFinished(self, exit_code, exit_status):
        self.timer.stop()
        
        for copy_file in self.copy_files:
            if copy_file.state == 1:
                copy_file.state = 2
                break
        
        if self.aborted:
            ##remove all created files
            for copy_file in self.copy_files:
                if copy_file.state > 0:
                    file_to_remove = copy_file.dest_path
                    
                    if os.path.exists(file_to_remove):
                        try:
                            subprocess.run(['rm', '-R', file_to_remove]) 
                        except:
                            pass
                        
            self.is_active = False
            self.informCopytoGui(False)
            self.abort_function(*self.next_args)
            return
        
        #run next_function if copy is terminated
        for copy_file in self.copy_files:
            if copy_file.state != 2:
                break
        else:
            self.is_active = False
            self.informCopytoGui(False)
            
            if self.next_function:
                self.next_function(*self.next_args)
                
            return
        
        self.nextProcess()
        
    def errorOccurred(self):
        #todo make something else
        self.processFinished(0, 0)
        
    def nextProcess(self):
        self.is_active = True
        
        for copy_file in self.copy_files:
            if copy_file.state == 0:
                copy_file.state = 1
                self.process.start('nice' , ['-n', '+15', 'cp', '-R', copy_file.orig_path, copy_file.dest_path])
                break
            
        self.timer.start()
    
    def start(self, src_list, dest_dir, next_function, abort_function, next_args=[]):
        self.abort_function = abort_function
        self.next_function  = next_function
        self.next_args      = next_args
        
        self.aborted = False
        self.copy_size = 0
        self.copy_files.clear()
        
        dest_path_exists = bool(os.path.exists(dest_dir))
        if dest_path_exists:
            if not os.path.isdir(dest_dir):
                #TODO send error, but it should not append
                self.abort_function(*self.next_args)
                return
        
        for orig_path in src_list:
            copy_file = CopyFile()
            copy_file.state     = 0
            copy_file.orig_path = orig_path
            copy_file.size      = self.getFileSize(orig_path)
            
            self.copy_size+=copy_file.size
            
            if dest_path_exists:
                copy_file.dest_path = "%s/%s" % (dest_dir, basename(orig_path))
            else:
                #WARNING works only with one file !!!
                copy_file.dest_path = dest_dir
            
            self.copy_files.append(copy_file)
        
        
        if self.copy_files:
            self.informCopytoGui(True)
            self.nextProcess()
        else:
            self.next_function(*self.next_args)
        
    def startClientCopy(self, client_id, src_list, dest_dir, next_function, abort_function, next_args=[]):
        self.client_id = client_id
        self.start(src_list, dest_dir, next_function, abort_function, next_args)
        
    def startSessionCopy(self, src_dir, dest_dir, next_function, abort_function, next_args=[]):
        self.client_id = ''
        self.start([src_dir], dest_dir, next_function, abort_function, next_args)
        
    def abort(self, abort_function=None, next_args=[]):
        if abort_function:
            self.abort_function = abort_function
            self.next_args = next_args
        
        self.timer.stop()
        if self.process.state() == QProcess.Running:
            self.aborted = True
            self.process.terminate()
            
    def isActive(self, client_id=''):
        if client_id and client_id != self.client_id:
            return False
        
        return self.is_active
        
class Client(ServerSender):
    #can be directly changed by OSC thread
    gui_visible      = True
    _reply_errcode   = 0
    _reply_message   = None
    progress         = 0
    
    #have to be modified by main thread for security
    addr             = None
    pid              = 0
    pending_command  = COMMAND_NONE
    active           = False
    client_id        = ''
    capabilities     = ''
    did_announce     = False
    
    status           = CLIENT_STATUS_STOPPED
    name             = ''
    executable_path  = ''
    arguments        = ''
    tmp_arguments    = ''
    label            = ''
    icon             = ''
    pre_existing     = False
    project_path     = ""
    prefix_mode      = PREFIX_MODE_SESSION_NAME
    auto_start       = True
    start_gui_hidden = False
    check_last_save  = True
    sent_to_gui      = False
    
    net_session_template = ''
    net_session_root     = ''
    net_daemon_url       = ''
    net_duplicate_state  = -1
    
    last_save_time = 0.00
    last_dirty = 0.00
    
    def __init__(self, parent_session):
        ServerSender.__init__(self)
        self.session = parent_session
        self.is_dummy = self.session.is_dummy
        
        process_env = QProcessEnvironment.systemEnvironment()
        if self.hasServer() and hasattr(server, 'url'):
            process_env.insert('NSM_URL', server.url)
        
        self.process = QProcess()
        self.process.started.connect(self.processStarted)
        if QT_VERSION >= (5, 6):
            self.process.errorOccurred.connect(self.errorInProcess)
        self.process.finished.connect(self.processFinished)
        self.process.readyReadStandardError.connect(self.standardError)
        self.process.readyReadStandardOutput.connect(self.standardOutput)
        self.process.setProcessEnvironment(process_env)
        
        #if client is'n't stopped 2secs after stop, another stop becames a kill!
        self.stopped_since_long = False
        self.stopped_timer = QTimer()
        self.stopped_timer.setSingleShot(True)
        self.stopped_timer.setInterval(2000) #2sec
        self.stopped_timer.timeout.connect(self.stoppedSinceLong)
        
        self.net_daemon_copy_timer = QTimer()
        self.net_daemon_copy_timer.setSingleShot(True)
        self.net_daemon_copy_timer.setInterval(3000)
        self.net_daemon_copy_timer.timeout.connect(self.netDaemonOutOfTime)
    
    def sendToSelfAddress(self, *args):
        if not self.hasServer():
            return
        
        if not self.addr:
            return
        
        server.send(self.addr, *args)
        
    def sendStatusToGui(self):
        if not self.hasServer():
            return
        
        server.sendClientStatusToGui(self)
    
    def readXmlProperties(self, ctx):
        #ctx is an xml sibling for client
        self.executable_path  = ctx.attribute('executable')
        self.arguments        = ctx.attribute('arguments')
        self.name             = ctx.attribute('name')
        self.label            = ctx.attribute('label')
        self.icon             = ctx.attribute('icon')
        self.auto_start       = bool(ctx.attribute('launched') != '0')
        self.check_last_save  = bool(ctx.attribute('check_last_save') != '0')
        self.start_gui_hidden = bool(ctx.attribute('gui_visible') == '0')
        
        prefix_mode = ctx.attribute('prefix_mode')
        
        if prefix_mode and prefix_mode.isdigit():
            if 0 <= int(prefix_mode) <= 2:
                self.prefix_mode = int(prefix_mode)
                if self.prefix_mode == 0:
                    self.project_path = ctx.attribute('project-path')
                    
        
        self.net_session_template = ctx.attribute('net_session_template')
        
        if basename(self.executable_path) == 'ray-network':
            if self.arguments:
                eat_url  = False
                eat_root = False
                
                for arg in shlex.split(self.arguments):
                    if arg in ('--daemon-url', '-u'):
                        eat_url  = True
                        continue
                    elif arg in ('--session-root', '-r'):
                        eat_root = True
                        continue
                    elif not (eat_url or eat_root):
                        eat_url  = False
                        eat_root = False
                        continue
                        
                    if eat_url:
                        self.net_daemon_url = arg
                        eat_url = False
                    elif eat_root:
                        self.net_session_root = arg
                        eat_root = False
        
        if ctx.attribute('id'):
            #session use "id" for absolutely needed client_id
            self.client_id = ctx.attribute('id')
            
        elif ctx.attribute('client_id'):
            #template use "client_id" for wanted client_id
            self.client_id = self.session.generateClientId(ctx.attribute('client_id'))
        
    def writeXmlProperties(self, ctx):
        ctx.setAttribute('executable', self.executable_path)
        ctx.setAttribute('name', self.name)
        if self.label:
            ctx.setAttribute('label', self.label)
        if self.icon:
            ctx.setAttribute('icon', self.icon)
        if not self.check_last_save:
            ctx.setAttribute('check_last_save', "0")
        if self.arguments:
            ctx.setAttribute('arguments', self.arguments)
            
        if self.prefix_mode != PREFIX_MODE_SESSION_NAME:
            ctx.setAttribute('prefix_mode', self.prefix_mode)
            
            if self.prefix_mode == PREFIX_MODE_UNDEF:
                ctx.setAttribute('project_path', self.project_path)
                
        if self.isCapableOf(':optional-gui:'):
            if self.executable_path != 'ray-proxy':
                if self.start_gui_hidden:
                    ctx.setAttribute('gui_visible', '0')
                    
        #if self.isCapableOf(':ray-network:'):
        if self.net_session_template:
            ctx.setAttribute('net_session_template', self.net_session_template)
            
        
    def setReply(self, errcode, message):
        self._reply_message = message
        self._reply_errcode = errcode
    
    def setLabel(self, label):
        self.label = label
        self.sendGuiClientProperties()
        
    def setIcon(self, icon_name):
        self.icon = icon_name
        self.sendGuiClientProperties()
        
    def hasError(self):
        if self._reply_errcode:
            return self._reply_errcode
        
    def errorCode(self):
        return self._reply_errcode
    
    def getMessage(self):
        return self._reply_message
    
    def isReplyPending(self):
        if self.pending_command:
            return self.pending_command
        
    def isDumbClient(self):
        return bool(not self.did_announce)
    
    def isCapableOf(self, capability):
        return bool(capability in self.capabilities)
    
    def guiMsgStyle(self):
        return "%s (%s):" % (self.name, self.client_id)
    
    def setNetworkProperties(self, net_daemon_url, net_session_root):
        if not self.isCapableOf(':ray-network:'):
            return
        
        if net_daemon_url == self.net_daemon_url and net_session_root == self.net_session_root:
            return
        
        self.net_daemon_url   = net_daemon_url
        self.net_session_root = net_session_root
        
        self.arguments = '--daemon-url %s --net-session-root "%s"' % (self.net_daemon_url, self.net_session_root.replace('"', '\\"'))
    
    def netDaemonOutOfTime(self):
        self.net_duplicate_state = -1
        
        if self.session.wait_for == WAIT_FOR_DUPLICATE_FINISH:
            self.session.endTimerIfLastExpected(self)
            
    
    def setStatus(self, status):
        #CLIENT_STATUS_COPY is not a status as the other ones.
        #GUI needs to know if client is started/open/stopped while files are copied
        #so self.status doesn't remember CLIENT_STATUS_COPY, although it is sent to GUI
        
        if status != CLIENT_STATUS_COPY:
            self.status = status
            self.sendStatusToGui()
        
        if status == CLIENT_STATUS_COPY or self.session.file_copier.isActive(self.client_id):
            self.sendGui("/ray/client/status", self.client_id, CLIENT_STATUS_COPY)
    
    def getJackClientName(self):
        jack_client_name = self.name
        
        numid = ''
        if '_' in self.client_id:
            numid = self.client_id.rpartition('_')[2]
        if numid.isdigit():
            jack_client_name += '_'
            jack_client_name += numid
        
        return jack_client_name
    
    def getProjectPath(self):
        if self.executable_path == 'ray-network':
            #for ray-network, use project_path for template, quite ugly but simple code.
            return self.net_session_template
        
        if self.prefix_mode == PREFIX_MODE_SESSION_NAME:
            return "%s/%s.%s" % (self.session.path, self.session.name, self.client_id)
        elif self.prefix_mode == PREFIX_MODE_CLIENT_NAME:
            return "%s/%s.%s" % (self.session.path, self.name, self.client_id)
        else:
            current_dir = os.getcwd()
            os.chdir(self.session.path)
            project_path = os.path.realpath(self.project_path)
            os.chdir(current_dir)
            
            return project_path
    
    def start(self):
        self.session.setRenameable(False)
        
        self.last_dirty = 0.00
        
        if self.is_dummy:
            return
        
        self.sendGuiMessage(_translate("GUIMSG", "%s launching") % self.guiMsgStyle())
        
        #if 'server' in globals() and hasattr(server, 'url'):
            #os.environ['NSM_URL'] = server.url
        
        self.pending_command = COMMAND_START
        
        arguments = []
        
        if self.tmp_arguments:
            arguments += shlex.split(self.tmp_arguments)
            
        if self.arguments:
            arguments += shlex.split(self.arguments)
        
        if self.hasServer() and self.executable_path == 'ray-network':
            arguments.append('--net-daemon-id')
            arguments.append(str(server.net_daemon_id))
            
        self.process.start(self.executable_path, arguments)
        #self.process.start('konsole', ['--hide-tabbar', '--hide-menubar', '-e', self.executable_path] + arguments)
     
    def terminate(self):
        if self.isRunning():
            self.process.terminate()
        
    def kill(self):
        if self.isRunning():
            self.process.kill()
            
    def isRunning(self):
        return bool(self.process.state() == 2)
    
    def standardError(self):
        standard_error = self.process.readAllStandardError().data()
        CLIENT_MESSAGE(standard_error, self.name, self.client_id)
        
    def standardOutput(self):
        standard_output = self.process.readAllStandardOutput().data()
        CLIENT_MESSAGE(standard_output, self.name, self.client_id)
    
    def processStarted(self):
        self.stopped_since_long = False
        self.pid    = self.process.pid()
        self.setStatus(CLIENT_STATUS_LAUNCH)
        
        #MESSAGE("Process has pid: %i" % self.pid)
        
        
        if self.session.osc_src_addr:
            self.session.oscReply("/reply", self.session.osc_path, ERR_OK, "Launched." )
        
    
    def processFinished(self, exit_code, exit_status):
        self.stopped_timer.stop()
        
        if self.pending_command in (COMMAND_KILL, COMMAND_QUIT):
            self.sendGuiMessage(_translate('GUIMSG', "%s terminated as planned") % self.guiMsgStyle())
            #self.sendGuiMessage(_translate('GUIMSG', "Client %s (%s) terminated because we told it to.") % (self.name, self.client_id))
        else:
            self.sendGuiMessage(_translate('GUIMSG', "%s died unexpectedly.") % self.guiMsgStyle())
        
        if self.session.wait_for:
            self.session.endTimerIfLastExpected(self)
        
        if self.pending_command == COMMAND_QUIT:
            self.session.removeClient(self)
            return
        else:
            self.setStatus(CLIENT_STATUS_STOPPED)
                
        self.pending_command = COMMAND_NONE
        self.active          = False
        self.pid             = 0
        
        self.session.setRenameable(True)
        
    def errorInProcess(self, error):
        if error == QProcess.FailedToStart:
            self.sendGuiMessage(_translate('GUIMSG', "%s Failed to start !") % self.guiMsgStyle())
            self.active     = False
            self.pid        = 0
            self.setStatus(CLIENT_STATUS_STOPPED)
            self.pending_command = COMMAND_NONE
            
            #if self.session.osc_src_addr:
                ##Finally, not sure that it's a good idea to display error dialog in this case.
                #self.session.oscReply("/error", self.session.osc_path, ERR_LAUNCH_FAILED, "Failed to launch process!")
            
            if self.session.wait_for:
                self.session.endTimerIfLastExpected(self)
        
        self.session.setRenameable(True)
    
    def stoppedSinceLong(self):
        self.stopped_since_long = True
        self.sendGui('/ray/client/still_running', self.client_id)
    
    def tellClientSessionIsLoaded(self):
        if self.active and not self.isDumbClient():
            MESSAGE("Telling client %s that session is loaded." % self.name)
            self.sendToSelfAddress("/nsm/client/session_is_loaded")
    
    def save(self):
        if self.active:
            MESSAGE("Telling %s to save" % self.name)
            self.sendToSelfAddress("/nsm/client/save")
            
            self.pending_command = COMMAND_SAVE
            self.setStatus(CLIENT_STATUS_SAVE)
        
        elif self.isDumbClient() and self.isRunning():
            self.status = CLIENT_STATUS_NOOP
            self.sendStatusToGui()
            
        if self.isCapableOf(':optional-gui:'):
            self.start_gui_hidden = not bool(self.gui_visible)
            
    def stop(self):
        self.sendGuiMessage(_translate('GUIMSG', "%s stopping") % self.guiMsgStyle())
        if self.isRunning():
            self.pending_command = COMMAND_KILL
            self.setStatus(CLIENT_STATUS_QUIT)
            self.process.terminate()
            
            if not self.stopped_timer.isActive():
                self.stopped_timer.start()
    
    def quit(self):
        MESSAGE("Commanding %s to quit" % self.name)
        if self.active:
            
            self.pending_command = COMMAND_QUIT
            self.terminate()
            self.setStatus(CLIENT_STATUS_QUIT)
        
        elif self.isDumbClient():
            if self.isRunning():
                self.pending_command = COMMAND_QUIT
                self.terminate()
                self.setStatus(CLIENT_STATUS_QUIT)
            else:
                self.sendGui("/ray/client/status", self.client_id, CLIENT_STATUS_REMOVED)
    
    def switch(self, new_client):
        old_client_id     = self.client_id
        self.client_id    = new_client.client_id
        self.name         = new_client.name
        self.prefix_mode  = new_client.prefix_mode
        self.project_path = new_client.project_path
        self.label        = new_client.label
        self.icon         = new_client.icon
        
        jack_client_name    = self.getJackClientName()
        client_project_path = self.getProjectPath()
        
        MESSAGE("Commanding %s to switch \"%s\"" % (self.name, client_project_path))
        
        self.sendToSelfAddress("/nsm/client/open", client_project_path,  self.session.name, jack_client_name)
        
        
        self.pending_command = COMMAND_OPEN
        self.setStatus(CLIENT_STATUS_SWITCH)
            
        self.sendGui("/ray/client/switch", old_client_id, self.client_id)
    
    def sendGuiClientProperties(self, removed=False):
        ad = '/ray/client/update' if self.sent_to_gui else '/ray/client/new'
            
        if removed:
            ad = '/ray/trash/add'
            
        self.sendGui(ad,
                        self.client_id, 
                        self.executable_path,
                        self.arguments,
                        self.name, 
                        self.prefix_mode, 
                        self.project_path,
                        self.label,
                        self.icon,
                        self.capabilities,
                        int(self.check_last_save))
        
        self.sent_to_gui = True
    
    def updateClientProperties(self, client_data):
        self.client_id       = client_data.client_id
        self.executable_path = client_data.executable_path
        self.arguments       = client_data.arguments
        self.prefix_mode     = client_data.prefix_mode
        self.project_path    = client_data.project_path
        self.label           = client_data.label
        self.icon            = client_data.icon
        self.capabilities    = client_data.capabilities
        self.check_last_save = client_data.check_last_save
        
        self.sendGuiClientProperties()
    
    def prettyClientId(self):
        wanted = self.client_id
        
        if self.executable_path == 'ray-proxy':
            proxy_file = "%s/ray-proxy.xml" % self.getProjectPath()
            
            if os.path.exists(proxy_file):
                file = open(proxy_file, 'r')
                xml = QDomDocument()
                xml.setContent(file.read())
                file.close()
                
                content = xml.documentElement()
                if content.tagName() == 'RAY-PROXY':
                    executable = content.attribute('executable')
                    if executable:
                        wanted = executable
            
            
        if '_' in wanted:
            begin, udsc, end = wanted.rpartition('_')
            
            if not end:
                return wanted
            
            if not end.isdigit():
                return wanted
            
            return begin
        
        return wanted
    
    def getProjectFiles(self):
        #return a list of full filenames
        client_files = []
        
        project_path = self.getProjectPath()
        if os.path.exists(project_path):
            client_files.append(project_path)
            
        if project_path.startswith('%s/' % self.session.path):
            base_project = project_path.replace('%s/' % self.session.path, '', 1)
            
            for filename in os.listdir(self.session.path):
                if filename == base_project:
                    full_file_name =  "%s/%s" % (self.session.path, filename)
                    if not full_file_name in client_files:
                        client_files.append(full_file_name)
                        
                elif filename.startswith('%s.' % base_project):
                    client_files.append('%s/%s' % (self.session.path, filename))
                    
        return client_files
            
    def saveAsTemplate(self, template_name):
        #copy files
        if self.prefix_mode != PREFIX_MODE_UNDEF:
            client_files = self.getProjectFiles()
                        
            template_dir = "%s/%s" % (client_template_local_root, template_name)
            
            if os.path.exists(template_dir):
                if os.access(template_dir, os.W_OK):
                    shutil.rmtree(template_dir)
                else:
                    #TODO send error
                    return
                
            os.makedirs(template_dir)
            
            if self.net_daemon_url:
                self.net_session_template = template_name
                self.send(Address(self.net_daemon_url), '/ray/session/save_as_template', self.session.name, template_name, self.net_session_root)
            
            #if self.net_daemon_url:
                #server.send(Address(self.net_daemon_url), '/ray/serve')
            #if self.isCapableOf(':ray-network:'):
                #if self.active:
                    #self.sendToSelfAddress('/nsm/client/save_as_template', template_name)
                    #self.net_session_template = template_name
            
            if client_files:
                self.setStatus(CLIENT_STATUS_COPY)
                self.session.file_copier.startClientCopy(self.client_id, client_files, template_dir, self.saveAsTemplate_step1, self.saveAsTemplateAborted, [template_name])
            else:
                self.saveAsTemplate_step1(template_name)

    def saveAsTemplate_step1(self, template_name):
        self.setStatus(self.status) #see setStatus to see why
        
        if self.prefix_mode != PREFIX_MODE_UNDEF:
            self.adjustFilesAfterCopy(template_name, TEMPLATE_CLIENT_SAVE)
            
        xml_file = "%s/%s" % (client_template_local_root, 'client_templates.xml')
        
        #security check
        if os.path.exists(xml_file):
            if not os.access(xml_file, os.W_OK):
                return
            
            if os.path.isdir(xml_file):
                #should not be a dir, remove it !
                subprocess.run('rm', '-R', xml_file)
        
        
        if not os.path.isdir(client_template_local_root):
            os.makedirs(client_template_local_root)
        
        #create client_templates.xml if not exists
        if not os.path.isfile(xml_file):
            file = open(xml_file, 'w')
            
            xml = QDomDocument()
            rct = xml.createElement('RAY-CLIENT-TEMPLATES')
            xml.appendChild(rct)
            file.write(xml.toString())
            file.close()
            del xml
            
        file = open(xml_file, 'r')
        xml = QDomDocument()
        xml.setContent(file.read())
        file.close()
        content = xml.documentElement()
                
        if not content.tagName() == 'RAY-CLIENT-TEMPLATES':
            return
        
        
        #remove existing template if it has the same name as the new one
        node = content.firstChild()
        while not node.isNull():
            if node.toElement().tagName() != 'Client-Template':
                node = node.nextSibling()
                continue
            
            if node.toElement().attribute('template-name') == template_name:
                content.removeChild(node)
            
            node = node.nextSibling()
        
        #create template
        rct = xml.createElement('Client-Template')
        
        self.writeXmlProperties(rct)
        rct.setAttribute('template-name', template_name)
        rct.setAttribute('client_id', self.prettyClientId())
        
        if not self.isRunning():
            rct.setAttribute('launched', False)
            
        content.appendChild(rct)
        
        file = open(xml_file, 'w')
        file.write(xml.toString())
        file.close()
    
    def saveAsTemplateAborted(self, template_name):
        self.setStatus(self.status)
    
    def adjustFilesAfterCopy(self, new_session_full_name, template_save=TEMPLATE_NONE):            
        old_session_name = self.session.name
        new_session_name = basename(new_session_full_name)
        new_client_id    = self.client_id
        old_client_id    = self.client_id
        xsessionx   = "XXX_SESSION_NAME_XXX"
        xclient_idx = "XXX_CLIENT_ID_XXX"
        
        if template_save == TEMPLATE_NONE:
            if self.prefix_mode != PREFIX_MODE_SESSION_NAME:
                return
            
            spath = "%s/%s" % (self.session.root, new_session_full_name)
        
        elif template_save == TEMPLATE_RENAME:
            spath = self.session.path
            
        elif template_save == TEMPLATE_SESSION_SAVE:
            spath = "%s/%s" % (session_template_root, new_session_full_name)
            new_session_name = xsessionx
        
        elif template_save == TEMPLATE_SESSION_SAVE_NET:
            spath = "%s/%s/%s" % (self.session.root , session_template_net_rootname, new_session_full_name)
            new_session_name = xsessionx
        
        elif template_save == TEMPLATE_SESSION_LOAD:
            spath = "%s/%s" % (self.session.root, new_session_full_name)
            old_session_name = xsessionx
        
        elif template_save == TEMPLATE_SESSION_LOAD_NET:
            spath = "%s/%s" % (self.session.root, new_session_full_name)
            old_session_name = xsessionx
        
        elif template_save == TEMPLATE_CLIENT_SAVE:
            spath = "%s/%s" % (client_template_local_root, new_session_full_name)
            new_session_name = xsessionx
            new_client_id    = xclient_idx
           
        elif template_save == TEMPLATE_CLIENT_LOAD:
            spath = self.session.path
            old_session_name = xsessionx
            old_client_id    = xclient_idx
        
        old_prefix = old_session_name
        new_prefix = new_session_name
        
        if self.prefix_mode == PREFIX_MODE_CLIENT_NAME:
            old_prefix = new_prefix = self.name
        
        project_path = "%s/%s.%s" % (spath, old_prefix, old_client_id)
        
        if not os.path.exists(project_path):
            for file in os.listdir(spath):
                if ( file.startswith("%s.%s." % (old_prefix, old_client_id)) or
                    file == "%s.%s" %(old_prefix, old_client_id) ):
                    
                    if not os.access("%s/%s" % (spath, file), os.W_OK):
                        continue
                    
                    endfile = file.replace("%s.%s." % (old_prefix, old_client_id), '', 1)
                    
                    os.rename('%s/%s' %(spath, file), "%s/%s.%s.%s" % (spath, new_prefix, new_client_id, endfile))
            return
        
        if not os.path.isdir(project_path):
            if not os.access(project_path, os.W_OK):
                return
            
            os.rename(project_path, "%s/%s.%s" % (spath, new_prefix, new_client_id))
            return
        
        #only for ardour
        ardour_file  = "%s/%s.ardour"     % (project_path, old_prefix)
        ardour_bak   = "%s/%s.ardour.bak" % (project_path, old_prefix)
        ardour_audio = "%s/interchange/%s.%s" % (project_path, old_prefix, old_client_id)
        
        if os.path.isfile(ardour_file) and os.access(ardour_file, os.W_OK):
            os.rename(ardour_file, "%s/%s.ardour" % (project_path, new_prefix))
        if os.path.isfile(ardour_bak) and os.access(ardour_bak, os.W_OK):
            os.rename(ardour_bak, "%s/%s.ardour.bak" % (project_path, new_prefix))
        if os.path.isdir(ardour_audio and os.access(ardour_audio, os.W_OK)):
            os.rename(ardour_audio, "%s/interchange/%s.%s" % (project_path, new_prefix, new_client_id))
        
        #change last_used snapshot of ardour
        instant_file = "%s/instant.xml" % project_path
        if os.path.isfile(instant_file) and os.access(instant_file, os.W_OK):
            try :
                file = open(instant_file, 'r')
                xml = QDomDocument()
                xml.setContent(file.read())
                content = xml.documentElement()
                
                if content.tagName() == 'instant':
                    node = content.firstChild()
                    while not node.isNull():
                        tag = node.toElement()
                        if tag.tagName() == 'LastUsedSnapshot':
                            if tag.attribute('name') == old_prefix:
                                tag.setAttribute('name', new_prefix)
                                file = open(instant_file, 'w')
                                file.write(xml.toString())
                            break
                            
                        node = node.nextSibling()
                file.close()
            except:
                False
        
        #for Vee One Suite
        for extfile in ('samplv1', 'synthv1', 'padthv1', 'drumkv1'):
            old_veeone_file = "%s/%s.%s" % (project_path, old_session_name, extfile)
            new_veeone_file = "%s/%s.%s" % (project_path, new_session_name, extfile)
            if os.path.isfile(old_veeone_file) and os.access(old_veeone_file, os.W_OK) and not os.path.exists(new_veeone_file):
                os.rename(old_veeone_file, new_veeone_file)
        
        
        #for ray-proxy, change config_file name
        proxy_file = "%s/ray-proxy.xml" % project_path
        if os.path.isfile(proxy_file):
            try:
                file = open(proxy_file, 'r')
                xml = QDomDocument()
                xml.setContent(file.read())
                content = xml.documentElement()
                
                if content.tagName() == "RAY-PROXY":
                    cte = content.toElement()
                    config_file = cte.attribute('config_file')
                    
                    if ('$RAY_SESSION_NAME' or '${RAY_SESSION_NAME}') in config_file:
                        for env in ('"$RAY_SESSION_NAME"', '"${RAY_SESSION_NAME}"', "$RAY_SESSION_NAME", "${RAY_SESSION_NAME}"):
                            config_file = config_file.replace(env, old_session_name)
                        
                        if config_file and config_file.split('.')[0] == old_session_name:
                            config_file_path = "%s/%s" % (project_path, config_file)
                            
                            if os.path.exists(config_file_path) and os.access(config_file_path, os.W_OK):
                                os.rename(config_file_path, "%s/%s" % (project_path, config_file.replace(old_session_name, new_session_name)))
                                            
                file.close()
                        
            except:
                False
        
        if os.access(project_path, os.W_OK):
            subprocess.run(['mv', project_path, "%s/%s.%s" % (spath, new_prefix, new_client_id)])
    
    def serverAnnounce(self, path, args, src_addr, is_new):
        client_name, capabilities, executable_path, major, minor, pid = args
        
        if self.pending_command in (COMMAND_QUIT, COMMAND_KILL):
            return
        
        if major > NSM_API_VERSION_MAJOR:
            MESSAGE("Client is using incompatible and more recent API version %i.%i" % (major, minor))
            self.send(src_addr, "/error", path, ERR_INCOMPATIBLE_API, "Server is using an incompatible API version." )
            return
        
        #self.pid          = pid
        self.capabilities = capabilities
        self.addr         = src_addr
        self.name         = client_name
        self.active       = True
        self.did_announce = True
        
        if self.executable_path in known_as_non_active:
            known_as_non_active.remove(self.executable_path)
        
        MESSAGE("Process has pid: %i" % pid )
        MESSAGE("The client \"%s\" at \"%s\" informs us it's ready to receive commands." % (self.name, self.addr.url) )
        self.send(src_addr, "/reply", path, "Well hello, stranger. Welcome to the party." if is_new else "Howdy, what took you so long?", APP_TITLE, ":server-control:broadcast:optional-gui:" )
        
        self.sendGuiClientProperties()
        self.setStatus(CLIENT_STATUS_OPEN)
        
        if self.isCapableOf(":optional-gui:"):
            self.sendGui("/ray/client/has_optional_gui", self.client_id)
            
            if self.start_gui_hidden:
                self.send(src_addr, "/nsm/client/hide_optional_gui")
                
        jack_client_name    = self.getJackClientName()
        client_project_path = self.getProjectPath()
        
        self.send(src_addr, "/nsm/client/open", client_project_path,  self.session.name, jack_client_name)
        self.pending_command = COMMAND_OPEN
       
class Session(ServerSender):
    def __init__(self, root):
        ServerSender.__init__(self)
        self.root = root
        self.is_dummy = False
        
        self.clients = []
        self.new_clients = []
        self.removed_clients = []
        self.name    = ""
        self.path    = ""
        #self.root    = ""
        
        self.is_renameable = True
        self.forbidden_ids_list = []
        
        self.file_copier = FileCopier(self)
    
    #############
    def oscReply(self, *args):
        if not self.osc_src_addr:
            return
        
        if not 'server' in globals():
            return
        
        server.send(self.osc_src_addr, *args)
    
    def setRenameable(self, renameable):
        if not renameable:
            if self.is_renameable:
                self.is_renameable = False
                if self.hasServer():
                    server.sendRenameable(False)
            return
        
        for client in self.clients:
            if client.isRunning():
                return
            
        self.is_renameable = True
        if self.hasServer():
            server.sendRenameable(True)
    
    def message(self, string, even_dummy=False):
        if self.is_dummy and not even_dummy:
            return
        
        MESSAGE(string)
        
    def setRoot(self, session_root):
        if self.name:
            return
        self.root = session_root
    
    def setName(self, session_name):
        self.name = session_name
    
    def setPath(self, session_path):
        self.path = session_path
        self.setName(session_path.rpartition('/')[2])
        multi_daemon_file.update()
    
    def getClient(self, client_id):
        for client in self.clients:
            if client.client_id == client_id:
                return client
        else:
            ifDebug("client_id %s is not in ray-daemon session")
    
    def getClientByAddress(self, addr):
        if not addr:
            return None
        
        for client in self.clients:
            if client.addr and client.addr.url == addr.url:
                return client
    
    def getClientByExecutable(self, executable):
        for client in self.clients:
            if client.executable_path == executable:
                return client
    
    def getClientByExecutableAndId(self, executable, client_id):
        for client in self.clients:
            if client.client_id == client_id and client.executable_path == executable:
                return client
    
    def newClient(self, executable, client_id=None):
        client = Client(self)
        client.executable_path = executable
        client.name = basename(executable)
        client.client_id = client_id if client_id else self.generateClientId(executable)
        self.clients.append(client)
        return client
    
    def removeClient(self, client):
        if not client in self.clients:
            return
        
        client.setStatus(CLIENT_STATUS_REMOVED)
        
        if client.getProjectFiles() or client.net_daemon_url:
            self.removed_clients.append(client)
            client.sendGuiClientProperties(removed=True)
        
        self.clients.remove(client)
    
    def restoreClient(self, client):
        client.sent_to_gui = False
        
        if not self.addClient(client):
            return
        
        self.sendGui('/ray/trash/remove', client.client_id)
        self.removed_clients.remove(client)
        
        if client.auto_start:
            client.start()
    
    def tellAllClientsSessionIsLoaded(self):
        self.message("Telling all clients that session is loaded...")
        for client in self.clients:
            client.tellClientSessionIsLoaded()
    
    def purgeInactiveClients(self):
        remove_item_list = []
        for i in range(len(self.clients)):
            if not self.clients[i].active:
                self.sendGui("/ray/client/status", self.clients[i].client_id, CLIENT_STATUS_REMOVED)
                remove_item_list.append(i)
        
        remove_item_list.reverse()
        
        for i in remove_item_list:
            self.clients.__delitem__(i)
            
        del remove_item_list
            
    def clientsHaveErrors(self):
        for client in self.clients:
            if client.active and client.hasError():
                return True
        return False
    
    def updateForbiddenIdsList(self):
        if not self.path:
            return
        
        self.forbidden_ids_list.clear()
        
        for file in os.listdir(self.path):
            if os.path.isdir("%s/%s" % (self.path, file)) and '.' in file:
                client_id = file.rpartition('.')[2]
                if not client_id in self.forbidden_ids_list:
                    self.forbidden_ids_list.append(client_id)
                    
            elif os.path.isfile("%s/%s" % (self.path, file)) and '.' in file:
                for string in file.split('.')[1:]:
                    if not string in self.forbidden_ids_list:
                        self.forbidden_ids_list.append(string)
                        
        for client in self.clients + self.removed_clients:
            if not client.client_id in self.forbidden_ids_list:
                self.forbidden_ids_list.append(client.client_id)
    
    def generateClientIdAsNsm(self):
        client_id = 'n'
        for l in range(4):
            client_id += random.choice(string.ascii_uppercase)
            
        return client_id
    
    def generateClientId(self, wanted_id=""):
        self.updateForbiddenIdsList()
        
        wanted_id = basename(wanted_id)
        
        if wanted_id:
            for to_rm in ('ray-', 'non-', 'carla-'):
                if wanted_id.startswith(to_rm):
                    wanted_id = wanted_id.replace(to_rm, '', 1)
                    break
            
            wanted_id = wanted_id.replace('jack', '')
            
            #reduce string if contains '-'
            if '-' in wanted_id:
                new_wanted_id = ''
                seplist = wanted_id.split('-')
                for sep in seplist[:-1]:
                    if len(sep) > 0:
                        new_wanted_id += (sep[0] + '_')
                new_wanted_id += seplist[-1]
                wanted_id = new_wanted_id
            
            
            #prevent non alpha numeric characters
            new_wanted_id = ''
            last_is_ = False
            for char in wanted_id:
                if char.isalnum():
                    new_wanted_id += char
                else:
                    if not last_is_:
                        new_wanted_id += '_'
                        last_is_ = True
            
            wanted_id = new_wanted_id
            
            while wanted_id and wanted_id.startswith('_'):
                wanted_id = wanted_id[1:]
            
            while wanted_id and wanted_id.endswith('_'):
                wanted_id = wanted_id[:-1]
            
            if not wanted_id:
                wanted_id = self.generateClientIdAsNsm()
                while wanted_id in self.forbidden_ids_list:
                    wanted_id = self.generateClientIdAsNsm()
            
            #limit string to 10 characters
            if len(wanted_id) >= 11:
                wanted_id = wanted_id[:10]
            
            if not wanted_id in self.forbidden_ids_list:
                self.forbidden_ids_list.append(wanted_id)
                return wanted_id
            
            n=2
            while "%s_%i" % (wanted_id, n) in self.forbidden_ids_list:
                n+=1
            
            self.forbidden_ids_list.append(wanted_id)
            return "%s_%i" % (wanted_id, n)
                
                
        client_id = 'n'
        for l in range(4):
            client_id += random.choice(string.ascii_uppercase)
        
        while client_id in self.forbidden_ids_list:
            client_id = 'n'
            for l in range(4):
                client_id += random.choice(string.ascii_uppercase)
        
        self.forbidden_ids_list.append(client_id)
        return client_id
    
    def getListOfExistingClientIds(self):
        if not self.path:
            return []
        
        client_ids_list = []
        
        for file in os.listdir(self.path):
            if os.path.isdir(file) and file.contains('.'):
                client_ids_list.append(file.rpartition('.')[2])
            elif os.path.isfile(file) and file.contains('.'):
                file_without_extension = file.rpartition('.')[0]
                
    
    def addClient(self, client):
        self.clients.append(client)
        client.sendGuiClientProperties()
        return True
        
    def reOrderClients(self, client_ids_list):
        client_newlist  = []
        
        for client_id in client_ids_list:
            for client in self.clients:
                if client.client_id == client_id:
                    client_newlist.append(client)
                    break
        
        if len(client_ids_list) != len(self.clients):
            return
        
        self.clients.clear()
        for client in client_newlist:
            self.clients.append(client)

class OperatingSession(Session):
    #Session is separated in 3 parts only for faster search and modifications.
    def __init__(self, root):
        Session.__init__(self, root)
        self.wait_for = WAIT_FOR_NONE
        
        self.timer = QTimer()
        self.expected_clients = []
        
        self.timer_launch = QTimer()
        self.timer_launch.setInterval(100)
        self.timer_launch.timeout.connect(self.timerLaunchTimeOut)
        self.clients_to_launch = []
        
        self.timer_quit = QTimer()
        self.timer_quit.setInterval(100)
        self.timer_quit.timeout.connect(self.timerQuitTimeOut)
        self.clients_to_quit = []
        
        self.err_loading = ERR_OK
        self.err_saving  = ERR_OK
        
        self.osc_path     = None
        self.osc_args     = None
        self.osc_src_addr = None
        
        self.process_order = []
        
        self.terminated_yet = False
        
    def rememberOscArgs(self, path, args, src_addr):
        self.osc_path     = path
        self.osc_args     = args
        self.osc_src_addr = src_addr
    
    def waitAndGoTo(self, duration, follow, wait_for, single_shot=True):
        self.timer.stop()
        
        #we need to delete timer to change the timeout connect
        del self.timer
        self.timer = QTimer()
        
        if type(follow) in (list, tuple):
            if len(follow) == 0:
                return
            elif len(follow) == 1:
                follow = follow[0]
            else:
                follow = functools.partial(follow[0], *follow[1:])
        
        if self.expected_clients:
            if wait_for == WAIT_FOR_ANNOUNCE:
                self.sendGuiMessage(_translate('GUIMSG', 'waiting for clients announces...'))
            elif wait_for == WAIT_FOR_STOP:
                self.sendGuiMessage(_translate('GUIMSG', 'waiting for clients to die...'))
            
            self.wait_for = wait_for
            self.timer.setSingleShot(True)
            self.timer.timeout.connect(follow)
            self.timer.start(duration)
        else:
            follow()
    
    def endTimerIfLastExpected(self, client):
        if client in self.expected_clients:
            self.expected_clients.remove(client)
        if not self.expected_clients:
            self.timer.setSingleShot(True)
            self.timer.stop()
            self.timer.start(0)
    
    def cleanExpected(self):
        if self.expected_clients:
            client_names = ""
            for client in self.expected_clients:
                client_names += client.name + ', ' 
            
            if self.wait_for == WAIT_FOR_ANNOUNCE:
                self.sendGuiMessage(_translate('GUIMSG', "%sdidn't announce") % client_names)
            elif self.wait_for == WAIT_FOR_STOP:
                self.sendGuiMessage(_translate('GUIMSG', "%sstill alive !") % client_names)
                
            self.expected_clients.clear()
        else:
            if self.wait_for == WAIT_FOR_ANNOUNCE:
                self.sendGuiMessage(_translate('GUIMSG', 'All expected clients are announced'))
            elif self.wait_for == WAIT_FOR_STOP:
                self.sendGuiMessage(_translate('GUIMSG', 'All expected clients are died'))
        self.wait_for = WAIT_FOR_NONE
    
    def nextFunction(self):
        if len(self.process_order) > 0:
            next_item = self.process_order[0]
            next_function = next_item
            arguments = []
            
            if type(next_item) in (tuple, list):
                if len(next_item) == 0:
                    return
                else:
                    next_function = next_item[0]
                    if len(next_item) > 1:
                        arguments = next_item[1:]
            
            
            self.process_order.__delitem__(0)
            next_function(*arguments)
    
    def timerLaunchTimeOut(self):
        if self.clients_to_launch:
            waitForJack()
            self.clients_to_launch[0].start()
            self.clients_to_launch.__delitem__(0)
            
        if not self.clients_to_launch:
            self.timer_launch.stop()
            
    def timerQuitTimeOut(self):
        if self.clients_to_quit:
            waitForJack()
            self.clients_to_quit[0].quit()
            self.clients_to_quit.__delitem__(0)
            
        if not self.clients_to_quit:
            self.timer_quit.stop()
    
    def sendError(self, err, error_message):
        #clear process order to allow other new operations
        self.process_order.clear()
        
        if not (self.osc_src_addr or self.osc_path):
            return
        
        self.oscReply("/error", self.osc_path, err, error_message)
    
    def adjustFilesAfterCopy(self, new_session_full_name, template_mode):
        #new_session_full_name = self.osc_args[0]
        new_session_name = basename(new_session_full_name)
        spath = "%s/%s" % (self.root, new_session_full_name)
        
        #create temp clients from raysession.xml to adjust Files after copy
        session_file = "%s/%s" % (spath, "raysession.xml")
        
        try:
            ray_file = open(session_file, 'r')
        except:
            self.sendError(ERR_BAD_PROJECT, _translate("error", "impossible to read %s") % session_file)
            return
        
        tmp_clients = []
        
        xml = QDomDocument()
        xml.setContent(ray_file.read())

        content = xml.documentElement()
        
        if content.tagName() != "RAYSESSION":
            ray_file.close()
            self.err_loading = ERR_BAD_PROJECT
            self.loadError()
            return
        
        content.setAttribute('name', new_session_name)
        
        node = content.firstChild()
        while not node.isNull():
            tag_name = node.toElement().tagName()
            if tag_name in ('Clients', 'RemovedClients'):
                client_xml = node.toElement().firstChild()
                while not client_xml.isNull():
                    client = Client(self)
                    cx = client_xml.toElement()
                    client.readXmlProperties(cx)
                    
                    tmp_clients.append(client)
                    
                    client_xml = client_xml.nextSibling()
                    
            node = node.nextSibling()
        
        ray_file.close()
        
        ray_file_w = open(session_file, 'w')
        ray_file_w.write(xml.toString())
        ray_file_w.close()
        
        
        for client in tmp_clients:
            client.adjustFilesAfterCopy(new_session_full_name, template_mode)
    
    
    ############################## COMPLEX OPERATIONS ###################
    #all functions are splitted when we need to wait clients for something (announce, reply, quit)
    #for example, at the end of save(), timer is launched, 
    #then, when timer is timeout or when all client replied, save_step1 is launched
        
    def save(self, from_client_id=''):
        if not self.path:
            self.nextFunction()
            return
        
        self.setServerStatus(SERVER_STATUS_SAVE)
        
        for client in self.clients:
            if from_client_id and client.client_id == from_client_id:
                continue
            
            if client.active:
                self.expected_clients.append(client)
                client.save()
                
        self.waitAndGoTo(10000, self.save_step1, WAIT_FOR_REPLY)
            
    def save_step1(self):
        self.cleanExpected()
        
        if not self.path:
            self.nextFunction()
            return
        
        session_file = self.path + '/raysession.xml'
        if os.path.isfile(session_file) and not os.access(session_file, os.W_OK):
            self.err_saving = ERR_CREATE_FAILED
            self.saveError()
            return
        
        try:
            file = open(session_file, 'w')
        except:
            self.err_saving = ERR_CREATE_FAILED
            self.saveError()
            return
        
        self.err_saving = ERR_OK
        
        xml = QDomDocument()
        p = xml.createElement('RAYSESSION')
        p.setAttribute('VERSION', VERSION)
        p.setAttribute('name', self.name)
        
        xml_cls = xml.createElement('Clients')
        xml_rmcls = xml.createElement('RemovedClients')
        
        for client in self.clients:
            cl = xml.createElement('client')
            cl.setAttribute('id', client.client_id)
            cl.setAttribute('launched', int(bool(client.isRunning())) )
            
            client.writeXmlProperties(cl)
            
            xml_cls.appendChild(cl)
            
        for client in self.removed_clients:
            cl = xml.createElement('client')
            cl.setAttribute('id', client.client_id)
            
            client.writeXmlProperties(cl)
            
            xml_rmcls.appendChild(cl)
            
        p.appendChild(xml_cls)
        p.appendChild(xml_rmcls)
        xml.appendChild(p)
        
        contents = ("<?xml version='1.0' encoding='UTF-8'?>\n"
                    "<!DOCTYPE RAYSESSION>\n")
        
        contents += xml.toString()
        
        
        file.write(contents)
        file.close()
        
        self.sendGuiMessage(_translate('GUIMSG', "Session saved."))
        self.message("Session saved.")
        self.nextFunction()
    
    def saveDone(self):
        if not self.err_loading:
            self.message("Done.")
            self.oscReply("/reply", self.osc_path, "Saved." )
        self.setServerStatus(SERVER_STATUS_READY)
    
    def saveError(self):
        self.message("Failed")
        m = _translate('Load Error', "Unknown error")
        if self.err_saving == ERR_CREATE_FAILED:
            m = _translate('GUIMSG', "Can't save session, session file is unwriteable !")
        
        self.message(m)
        self.sendGuiMessage(m)
        self.oscReply("/error", self.osc_path, ERR_CREATE_FAILED, m)
        
        self.process_order.clear()
        self.setServerStatus(SERVER_STATUS_READY)
        
    def close(self):
        self.sendGuiMessage(_translate('GUIMSG', "Commanding attached clients to quit."))
        self.expected_clients.clear()
        self.removed_clients.clear()
        
        if not self.path:
            self.nextFunction()
            return
        
        self.setServerStatus(SERVER_STATUS_CLOSE)
        self.sendGui('/ray/trash/clear')
        
        
        for client in self.clients.__reversed__():
            if client.isRunning():
                self.expected_clients.append(client)
                self.clients_to_quit.append(client)
                self.timer_quit.start()
        
        self.waitAndGoTo(30000, self.close_step1, WAIT_FOR_STOP)
    
    def close_step1(self):
        for client in self.expected_clients:
            client.kill()
            
        self.waitAndGoTo(1000, self.close_step2, WAIT_FOR_STOP)
    
    def close_step2(self):
        self.cleanExpected()
        
        self.purgeInactiveClients()
        self.clients.clear()
        
        if self.path:
            lock_file =  self.path + '/.lock'
            if os.path.isfile(lock_file):
                os.remove(lock_file)
                
        self.setPath('')
            
        self.sendGui("/ray/gui/session/name", "", "" )
        self.nextFunction()
    
    def closeDone(self):
        self.oscReply("/reply", self.osc_path, "Closed.")
        self.message("Done")
        self.setServerStatus(SERVER_STATUS_OFF)
    
    def abortDone(self):
        self.oscReply("/reply", self.osc_path, "Aborted.")
        self.message("Done")
        self.setServerStatus(SERVER_STATUS_OFF)
        
    def new(self, new_session_name):
        self.sendGuiMessage(_translate('GUIMSG', "Creating new session \"%s\"") % new_session_name)
        spath = self.root + '/' + new_session_name
        
        try:
            os.makedirs(spath)
        except:
            self.oscReply("/error", self.osc_path, ERR_CREATE_FAILED, "Could not create the session directory" )
            return
        
        self.setServerStatus(SERVER_STATUS_NEW)
        self.setPath(spath)
        self.oscReply("/reply", self.osc_path, "Created." )
        self.sendGui("/ray/gui/session/session", new_session_name)
        self.sendGui("/ray/gui/session/name", new_session_name, new_session_name)
        
        self.oscReply("/reply", self.osc_path, "Session created")
        self.nextFunction()
    
    def newDone(self):
        self.sendGuiMessage(_translate('GUIMSG', 'Session is ready'))
        self.setServerStatus(SERVER_STATUS_READY)
    
    def duplicate(self, new_session_full_name):
        if self.clientsHaveErrors():
            self.sendError(ERR_GENERAL_ERROR, _translate('error', "Some clients could not save"))
            self.process_order.clear()
            return
        
        self.sendGui('/ray/trash/clear')
        
        for client in self.clients:
            client.net_duplicate_state = -1
            
            if client.net_daemon_url and isValidOscUrl(client.net_daemon_url):
                self.send(Address(client.net_daemon_url), '/ray/session/duplicate_only', self.name, new_session_full_name, client.net_session_root)
                self.expected_clients.append(client)
        
        self.waitAndGoTo(2000, (self.duplicate_step1, new_session_full_name), WAIT_FOR_DUPLICATE_START) 
        
    def duplicate_step1(self, new_session_full_name):
        spath = "%s/%s" % (self.root, new_session_full_name)
        
        self.setServerStatus(SERVER_STATUS_COPY)
        self.file_copier.startSessionCopy(self.path, spath, self.duplicate_step2, self.duplicateAborted, [new_session_full_name])
    
    def duplicate_step2(self, new_session_full_name):
        self.cleanExpected()
        
        for client in self.clients:
            if client.net_duplicate_state == 0:
                self.expected_clients.append(client)
        
        self.waitAndGoTo(3600000, (self.duplicate_step3, new_session_full_name), WAIT_FOR_DUPLICATE_FINISH) #1Hour
        
    def duplicate_step3(self, new_session_full_name):
        self.adjustFilesAfterCopy(new_session_full_name, TEMPLATE_NONE)
        self.nextFunction()
    
    def duplicateAborted(self, new_session_full_name):
        self.process_order.clear()
        self.oscReply('/ray/net_daemon/duplicate_state', 1)
        self.setServerStatus(SERVER_STATUS_READY)
    
    def saveSessionTemplate(self, template_name, net=False):
        template_root = session_template_root
        
        if net:
            template_root = "%s/%s" % (self.root, session_template_net_rootname)
        
        spath = "%s/%s" % (template_root, template_name)
        
        #overwrite existing template
        if os.path.isdir(spath):
            if not os.access(spath, os.W_OK):
                self.sendError(ERR_GENERAL_ERROR, _translate("error", "Impossible to save template, unwriteable file !" ))
                self.setServerStatus(SERVER_STATUS_READY)
                return
            shutil.rmtree(spath)
        
        if not os.path.exists(template_root):
            os.makedirs(template_root)
        
        
        #For network sessions, save as template the network session only if there is no other server on this same machine.
        #Else, one could erase template just created by another one.
        #To prevent all confusion, all seen machines are sended to prevent an erase by looping (a network session can contains another network session on the machine where is the master daemon, for example).
        
        for client in self.clients:
            if client.net_daemon_url:
                self.send(Address(client.net_daemon_url), '/ray/session/save_as_template', self.name, template_name, client.net_session_root)
        
        self.setServerStatus(SERVER_STATUS_COPY)
        self.file_copier.startSessionCopy(self.path, spath, self.saveSessionTemplate_step_1, self.saveSessionTemplateAborted, [template_name, net])
        
    def saveSessionTemplate_step_1(self, template_name, net):
        tp_mode = TEMPLATE_SESSION_SAVE_NET if net else TEMPLATE_SESSION_SAVE
        
        for client in self.clients + self.removed_clients:
            client.adjustFilesAfterCopy(template_name, tp_mode)
        
        self.message("Done")
        self.sendGuiMessage(_translate('GUIMSG', "Session saved as template named %s") % template_name)
        self.oscReply("/reply", self.osc_path, "Saved as template.")
        self.setServerStatus(SERVER_STATUS_READY)
    
    def saveSessionTemplateAborted(self, template_name):
        self.process_order.clear()
        self.setServerStatus(SERVER_STATUS_READY)
    
    def prepareTemplate(self, new_session_full_name, template_name, net=False):
        template_root = session_template_root
        
        if net:
            template_root = "%s/%s" % (self.root, session_template_net_rootname)
        
        template_path = "%s/%s" % (template_root, template_name)
        
        if template_name.startswith('///'):
            template_name = template_name.replace('///', '')
            template_path = "%s/%s" % (session_template_factory_root, template_name)
            
        if not os.path.isdir(template_path):
            self.sendError(ERR_GENERAL_ERROR, _translate("error", "No template named %s") % template_name)
            return
        
        new_session_name = basename(new_session_full_name)
        spath = "%s/%s" % (self.root, new_session_full_name)
        
        if os.path.exists(spath):
            self.sendError(ERR_CREATE_FAILED, _translate("error", "Folder \n%s \nalready exists") % spath)
            return
        
        if self.path:
            self.setServerStatus(SERVER_STATUS_COPY)
        else:
            self.setServerStatus(SERVER_STATUS_PRECOPY)
            self.sendGui("/ray/gui/session/name",  new_session_name, new_session_name)
            
        self.file_copier.startSessionCopy(template_path, spath, self.prepareTemplate_step1, self.prepareTemplateAborted, [new_session_full_name])
        
    def prepareTemplate_step1(self, new_session_full_name):
        self.adjustFilesAfterCopy(new_session_full_name, TEMPLATE_SESSION_LOAD)
        self.nextFunction()
    
    def prepareTemplateAborted(self, new_session_full_name):
        self.process_order.clear()
        if self.name:
            self.setServerStatus(SERVER_STATUS_READY)
        else:
            self.setServerStatus(SERVER_STATUS_OFF)
        
            self.setPath('')
            self.sendGui('/ray/gui/session/name', '', '')
        
    def load(self, session_full_name):
        #terminate or switch clients
        spath = self.root + '/' + session_full_name
        if session_full_name.startswith('/'):
            spath = session_full_name
            
        if not os.path.exists(spath):
            try:
                os.makedirs(spath)
            except:
                self.err_loading = ERR_CREATE_FAILED
                self.loadError()
                return
        
        if not multi_daemon_file.isFreeForSession(spath):
            WARNING("Session is used by another daemon")
            self.err_loading = ERR_SESSION_LOCKED
            self.loadError()
            return
        
        if os.path.isfile(spath + '/.lock'):
            WARNING("Session is locked by another process")
            self.err_loading = ERR_SESSION_LOCKED
            self.loadError()
            return
        
        
        self.message("Attempting to open %s" % spath)
        
        session_ray_file = spath + '/raysession.xml'
        session_nsm_file = spath + '/session.nsm'
        
        self.err_loading = ERR_OK
        
        
        
        is_ray_file = True
        
        try:
            ray_file = open(session_ray_file, 'r')
        except:
            is_ray_file = False
            
        if not is_ray_file:
            try:
                file = open(session_nsm_file, 'r')
                self.sendGui('/ray/opening_nsm_session')
            except:
                try:
                    ray_file = open(session_ray_file, 'w')
                    xml = QDomDocument()
                    p = xml.createElement('RAYSESSION')
                    p.setAttribute('VERSION', VERSION)
                    
                    if self.isNsmLocked():
                        name = basename(session_full_name).rpartition('.')[0]
                        p.setAttribute('name', name)
                    
                    xml.appendChild(p)
                    
                    ray_file.write(xml.toString())
                    ray_file.close()
                    
                    ray_file = open(session_ray_file, 'r')
                    
                    is_ray_file = True
                    
                except:
                    self.err_loading = ERR_CREATE_FAILED
                    self.loadError()
                    return
                
        self.sendGuiMessage(_translate('GUIMSG', "Opening session %s") % session_full_name)
        
        self.removed_clients.clear()
        self.sendGui('/ray/trash/clear')
        
        
        self.new_clients = []
        new_client_exec_args = []
        
        self.setPath(spath)
        #multi_daemon_file.update()
        
        if is_ray_file:
            xml = QDomDocument()
            xml.setContent(ray_file.read())

            content = xml.documentElement()
            
            if content.tagName() != "RAYSESSION":
                ray_file.close()
                self.err_loading = ERR_BAD_PROJECT
                self.loadError()
                return
            
            sess_name = content.attribute('name')
            if sess_name:
                self.name = sess_name
            
            node = content.firstChild()
            while not node.isNull():
                tag_name = node.toElement().tagName()
                if tag_name in ('Clients', 'RemovedClients'):
                    client_xml = node.toElement().firstChild()
                    while not client_xml.isNull():
                        client = Client(self)
                        cx = client_xml.toElement()
                        client.readXmlProperties(cx)
                        
                        if tag_name == 'Clients':
                            if client.auto_start:
                                new_client_exec_args.append((client.executable_path, client.arguments))
                            
                            self.new_clients.append(client)
                            
                        elif tag_name == 'RemovedClients':
                            self.removed_clients.append(client)
                            client.sendGuiClientProperties(removed=True)
                        
                        client_xml = client_xml.nextSibling()
                        
                node = node.nextSibling()
            
            ray_file.close()
        else:
            for line in file.read().split('\n'):
                elements = line.split(':')
                if len(elements) >= 3:
                    client = Client(self)
                    client.name            = elements[0]
                    client.executable_path = elements[1]
                    client.client_id       = elements[2]
                    client.prefix_mode     = PREFIX_MODE_CLIENT_NAME
                    self.new_clients.append(client)
                    new_client_exec_args.append((client.executable_path, ''))
                    
            file.close()
        
        self.message("Commanding unneeded and dumb clients to quit")
        
        for client in self.clients:
            if client.active and client.isCapableOf(':switch:') and (client.executable_path, client.arguments) in new_client_exec_args:
                new_client_exec_args.remove((client.executable_path, client.arguments))
            else:
                #client is not capable of switch, or is not wanted in the new session
                if client.isRunning():
                    self.expected_clients.append(client)
                client.quit()
        
        if self.expected_clients:
            self.setServerStatus(SERVER_STATUS_CLEAR)
        
        self.waitAndGoTo(20000, self.load_step1, WAIT_FOR_STOP)
    
    def load_step1(self):
        self.cleanExpected()
        self.purgeInactiveClients()
        
        for client in self.clients:
            client.pre_existing = True
            
        self.message("Commanding smart clients to switch")
        
        has_switch = False
        
        new_client_id_list = []
        
        for new_client in self.new_clients:
            #/* in a duplicated session, clients will have the same
            #* IDs, so be sure to pick the right one to avoid race
            #* conditions in JACK name registration. */
            client = self.getClientByExecutableAndId(new_client.executable_path, new_client.client_id)
            if not client:
                client = self.getClientByExecutable(new_client.executable_path)
            
            if client and client.active and client.pre_existing and not client.isReplyPending():
                #since we already shutdown clients not capable of 'switch', we can assume that these are.
                client.switch(new_client)
                has_switch = True
            else:
                #* sleep a little bit because liblo derives its sequence
                #* of port numbers from the system time (second
                #* resolution) and if too many clients start at once they
                #* won't be able to find a free port. */
                if not self.addClient(new_client):
                    continue
                    
                if new_client.auto_start and not self.is_dummy:
                    self.clients_to_launch.append(new_client)
                    if not new_client.executable_path in known_as_non_active:
                        self.expected_clients.append(new_client)
            
            new_client_id_list.append(new_client.client_id)
            
        self.sendGui("/ray/gui/session/name",  self.name, self.name)
        
        
        if has_switch:
            self.setServerStatus(SERVER_STATUS_SWITCH)
        else:
            self.setServerStatus(SERVER_STATUS_LAUNCH) 
        
        
        #* this part is a little tricky... the clients need some time to
        #* send their 'announce' messages before we can send them 'open'
        #* and know that a reply is pending and we should continue waiting
        #* until they finish.

        #* dumb clients will never send an 'announce message', so we need
        #* to give up waiting on them fairly soon. */
        
        self.timer_launch.start()
        
        self.reOrderClients(new_client_id_list)
        self.sendGui('/ray/gui/clients_reordered', *new_client_id_list)
        
        self.waitAndGoTo(5000, self.load_step2, WAIT_FOR_ANNOUNCE)
    
    def load_step2(self):
        for client in self.expected_clients:
            known_as_non_active.append(client.executable_path)
        settings.setValue('daemon/non_active_list', known_as_non_active)
        settings.sync()
        
        self.cleanExpected()
        
        self.setServerStatus(SERVER_STATUS_OPEN)
        
        for client in self.clients:
            if client.active and client.isReplyPending():
                self.expected_clients.append(client)
        self.waitAndGoTo(10000, self.load_step3, WAIT_FOR_REPLY)
        
    def load_step3(self):
        self.cleanExpected()
        self.tellAllClientsSessionIsLoaded()
        self.message('Loaded')
        
        self.sendGui("/ray/gui/session/name",  self.name, self.name)
        self.oscReply("/reply", self.osc_path, "Loaded.")
        
        self.nextFunction()
    
    def loadDone(self):
        self.message("Done")
        self.setServerStatus(SERVER_STATUS_READY)
    
    def loadError(self):
        self.message("Failed")
        m = _translate('Load Error', "Unknown error")
        if self.err_loading == ERR_CREATE_FAILED:
            m = _translate('Load Error', "Could not create session file!")
        elif self.err_loading == ERR_SESSION_LOCKED:
            m = _translate('Load Error', "Session is locked by another process!")
        elif self.err_loading == ERR_NO_SUCH_FILE:
            m = _translate('Load Error', "The named session does not exist.")
        elif self.err_loading == ERR_BAD_PROJECT:
            m = _translate('Load Error', "Could not load session file.")
        
        self.oscReply("/error", self.osc_path, self.err_loading, m)
        
        if self.name:
            self.setServerStatus(SERVER_STATUS_READY)
        else:
            self.setServerStatus(SERVER_STATUS_OFF)
            
        self.process_order.clear()
    
    def duplicateOnlyDone(self):
        self.oscReply('/ray/net_daemon/duplicate_state', 1)
    
    def duplicateDone(self):
        self.message("Done")
        self.oscReply("/reply", self.osc_path, "Duplicated.")
        self.setServerStatus(SERVER_STATUS_READY)
        
    def exitNow(self):
        self.message("Bye Bye...")
        self.setServerStatus(SERVER_STATUS_OFF)
        app.quit()
        
class SignaledSession(OperatingSession):
    def __init__(self, root):
        OperatingSession.__init__(self, root)
        signaler.server_new.connect(self.serverNewSession)
        signaler.server_new_from_tp.connect(self.serverNewSessionFromTemplate)
        signaler.server_open.connect(self.serverOpenSession)
        signaler.server_save.connect(self.serverSaveSession)
        signaler.server_save_from_client.connect(self.serverSaveSessionFromClient)
        signaler.server_rename.connect(self.serverRenameSession)
        signaler.server_duplicate.connect(self.serverDuplicateSession)
        signaler.server_duplicate_only.connect(self.serverDuplicateSessionOnly)
        signaler.server_save_session_template.connect(self.serverSaveSessionTemplate)
        signaler.server_close.connect(self.serverCloseSession)
        signaler.server_abort.connect(self.serverAbortSession)
        signaler.server_list_sessions.connect(self.serverListSessions)
        
        signaler.server_reorder_clients.connect(self.serverReorderClients)
        
        signaler.server_add.connect(self.serverAdd)
        signaler.server_add_proxy.connect(self.serverAddProxy)
        signaler.server_add_client_template.connect(self.serverAddClientTemplate)
        signaler.server_add_user_client_template.connect(self.serverAddUserClientTemplate)
        signaler.server_add_factory_client_template.connect(self.serverAddFactoryClientTemplate)
        
        signaler.server_announce.connect(self.serverAnnounce)
        signaler.server_reply.connect(self.serverReply)
        
        signaler.gui_client_stop.connect(self.guiClientStop)
        signaler.gui_client_kill.connect(self.guiClientKill)
        signaler.gui_client_remove.connect(self.guiClientRemove)
        signaler.gui_client_resume.connect(self.guiClientResume)
        signaler.gui_client_save.connect(self.guiClientSave)
        signaler.gui_client_save_template.connect(self.guiClientSaveTemplate)
        signaler.gui_client_label.connect(self.guiClientLabel)
        signaler.gui_client_icon.connect(self.guiClientIcon)
        signaler.gui_update_client_properties.connect(self.updateClientProperties)
        
        signaler.gui_trash_restore.connect(self.guiTrashRestore)
        signaler.gui_trash_remove_definitely.connect(self.guiTrashRemoveDefinitely)
        
        signaler.copy_aborted.connect(self.abortCopy)
        
        signaler.client_net_properties.connect(self.setClientNetworkProperties)
        signaler.net_duplicate_state.connect(self.setClientNetDuplicateState)
        
    ############################# FUNCTIONS CONNECTED TO SIGNALS FROM OSC ###############################
    
    def serverNewSession(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        if len(args) < 1:
            return
        
        self.process_order = [self.save, self.close, (self.new, args[0]), self.save, self.newDone]
        self.nextFunction()
        
    def serverNewSessionFromTemplate(self, path, args, src_addr, net=False):
        if self.process_order:
            return
        
        self.rememberOscArgs(path, args, src_addr)
        
        if len(args) != 2:
            return
        
        new_session_full_name, template_name = args
        
        self.process_order = [self.save, (self.prepareTemplate, *args, net), (self.load, new_session_full_name), self.loadDone]
        self.nextFunction()
        
    def serverOpenSession(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, (self.load, *args), self.loadDone]
        self.nextFunction()
    
    def serverSaveSession(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, self.saveDone]
        self.nextFunction()
        
    def serverSaveSessionFromClient(self, path, args, src_addr, client_id):
        if self.process_order:
            return
        
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [(self.save, client_id), self.saveDone]
        self.nextFunction()
        
        
    def serverCloseSession(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, self.close, self.closeDone]
        self.nextFunction()
    
    def serverRenameSession(self, new_session_name):
        if self.process_order:
            return
        
        if not self.path:
            return
        
        if self.file_copier.isActive():
            return
        
        if new_session_name == self.name:
            return
        
        if not self.isNsmLocked():
            for filename in os.listdir(dirname(self.path)):
                if filename == new_session_name:
                    return
        
        for client in self.clients:
            if client.isRunning():
                self.sendGuiMessage(_translate('GUIMSG', 'Stop all clients before rename session !'))
                return
        
        for client in self.clients + self.removed_clients:
            client.adjustFilesAfterCopy(new_session_name, TEMPLATE_RENAME)
        
        self.sendGuiMessage(_translate('GUIMSG', 'Session %s has been renamed to %s .') % (self.name, new_session_name))
        
        if not self.isNsmLocked():
            try:
                spath = "%s/%s" % (dirname(self.path), new_session_name)
                subprocess.run(['mv', self.path, spath])
                self.path = spath
                self.sendGuiMessage(_translate('GUIMSG', 'Session directory is now: %s') % self.path)
            except:
                pass
        
        self.name = new_session_name
        
        self.sendGui('/ray/gui/session/name', self.name, self.name)
    
    def serverDuplicateSession(self, path, args, src_addr):
        if self.process_order:
            return
        
        if len(args) != 1:
            return
        
        new_session_full_name = args[0]
        
        self.rememberOscArgs(path, args, src_addr)
        
        
        self.process_order = [self.save, (self.duplicate, new_session_full_name), (self.load, new_session_full_name), self.duplicateDone]
        self.nextFunction()
    
    def serverDuplicateSessionOnly(self, path, args, src_addr):
        if self.process_order or len(args) != 1 or self.file_copier.isActive():
            self.oscReply('/ray/net_daemon/duplicate_state', 1)
            return
        
        new_session_full_name = args[0]
        
        self.rememberOscArgs(path, args, src_addr)
        
        self.process_order = [self.save, (self.duplicate, new_session_full_name), self.duplicateOnlyDone]
        self.nextFunction()
    
    def serverSaveSessionTemplate(self, path, args, src_addr, net=False):
        if self.process_order:
            return
        
        if len(args) != 1:
            return
        
        self.rememberOscArgs(path, args, src_addr)
        
        template_name = args[0]
        
        for client in self.clients:
            if client.executable_path == 'ray-network':
                client.net_session_template = template_name
        
        self.process_order = [self.save, (self.saveSessionTemplate, template_name, net)]
        self.nextFunction()
        
    def serverAbortSession(self, path, args, src_addr):
        self.wait_for = WAIT_FOR_NONE
        self.timer.stop()
        
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.close, self.abortDone]
        
        if self.file_copier.isActive():
            self.file_copier.abort(self.nextFunction, [])
        else:
            self.nextFunction()
    
    def serverListSessions(self, src_addr, with_net):
        if with_net:
            for client in self.clients:
                if client.net_daemon_url:
                    self.send(Address(client.net_daemon_url), '/ray/server/list_sessions', 1)
        
        if not self.root:
            return
        
        session_list = []
        
        for root, dirs, files in os.walk(self.root):
            #exclude hidden files and dirs
            files   = [f for f in files if not f.startswith('.')]
            dirs[:] = [d for d in dirs  if not d.startswith('.')]
        
        #for fds in os.walk(self.root):
            #folder, folders, files = fds
            if root == self.root:
                continue
            
            already_send = False
            
            for file in files:
                if file in ('raysession.xml', 'session.nsm'):
                    if not already_send:
                        basefolder = root.replace(self.root + '/', '', 1)
                        session_list.append(basefolder)
                        if len(session_list) == 100:
                            self.send(src_addr, "/reply_sessions_list", *session_list)
                            session_list.clear()
                        already_send = True
                    
        if session_list:
            self.send(src_addr, "/reply_sessions_list", *session_list)
        
    def serverReorderClients(self, path, args):
        client_ids_list = args
        
        self.reOrderClients(client_ids_list)
        
    
    def serverAdd(self, path, args, src_addr):
        self.rememberOscArgs(path, args, src_addr)
        executable = args[0]
        
        client = Client(self)
        client.executable_path = executable
        client.name            = basename(executable)
        client.client_id       = self.generateClientId(executable)
        client.icon            = client.name.lower().replace('_', '-')
        
        if self.addClient(client):
            client.start()
    
    def serverAddProxy(self, path, args, src_addr):
        self.rememberOscArgs(path, args, src_addr)
        executable = args[0]
        
        client = Client(self)
        client.executable_path = 'ray-proxy'
        
        client.tmp_arguments  = "--executable %s" % executable
        if debug:
            client.tmp_arguments += " --debug"
            
        client.name            = basename(executable)
        client.client_id       = self.generateClientId(client.name)
        client.icon            = client.name.lower().replace('_', '-')
        
        if self.addClient(client):
            client.start()
    
    def addClientTemplate(self, template_name, factory=False):
        templates_root = client_template_local_root
        if factory:
            templates_root = client_template_factory_root
            
        xml_file = "%s/%s" % (templates_root, 'client_templates.xml')
        file = open(xml_file, 'r')
        xml = QDomDocument()
        xml.setContent(file.read())
        file.close()
        
        if xml.documentElement().tagName() != 'RAY-CLIENT-TEMPLATES':
            return
        
        node = xml.documentElement().firstChild()
        while not node.isNull():
            ct = node.toElement()
            if ct.tagName() != 'Client-Template':
                node = node.nextSibling()
                continue
            
            if ct.attribute('template-name') == template_name:
                client = Client(self)
                client.readXmlProperties(ct)
                
                needed_version = ct.attribute('needed-version')
                
                if needed_version.startswith('.') or needed_version.endswith('.') or not needed_version.replace('.', '').isdigit():
                    #needed-version not writed correctly, ignores it
                    needed_version = ''
                
                if factory and needed_version:
                    full_program_version = subprocess.check_output([client.executable_path, '--version']).decode()
                    previous_is_digit = False
                    program_version = ''
                    for character in full_program_version:
                        if character.isdigit():
                            program_version+=character
                            previous_is_digit = True
                        elif character == '.':
                            if previous_is_digit:
                                program_version+=character
                            previous_is_digit = False
                        else:
                            if program_version:
                                break
                            
                    if not program_version:
                        node = node.nextSibling()
                        continue
                    
                    
                    neededs = []
                    progvss = []
                    
                    for n in needed_version.split('.'):
                        neededs.append(int(n))
                        
                    for n in program_version.split('.'):
                        progvss.append(int(n))
                    
                    if neededs > progvss:
                        node = node.nextSibling()
                        continue
                
                full_name_files = []
                
                if not needed_version: 
                    #if there is a needed version, 
                    #then files are ignored because factory templates with version must be NSM compatible and dont need files (factory)
                    template_path = "%s/%s" % (templates_root, template_name)
                    
                    if os.path.isdir(template_path):
                        for file in os.listdir(template_path):
                            full_name_files.append("%s/%s" % (template_path, file))
                            
                
                if self.addClient(client):
                    if full_name_files:
                        client.setStatus(CLIENT_STATUS_PRECOPY)
                        self.file_copier.startClientCopy(client.client_id, full_name_files, self.path, self.addClientTemplate_step_1, self.addClientTemplateAborted, [client])
                    else:
                        self.addClientTemplate_step_1(client)
                    
                break
            
            node = node.nextSibling()
    
    def addClientTemplate_step_1(self, client):
        client.adjustFilesAfterCopy(self.name, TEMPLATE_CLIENT_LOAD)
        
        if client.auto_start:
            client.start()
    
    def addClientTemplateAborted(self, client):
        self.removeClient(client)
    
    def serverAddClientTemplate(self, path, args, src_addr):
        self.rememberOscArgs(path, args, src_addr)
        
        factory = bool(args[0])
        template_name = args[1]
        
        self.addClientTemplate(template_name, factory)
    
    def serverAddUserClientTemplate(self, path, args, src_addr):
        self.rememberOscArgs(path, args, src_addr)
        template_name = args[0]
        
        self.addClientTemplate(template_name, False)
        
    def serverAddFactoryClientTemplate(self, path, args, src_addr):
        self.rememberOscArgs(path, args, src_addr)
        template_name = args[0]
        
        self.addClientTemplate(template_name, True)
     
    def serverAnnounce(self, path, args, src_addr):
        client_name, capabilities, executable_path, major, minor, pid = args
        
        if self.wait_for == WAIT_FOR_STOP:
            return
        
        #we can't be absolutely sure that the announcer is the good one
        #but if client announce a known PID, we can be sure of which client is announcing
        for client in self.clients: 
            if client.pid == pid and not client.active and client.isRunning():
                client.serverAnnounce(path, args, src_addr, False)
                break
        else:
            n=0
            for client in self.clients:
                if (basename(client.executable_path) == basename(executable_path)
                    and not client.active
                    and client.pending_command == COMMAND_START):
                        n+=1
                        if n>1:
                            break
            
            if n==1:
                for client in self.clients:
                    if (basename(client.executable_path) == basename(executable_path)
                        and not client.active
                        and client.pending_command == COMMAND_START):
                            client.serverAnnounce(path, args, src_addr, False)
                            break
            else:
                for client in self.clients:
                    if not client.active and client.pending_command == COMMAND_START:
                        if isPIdChildOf(pid, client.pid):
                            client.serverAnnounce(path, args, src_addr, False)
                            break
                
                #Ray Session won't add clients that aren't launched by Ray Session itself. 
            
        if self.wait_for == WAIT_FOR_ANNOUNCE:
            self.endTimerIfLastExpected(client)
    
    def serverReply(self, path, args, src_addr):
        if self.wait_for == WAIT_FOR_STOP:
            return
        
        message = args[1]
        client = self.getClientByAddress(src_addr)
        if client:
            client.setReply(ERR_OK, message)
            #self.message( "Client \"%s\" replied with: %s in %fms" % ( client.name, message, client.milliseconds_since_last_command() ))
            
            if client.pending_command == COMMAND_SAVE:
                client.last_save_time = time.time()
            
            client.pending_command = COMMAND_NONE
            
            client.setStatus(CLIENT_STATUS_READY)
            
            if self.wait_for == WAIT_FOR_REPLY:
                self.endTimerIfLastExpected(client)
        else:
            self.message("Reply from unknown client")
    
    def setClientNetworkProperties(self, client_id, net_daemon_url, net_session_root):
        for client in self.clients:
            if client.client_id == client_id:
                client.setNetworkProperties(net_daemon_url, net_session_root)
                break
    
    def setClientNetDuplicateState(self, src_addr, state):
        for client in self.clients:
            if client.net_daemon_url and areSameOscPort(client.net_daemon_url, src_addr.url):
                client.net_duplicate_state = state
                client.net_daemon_copy_timer.stop()
                break
        else:
            return
        
        if state == 1:
            if self.wait_for == WAIT_FOR_DUPLICATE_FINISH:
                self.endTimerIfLastExpected(client)
            return
        
        if (self.wait_for == WAIT_FOR_DUPLICATE_START and state == 0):
            self.endTimerIfLastExpected(client)
            
        client.net_daemon_copy_timer.start()
            
    
    def guiClientStop(self, path, args):
        for client in self.clients:
            if client.client_id == args[0]:
                client.stop()
                self.sendGui("/reply", "Client stopped." )
                break
        else:
            self.sendGui("/error", -10, "No such client." )
    
    def guiClientKill(self, path, args):
        for client in self.clients:
            if client.client_id == args[0]:
                client.kill()
                self.sendGui("/reply", "Client killed." )
                break
        else:
            self.sendGui("/error", -10, "No such client." )
    
    def guiClientRemove(self, path, args):
        client_id = args[0]
        
        for client in self.clients:
            if client.client_id == client_id:
                if client.isRunning():
                    return
                
                if self.file_copier.isActive(client_id):
                    self.file_copier.abort()
                    return
                
                self.removeClient(client)
                
                self.sendGui("/reply", "Client removed.")
                break
        else:
            self.sendGui("/error", -10, "No such client.")
            
    def guiClientResume(self, path, args):
        for client in self.clients:
            if client.client_id == args[0] and not client.isRunning():
                if self.file_copier.isActive(client.client_id):
                    self.sendGui("/error", -13, "Impossible, copy running")
                    return
                
                client.start()
                break
    
    def guiClientSave(self, path, args):
        for client in self.clients:
            if client.client_id == args[0] and client.active:
                if self.file_copier.isActive(client.client_id):
                    self.sendGui("/error", -13, "Impossible, copy running")
                    return
                client.save()
                break
    
    def guiClientSaveTemplate(self, path, args):
        if self.file_copier.isActive():
            self.sendGui("/error", -13, "Impossible, copy running")
            return
        
        for client in self.clients:
            if client.client_id == args[0]:
                client.saveAsTemplate(args[1])
                break
    
    def guiClientLabel(self, client_id, label):
        for client in self.clients:
            if client.client_id == client_id:
                client.setLabel(label)
                break
            
    def guiClientIcon(self, client_id, icon):
        for client in self.clients:
            if client.client_id == client_id:
                client.setIcon(icon)
                break
    
    def updateClientProperties(self, client_data):
        for client in self.clients:
            if client.client_id == client_data.client_id:
                client.updateClientProperties(client_data)
                break
    
    def guiTrashRestore(self, client_id):
        for client in self.removed_clients:
            if client.client_id == client_id:
                self.restoreClient(client)
                break
        else:
            self.sendGui("/error", -10, "No such client.")
            
    def guiTrashRemoveDefinitely(self, client_id):
        for client in self.removed_clients:
            if client.client_id == client_id:
                break
        else:
            return
        
        self.sendGui('/ray/trash/remove', client_id)
        
        for file in client.getProjectFiles():
            try:
                subprocess.run(['rm', '-R', file])
            except:
                continue
            
        self.removed_clients.remove(client)
    
    def abortCopy(self):
        self.file_copier.abort()
    
    def terminate(self):
        if self.terminated_yet:
            return
        
        if self.file_copier.isActive():
            self.file_copier.abort()
        
        self.terminated_yet = True
        self.process_order = [self.close, self.exitNow]
        self.nextFunction()


class DummySession(OperatingSession):
    def __init__(self, root):
        OperatingSession.__init__(self, root)
        self.is_dummy = True
        
    def dummyLoadAndTemplate(self, session_full_name, template_name):
        self.process_order = [(self.load, session_full_name), (self.saveSessionTemplate, template_name, True)]
        self.nextFunction()
        
    def dummyDuplicate(self, session_to_load, new_session_full_name):
        self.process_order = [(self.load, session_to_load), (self.duplicate, new_session_full_name), self.duplicateOnlyDone]
        self.nextFunction()

##########################

class Signaler(QObject):
    server_announce    = pyqtSignal(str, list, object)
    server_reply       = pyqtSignal(str, list, object)
    server_rename      = pyqtSignal(str)
    server_duplicate   = pyqtSignal(str, list, object)
    server_duplicate_only = pyqtSignal(str, list, object)
    server_save_session_template = pyqtSignal(str, list, object, bool)
    server_abort       = pyqtSignal(str, list, object)
    server_close       = pyqtSignal(str, list, object)
    server_new         = pyqtSignal(str, list, object)
    server_new_from_tp = pyqtSignal(str, list, object, bool)
    server_open        = pyqtSignal(str, list, object)
    server_save        = pyqtSignal(str, list, object)
    server_save_from_client = pyqtSignal(str, list, object, str)
    server_list_sessions = pyqtSignal(object, bool)
    server_add       = pyqtSignal(str, list, object)
    server_add_proxy = pyqtSignal(str, list, object)
    server_add_client_template = pyqtSignal(str, list, object)
    server_add_user_client_template    = pyqtSignal(str, list, object)
    server_add_factory_client_template = pyqtSignal(str, list, object)
    server_reorder_clients = pyqtSignal(str, list)
    gui_client_stop    = pyqtSignal(str, list)
    gui_client_kill    = pyqtSignal(str, list)
    gui_client_remove  = pyqtSignal(str, list)
    gui_client_resume  = pyqtSignal(str, list)
    gui_client_save    = pyqtSignal(str, list)
    gui_client_save_template = pyqtSignal(str, list)
    gui_client_label = pyqtSignal(str, str)
    gui_client_icon  = pyqtSignal(str, str)
    gui_update_client_properties = pyqtSignal(object)
    copy_aborted = pyqtSignal()
    gui_trash_restore           = pyqtSignal(str)
    gui_trash_remove_definitely = pyqtSignal(str)
    
    client_net_properties = pyqtSignal(str, str, str)
    net_duplicate_state   = pyqtSignal(object, int)
        
    dummy_load_and_template = pyqtSignal(str, str, str)
    dummy_duplicate         = pyqtSignal(object, str, str, str)
    
    def __init__(self):
        QObject.__init__(self)
        self.dummy_load_and_template.connect(self.dummyLoadAndTemplate)
        self.dummy_duplicate.connect(self.dummyDuplicate)
        
    def dummyLoadAndTemplate(self, session_name, template_name, sess_root):
        tmp_session = DummySession(sess_root)
        tmp_session.dummyLoadAndTemplate(session_name, template_name)
        
    def dummyDuplicate(self, src_addr, session_to_load, new_session, sess_root):
        tmp_session = DummySession(sess_root)
        tmp_session.osc_src_addr = src_addr
        tmp_session.dummyDuplicate(session_to_load, new_session)


#Osc server thread separated in many classes for confort.
#ClientCommunicating contains NSM protocol. Paths have to be never changed.
class ClientCommunicating(ServerThread):
    def __init__(self, osc_num=0):
        ServerThread.__init__(self, osc_num)
        self.gui_list = []
        self.server_status  = SERVER_STATUS_OFF
        self.is_nsm_locked  = False
        self.nsm_locker_url = ''
        self.net_master_daemon_addr = None
        self.net_master_daemon_url = ''
        self.net_daemon_id = random.randint(1, 999999999)
        
    @make_method('/nsm/server/announce', 'sssiii')
    def nsmServerAnnounce(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "Sorry, but there's no session open for this application to join." )
            return
        
        signaler.server_announce.emit(path, args, src_addr)
        
    @make_method('/reply', 'ss')
    def reply(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        signaler.server_reply.emit(path, args, src_addr)
            
    @make_method('/error', 'sis')
    def error(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client = session.getClientByAddress(src_addr)
        if not client:
            WARNING("Error from unknown client")
            return
        
        err_code = args[1]
        message  = args[2]
        client.setReply(err_code, message)
        
        MESSAGE( "Client \"%s\" replied with error: %s (%i)" % ( client.name, message, err_code ))
        client.pending_command = COMMAND_NONE
        client.setStatus(CLIENT_STATUS_ERROR)
    
    @make_method('/nsm/client/progress', 'f')
    def nsmClientProgress(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        client = session.getClientByAddress(src_addr)
        if not client:
            return
        
        client.progress = args[0]
        self.sendGui("/ray/client/progress", client.client_id, client.progress)
    
    @make_method('/nsm/client/is_dirty', '')
    def nsmClientIs_dirty(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        
        
        client = session.getClientByAddress(src_addr)
        if not client:
            return
        
        MESSAGE("%s sends dirty" % client.client_id)
        
        client.dirty = 1
        client.last_dirty = time.time()
        
        self.sendGui("/ray/client/dirty", client.client_id, client.dirty)

    @make_method('/nsm/client/is_clean', '')
    def nsmClientIs_clean(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client = session.getClientByAddress(src_addr)
        if not client:
            return
        
        MESSAGE("%s sends clean" % client.client_id)
        
        client.dirty = 0
        
        self.sendGui("/ray/client/dirty", client.client_id, client.dirty)
        
        if self.option_save_from_client:
            if client.pending_command != COMMAND_SAVE:
                if client.last_dirty and time.time() - client.last_dirty > 0.20:
                    if time.time() - client.last_save_time > 1.00:
                        signaler.server_save_from_client.emit(path, args, src_addr, client.client_id)
    
    @make_method('/nsm/client/message', 'is')
    def nsmClientMessage(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client = session.getClientByAddress(src_addr)
        if not client:
            return
        
        self.sendGui("/ray/client/message", client.client_id, args[0], args[1])

    @make_method('/nsm/client/gui_is_hidden', '')
    def nsmClientGui_is_hidden(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client = session.getClientByAddress(src_addr)
        if not client:
            return
        
        MESSAGE("Client '%s' sends gui hidden" % client.client_id)
        
        client.gui_visible = False
        
        self.sendGui("/ray/client/gui_visible", client.client_id, int(client.gui_visible))

    @make_method('/nsm/client/gui_is_shown', '')
    def nsmClientGui_is_shown(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client = session.getClientByAddress(src_addr)
        if not client:
            return
        
        MESSAGE("Client '%s' sends gui shown" % client.client_id)
        
        client.gui_visible = True
        
        self.sendGui("/ray/client/gui_visible", client.client_id, int(client.gui_visible))

    @make_method('/nsm/client/label', 's')
    def nsmClientLabel(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client = session.getClientByAddress(src_addr)
        if not client:
            return
        
        label = args[0]
        signaler.gui_client_label.emit(client.client_id, label)
      
    @make_method('/nsm/server/broadcast', None)
    def nsmServerBroadcast(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not args:
            return
        
        #don't allow clients to broadcast NSM commands
        if args[0].startswith('/nsm/') or args[0].startswith('/ray'):
            return
        
        for client in session.clients:
            if not client.addr:
                continue
            
            if not areSameOscPort(client.addr.url, src_addr.url):
                self.send(client.addr, Message(*args))
                
            #for gui_addr in self.gui_list:
                ##also relay to attached GUI so that the broadcast can be
                ##propagated to another NSMD instance
                #if gui_addr.url != src_addr.url:
                    #self.send(gui_addr, Message(*args))
      
    @make_method('/nsm/client/network_properties', 'ss')
    def nsmClientNetworkProperties(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client = session.getClientByAddress(src_addr)
        if not client:
            return
        
        net_daemon_url, net_session_root = args
        
        signaler.client_net_properties.emit(client.client_id, net_daemon_url, net_session_root)

class OscServerThread(ClientCommunicating):
    def __init__(self, osc_num=0):
        ClientCommunicating.__init__(self, osc_num)
        self.list_asker_addr = None
        
        self.option_save_from_client = True
    
    @make_method('/osc/ping', '')
    def oscPing(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        self.send(src_addr, "/reply", path)
    
    @make_method('/ray/server/gui_announce', 'sisii')
    def rayGuiGui_announce(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        version    = args[0]
        nsm_locked = bool(args[1])
        is_net_free = True
        
        if nsm_locked:
            self.net_master_daemon_url = args[2]
            self.is_nsm_locked = True
            self.nsm_locker_url = src_addr.url
            
            for gui_addr in self.gui_list:
                if gui_addr.url != src_addr.url:
                    self.send(gui_addr, '/ray/gui/daemon_nsm_locked', 1)
                    
            self.net_daemon_id = args[4]
            is_net_free = multi_daemon_file.isFreeForRoot(self.net_daemon_id, session.root)
        
        self.option_save_from_client = bool(args[3])
            
        self.announceGui(src_addr.url, nsm_locked, is_net_free)

    @make_method('/ray/server/gui_disannounce', '')
    def rayGuiGui_disannounce(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        for addr in self.gui_list:
            if addr.url == src_addr.url:
                break
        else:
            return
        
        self.gui_list.remove(addr)
        
        if src_addr.url == self.nsm_locker_url:
            self.net_daemon_id  = random.randint(1, 999999999)
            multi_daemon_file.update()
            
            self.is_nsm_locked  = False
            self.nsm_locker_url = ''
            self.sendGui('/ray/gui/daemon_nsm_locked', 0)
    
    @make_method('/ray/server/set_nsm_locked', '')
    def rayServerSetNsmLocked(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        self.is_nsm_locked = True
        self.nsm_locker_url = src_addr.url
        
        for gui_addr in self.gui_list:
            if gui_addr.url != src_addr.url:
                self.send(gui_addr, '/ray/gui/daemon_nsm_locked', 1)
    
    @make_method('/ray/server/quit', '')
    def nsmServerQuit(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        sys.exit(0)
    
    @make_method('/ray/server/abort_copy', '')
    def rayServerAbortCopy(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        signaler.copy_aborted.emit()
    
    @make_method('/ray/server/change_root', 's')
    def rayServerChangeRoot(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if session.path:
            self.send(src_addr, '/reply', "Can't change session_root while a session is running")
            return
        
        session.setRoot(args[0])
    
    @make_method('/ray/server/list_path', '')
    def rayServerListPath(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        exec_list = []
        tmp_exec_list = []
        
        pathlist = os.getenv('PATH').split(':')
        for path in pathlist:
            if os.path.isdir(path):
                listexe = os.listdir(path)
                for exe in listexe:
                    fullexe = path + '/' + exe
                    if os.path.isfile(fullexe) and os.access(fullexe, os.X_OK) and not exe in exec_list:
                        exec_list.append(exe)
                        tmp_exec_list.append(exe)
                        if len(tmp_exec_list) == 100:
                            self.send(src_addr, '/reply_path', *tmp_exec_list)
                            tmp_exec_list.clear()
        
        if tmp_exec_list:
            self.send(src_addr, '/reply_path', *tmp_exec_list)
            
    @make_method('/ray/server/list_session_templates', '')
    def rayServerListSessionTemplates(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not os.path.isdir(session_template_root):
            return
        
        template_list = []
        
        all_files = os.listdir(session_template_root)
        for file in all_files:
            if os.path.isdir("%s/%s" % (session_template_root, file)):
                template_list.append(file)
                
                if len(template_list) == 100:
                    self.send(src_addr, '/reply_session_templates', *template_list)
                    template_list.clear()
                    
        if template_list:
            self.send(src_addr, '/reply_session_templates', *template_list) 
    
    
    @make_method('/ray/server/list_user_client_templates', '')
    def rayServerListUserClientTemplates(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        self.listClientTemplates(src_addr, False)
    
    @make_method('/ray/server/list_factory_client_templates', '')
    def rayServerListFactoryClientTemplates(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        self.listClientTemplates(src_addr, True)
        
    @make_method('/ray/server/list_sessions', 'i')
    def nsmServerListAll(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        self.list_asker_addr = src_addr
        with_net = bool(args[0])
        signaler.server_list_sessions.emit(src_addr, with_net)
    
    @make_method('/ray/server/new_session', 's')
    def nsmServerNew(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.is_nsm_locked:
            return
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not pathIsValid(args[0]):
            self.send(src_addr, "/error", path, ERR_CREATE_FAILED, "Invalid session name.")
            return
        
        signaler.server_new.emit(path, args, src_addr)
    
    @make_method('/ray/server/new_from_template', 'ss')
    def rayServerNewFromTemplate(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.is_nsm_locked:
            return
        
        if self.isOperationPending(src_addr, path):
            return
        
        signaler.server_new_from_tp.emit(path, args, src_addr, False)
    
    @make_method('/ray/server/open_session', 's')
    def nsmServerOpen(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        signaler.server_open.emit(path, args, src_addr)
          
    @make_method('/ray/server/open_session', 'ss')
    def nsmServerOpenWithTemplate(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        session_name, template_name = args
        
        if template_name:
            spath = ''
            if session_name.startswith('/'):
                spath = session_name
            else:
                spath = "%s/%s" % (session.root, session_name)
            
            if not os.path.exists(spath):
                signaler.server_new_from_tp.emit(path, args, src_addr, True)
                return
        
        signaler.server_open.emit(path, [args[0]], src_addr)
    
    @make_method('/reply_sessions_list', None)
    def replySessionsList(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        #this reply is only used here for reply from net_daemon
        #it directly resend its infos to the last gui that asked session list
        if self.list_asker_addr:
            self.send(self.list_asker_addr, '/reply_sessions_list', *args)
    
    
    @make_method('/ray/session/save', '')
    def nsmServerSave(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to save.")
            return 0
        
        signaler.server_save.emit(path, args, src_addr)
    
    @make_method('/ray/session/save_as_template', 's')
    def nsmServerSaveSessionTemplate(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to save as template.")
            return
        
        if not pathIsValid(args[0]):
            self.send(src_addr, "/error", path, ERR_CREATE_FAILED, "Invalid session name.")
            return
        
        signaler.server_save_session_template.emit(path, args, src_addr, False)
        
    @make_method('/ray/session/save_as_template', 'sss')
    def nsmServerSaveSessionTemplateOff(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        #save as template an not loaded session
        session_name, template_name, sess_root = args
        
        if not pathIsValid(session_name):
            self.send(src_addr, "/error", path, ERR_CREATE_FAILED, "Invalid session name.")
            return
        
        if not pathIsValid(template_name):
            self.send(src_addr, "/error", path, ERR_CREATE_FAILED, "Invalid session name.")
            return
        
        if sess_root == session.root and session_name == session.name:
            net = True
            signaler.server_save_session_template.emit(path, [template_name], src_addr, net)
            return
        
        signaler.dummy_load_and_template.emit(*args)
    
    @make_method('/ray/session/close', '')
    def nsmServerClose(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not  session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to close.")
            return 0
        
        signaler.server_close.emit(path, args, src_addr)
    
    @make_method('/ray/session/abort', '')
    def nsmServerAbort(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.server_status == SERVER_STATUS_PRECOPY:
            signaler.copy_aborted.emit()
            return
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to abort." )
            return
        
        signaler.server_abort.emit(path, args, src_addr)
    
    @make_method('/ray/session/duplicate', 's')
    def nsmServerDuplicate(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.is_nsm_locked:
            return
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to duplicate.")
            return
        
        if not pathIsValid(args[0]):
            self.send(src_addr, "/error", path, ERR_CREATE_FAILED, "Invalid session name.")
            return
        
        signaler.server_duplicate.emit(path, args, src_addr)
        
    @make_method('/ray/session/duplicate_only', 'sss')
    def nsmServerDuplicateOnly(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        session_full_name, new_session_full_name, sess_root = args
        
        self.send(src_addr, '/ray/net_daemon/duplicate_state', 0)
        
        if sess_root == session.root and session_full_name == session.name:
            signaler.server_duplicate_only.emit(path, [new_session_full_name], src_addr)
            return
        
        signaler.dummy_duplicate.emit(src_addr, *args)
    
    @make_method('/ray/session/rename', 's')
    def rayServerRename(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        new_session_name = args[0]
        
        #prevent rename session in network session
        if self.nsm_locker_url:
            NSM_URL = os.getenv('NSM_URL')
            if not NSM_URL:
                return
            
            if not areSameOscPort(self.nsm_locker_url, NSM_URL):
                return
        
        if '/' in new_session_name:
            self.send(src_addr, "/error", path, ERR_CREATE_FAILED, "Invalid session name.")
            return
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to rename.")
            return
        
        signaler.server_rename.emit(new_session_name)
      
    @make_method('/ray/session/add_executable', 's')
    def nsmServerAdd(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "Cannot add to session because no session is loaded." )
            return
        
        signaler.server_add.emit(path, args, src_addr)
    
    @make_method('/ray/session/add_proxy', 's')
    def rayServerAddProxy(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "Cannot add to session because no session is loaded." )
            return
        
        signaler.server_add_proxy.emit(path, args, src_addr)

    @make_method('/ray/session/add_client_template', 'is')
    def rayServerAddClientTemplate(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "Cannot add to session because no session is loaded." )
            return
        
        #factory = bool(args[0])
        #template_name = args[1]
        
        signaler.server_add_client_template.emit(path, args, src_addr)
    
    @make_method('/ray/session/reorder_clients', None)
    def rayServerReorderClients(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not areTheyAllString(args):
            return
        
        signaler.server_reorder_clients.emit(path, args)
    
    @make_method('/ray/session/open_folder', '')
    def rayServerOpenFolder(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        if  session.path:
            subprocess.Popen(['xdg-open',  session.path])
    
    @make_method('/ray/client/stop', 's')
    def rayGuiClientStop(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        signaler.gui_client_stop.emit(path, args)
    
    @make_method('/ray/client/kill', 's')
    def rayGuiClientKill(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        signaler.gui_client_kill.emit(path, args)            
    
    @make_method('/ray/client/remove', 's')
    def rayGuiClientRemove(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        signaler.gui_client_remove.emit(path, args)
    
    @make_method('/ray/client/resume', 's')
    def rayGuiClientResume(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        signaler.gui_client_resume.emit(path, args)
                
    @make_method('/ray/client/save', 's')
    def rayGuiClientSave(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        signaler.gui_client_save.emit(path, args)

    @make_method('/ray/client/save_as_template', 'ss')
    def rayGuiClientSaveAsTemplate(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        signaler.gui_client_save_template.emit(path, args)
    
    @make_method('/ray/client/show_optional_gui', 's')
    def nsmGuiClientShow_optional_gui(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client = session.getClient(args[0])
        
        if client and client.active:
            self.send(client.addr, "/nsm/client/show_optional_gui")

    @make_method('/ray/client/hide_optional_gui', 's')
    def nsmGuiClientHide_optional_gui(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client = session.getClient(args[0])
        
        if client and client.active:
            self.send(client.addr, "/nsm/client/hide_optional_gui")

    @make_method('/ray/client/update_properties', 'ssssissssi')
    def rayGuiClientUpdateProperties(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client_data = ClientData(*args)
        signaler.gui_update_client_properties.emit(client_data)
        
    @make_method('/ray/net_daemon/duplicate_state', 'f')
    def rayDuplicateState(self, path, args, types, src_addr):
        signaler.net_duplicate_state.emit(src_addr, args[0])
    
    @make_method('/ray/trash/restore', 's')
    def rayGuiTrashRestore(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "Cannot add to session because no session is loaded." )
            return
        
        client_id = args[0]
        
        signaler.gui_trash_restore.emit(client_id)
        
    @make_method('/ray/trash/remove_definitely', 's')
    def rayGuiTrashRemoveDefinitely(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client_id = args[0]
        
        signaler.gui_trash_remove_definitely.emit(client_id)
    
    @make_method('/ray/option/save_from_client', 'i')
    def rayOptionSaveFromClient(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
    
        self.option_save_from_client = bool(args[0])
    
    def isOperationPending(self, src_addr, path):
        if session.file_copier.isActive():
            self.send(src_addr, "/error", path, ERR_COPY_RUNNING, "ray-daemon is copying files. Wait copy finish or abort copy, and restart operation !")
            return True
        
        if session.process_order:
            self.send(src_addr, "/error", path, ERR_OPERATION_PENDING, "An operation pending.")
            return True
        
        return False
        
    def sendGui(self, *args):
        for gui_addr in self.gui_list:
            self.send(gui_addr, *args)
    
    def sendClientStatusToGui(self, client):
        self.sendGui("/ray/client/status", client.client_id, client.status)
            
    def setServerStatus(self, server_status):
        self.server_status = server_status
        self.sendGui('/ray/server_status', server_status) 
    
    def informCopytoGui(self, copy_state):
        self.sendGui('/ray/gui/server/copying', int(copy_state))
    
    def listClientTemplates(self, src_addr, factory=False):
        template_list = []
        tmp_template_list = []
        
        templates_root    = client_template_local_root
        response_osc_path = '/reply_user_client_templates'
        
        if factory:
            templates_root    = client_template_factory_root
            response_osc_path = '/reply_factory_client_templates'
        
        
        templates_file = "%s/%s" % (templates_root, 'client_templates.xml')
        
        if not os.path.isfile(templates_file):
            return
        
        if not os.access(templates_file, os.R_OK):
            return
        
        file = open(templates_file)
        xml = QDomDocument()
        xml.setContent(file.read())
        file.close()
        
        content = xml.documentElement()
        
        if content.tagName() != "RAY-CLIENT-TEMPLATES":
            return
        
        node = content.firstChild()
        while not node.isNull():
            ct = node.toElement()
            tag_name = ct.tagName()
            if tag_name != 'Client-Template':
                node = node.nextSibling()
                continue
            
            template_name = ct.attribute('template-name')
            
            if not template_name or template_name in template_list:
                node = node.nextSibling()
                continue
            
            executable = ct.attribute('executable') 
            
            if not executable:
                node = node.nextSibling()
                continue
            
            try_exec_line = ct.attribute('try-exec')
            
            try_exec_list = []
            if try_exec_line:
                try_exec_list = ct.attribute('try-exec').split(';')
                
            try_exec_list.append(executable)
            try_exec_ok = True
            
            for try_exec in try_exec_list:
                path = shutil.which(try_exec)
                if not path:
                    try_exec_ok = False
                    break
            
            if not try_exec_ok:
                node = node.nextSibling()
                continue
            
            template_list.append("%s/%s" % (template_name, ct.attribute('icon') ))
            tmp_template_list.append("%s/%s" % (template_name, ct.attribute('icon') ))
            
            if len(tmp_template_list) == 100:
                self.send(src_addr, response_osc_path, *tmp_template_list)
                template_list.clear()
        
            node = node.nextSibling()
        
        if tmp_template_list:
            self.send(src_addr, response_osc_path, *tmp_template_list)
    
    def sendRenameable(self, renameable):
        if not renameable:
            self.sendGui('/ray/gui/session/renameable', 0)
            return
        
        if self.nsm_locker_url:
            NSM_URL = os.getenv('NSM_URL')
            if not NSM_URL:
                return
            if not areSameOscPort(self.nsm_locker_url, NSM_URL):
                return
        
        self.sendGui('/ray/gui/session/renameable', 1)
    
    def announceGui(self, url, nsm_locked=False, is_net_free=True):
        gui_addr = Address(url)
        
        self.send(gui_addr, "/ray/gui/daemon_announce", VERSION, self.server_status, int(self.is_nsm_locked), session.root, int(is_net_free))
        
        self.send(gui_addr, "/ray/server_status", self.server_status)
        self.send(gui_addr, "/ray/gui/session/name",  session.name,  session.path)
        
        for client in session.clients:
            self.send(  gui_addr, 
                        '/ray/client/new',
                        client.client_id, 
                        client.executable_path,
                        client.arguments,
                        client.name, 
                        client.prefix_mode, 
                        client.project_path,
                        client.label,
                        client.icon,
                        client.capabilities,
                        int(client.check_last_save))
            
            self.send(gui_addr, "/ray/client/status", client.client_id,  client.status)
        
        self.gui_list.append(gui_addr)
        MESSAGE("Registered with GUI")
        
#def dummyLoadAndTemplate(session_name, template_name, sess_root):
    #tmp_session = OperatingSession(sess_root, is_dummy=True)
    #tmp_session.rememberOscArgs(path, [session_name], src_addr)
    #tmp_session.load()
    #tmp_session.rememberOscArgs(path, [template_name], src_addr)
    #tmp_session.saveSessionTemplate()


if __name__ == '__main__':
    #Add RaySession/src to $PATH to can use ray-proxy and maybe future executables after make, whitout install
    os.environ['PATH']="%s:%s" % (os.path.realpath(dirname(sys.argv[0])), os.environ['PATH'])
    
    
    parser = argparse.ArgumentParser()
    parser.add_argument('--session-root', '-r', help='set root folder for sessions')
    parser.add_argument('--osc-port', '-p', type=int, default=0, help='select OSC port for the daemon')
    parser.add_argument('--findfreeport', action='store_true', help='find another port if port is not free')
    parser.add_argument('--gui-url', type=getLibloAddress, help=argparse.SUPPRESS)
    parser.add_argument('--config-dir', '-c', type=str, default='', help='use a custom config dir')
    parser.add_argument('--debug','-d',  action='store_true', help='see all OSC messages')
    parser.add_argument('--debug-only', '-do', action='store_true', help='debug without client messages')
    parser.add_argument('-v', '--version', action='version', version=VERSION)
    parsed_args = parser.parse_args()
    
    debug        = parsed_args.debug
    debug_only   = parsed_args.debug_only
    if debug_only:
        debug = True
    
    session_root = parsed_args.session_root
    osc_num      = parsed_args.osc_port
    findfreeport = parsed_args.findfreeport
    gui_address  = parsed_args.gui_url
    config_dir   = parsed_args.config_dir
    
    if osc_num == 0:
        osc_num = 16187
        findfreeport = True
    
    if config_dir and not os.access(config_dir, os.W_OK):
        sys.stderr.write('%s is not a writable config dir, try another one\n' % config_dir)
        sys.exit(1)
    
    signal.signal(signal.SIGINT,  signalHandler)
    signal.signal(signal.SIGTERM, signalHandler)
    
    app = QCoreApplication(sys.argv)
    app.setApplicationName("RaySession")
    #app.setApplicationVersion(VERSION)
    app.setOrganizationName("RaySession")
    
    if config_dir:
        settings = QSettings("%s/RaySession.conf" % config_dir)
        app_config_path = config_dir
    else:
        settings = QSettings()
        app_config_path = "%s/%s" % (QStandardPaths.writableLocation(QStandardPaths.ConfigLocation), app.organizationName())
    
    
    session_template_root         = "%s/%s" % (app_config_path, 'session_templates')
    session_template_factory_root = "%s/session_templates" % dirname(dirname(sys.argv[0]))
    session_template_net_rootname = ".ray-net-session-templates"
    client_template_local_root    = "%s/%s" % (app_config_path, 'client_templates')
    client_template_factory_root  = "%s/client_templates" % dirname(dirname(sys.argv[0]))
    
    ### Translation process
    locale = QLocale.system().name()
    appTranslator = QTranslator()
    if appTranslator.load("%s/locale/raysession_%s" % (dirname(dirname(sys.argv[0])), locale)):
        app.installTranslator(appTranslator)
    _translate = app.translate
    init_translation(_translate)
    
    
    if not session_root:
        session_root = "%s/%s" % (os.getenv('HOME'), _translate('daemon', 'Ray Network Sessions'))
    
    #make session_root folder if needed
    if not os.path.isdir(session_root):
        if os.path.exists(session_root):
            sys.stderr.write("%s exists and is not a dir, please choose another path !\n" % session_root)
            sys.exit(1)
        
        try:
            os.makedirs(session_root)
        except:
            sys.stderr.write("impossible to make dir %s , aborted !\n" % session_root)
            sys.exit(1)
            
    known_as_non_active = getListInSettings(settings, 'daemon/non_active_list')
    
    timer = QTimer()
    timer.setInterval(200)
    timer.timeout.connect(lambda: None)
    timer.start()
    
    signaler    = Signaler()
    session     = SignaledSession(session_root)
    
    if findfreeport:
        server = OscServerThread(getFreeOscPort(osc_num))
    else:
        if isOscPortFree(osc_num):
            server = OscServerThread(osc_num)
        else:
            sys.stderr.write(_translate('daemon', 'port %i is not free, try another one\n') % osc_num)
            sys.exit()
        
    
    server.start()
    
    if gui_address:
        server.announceGui(gui_address.url)
        
    MESSAGE(getNetUrl(server.port))
    MESSAGE(server.url)
    
    multi_daemon_file = MultiDaemonFile()
    multi_daemon_file.update()
    
    app.exec()
    
    multi_daemon_file.quit()
    
    settings.setValue('daemon/non_active_list', known_as_non_active)
    settings.sync()
    
    server.stop()
    
    
    del server
    del session
    del app
    
