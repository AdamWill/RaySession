#!/usr/bin/python3 -u

import os, sys, shutil, string, random, time, subprocess, signal, unicodedata, inspect
from liblo import ServerThread, Address, make_method, Message
from PyQt5.QtCore import QCoreApplication, pyqtSignal, QObject, QTimer, QProcess, QSettings, QStandardPaths
from PyQt5.QtXml import QDomDocument
from threading import Thread

from shared import *



#ray-daemon doesn't really cares if jack is running or not
#but if jack is running, it just ask all jack ports between many clients launchs or stops
#It 'maybe' prevent some jack bugs
try:
    import dbus
    bus = dbus.SessionBus()
    jack_bus = bus.get_object('org.jackaudio.service', '/org/jackaudio/Controller')
except:
    jack_bus = None

NSM_API_VERSION_MAJOR = 1
NSM_API_VERSION_MINOR = 0

ERR_OK                =  0
ERR_GENERAL_ERROR     = -1
ERR_INCOMPATIBLE_API  = -2
ERR_BLACKLISTED       = -3
ERR_LAUNCH_FAILED     = -4
ERR_NO_SUCH_FILE      = -5
ERR_NO_SESSION_OPEN   = -6
ERR_UNSAVED_CHANGES   = -7
ERR_NOT_NOW           = -8
ERR_BAD_PROJECT       = -9
ERR_CREATE_FAILED     = -10
ERR_SESSION_LOCKED    = -11
ERR_OPERATION_PENDING = -12
ERR_COPY_RUNNING      = -13

COMMAND_NONE      = 0
COMMAND_QUIT      = 1
COMMAND_KILL      = 2
COMMAND_SAVE      = 3
COMMAND_OPEN      = 4
COMMAND_START     = 5
COMMAND_CLOSE     = 6
COMMAND_DUPLICATE = 7
COMMAND_NEW       = 8

WAIT_FOR_NONE     = 0
WAIT_FOR_STOP     = 1
WAIT_FOR_ANNOUNCE = 2
WAIT_FOR_REPLY    = 3

TEMPLATE_NONE         = 0
TEMPLATE_RENAME       = 1
TEMPLATE_SESSION_SAVE = 2
TEMPLATE_SESSION_LOAD = 3
TEMPLATE_CLIENT_SAVE  = 4
TEMPLATE_CLIENT_LOAD  = 5

debug = False
last_client_message = ''
known_as_non_active = []

def dirname(*args):
    return os.path.dirname(*args)

def basename(*args):
    return os.path.basename(*args)

def signalHandler(sig, frame):
    if sig in (signal.SIGINT, signal.SIGTERM):
        session.terminate()
        
def remove_accents(input_str):
    nfkd_form = unicodedata.normalize('NFKD', input_str)
    return u"".join([c for c in nfkd_form if not unicodedata.combining(c)]).lower()    

def ifDebug(string):
    if debug:
        print(string, file=sys.stderr)

def isPIdChildOf(child_pid, parent_pid):
    ppid = child_pid
    this_pid = os.getpid()
    
    while ppid != parent_pid and ppid > 1 and ppid != this_pid:
        try:
            ppid = int(subprocess.check_output(['ps', '-o', 'ppid=', '-p', str(ppid)]))
        except:
            return False
        
    if ppid == parent_pid:
        return True
    
    return False

def MESSAGE(string):
    global last_client_message
    
    if last_client_message and last_client_message != 'daemon':
        sys.stderr.write('\n')
        
    sys.stderr.write('[\033[90mray-daemon\033[0m]\033[92m%s\033[0m\n' % string)
    
    last_client_message = 'daemon'

def CLIENT_MESSAGE(byte_string, client_name, client_id):
    global last_client_message
    
    client_str = "%s.%s" % (client_name, client_id)
    
    if not debug_only:
        if last_client_message != client_str:
            sys.stderr.write('\n[\033[90m%s-%s\033[0m]\n' % (client_name, client_id))
        sys.stderr.buffer.write(byte_string)
    
    last_client_message = client_str

def WARNING(string):
    print('[' + '\033[90m' + 'ray-daemon' + '\033[0m' + '] ' + '\033[93m' + string + '\033[0m', file=sys.stderr)
    
def GUIMSG(message):
    server.sendGui('/ray/gui/server/message', message)

def waitForJack():
    pass
    #if jack_bus and jack_bus.IsStarted():
        #all_ports = jack_bus.GetAllPorts()
        #del all_ports
        
def quitRay(sig, frame):
    for client in session.clients:
        if client.isRunning():
            MESSAGE(_translate('GUIMSG', 'Good Bye ! Clients are still running.'))
            break
    else:
        MESSAGE(_translate('GUIMSG', 'Good Bye !'))
    app.quit()

class CopyFile(object):
    slots = ['orig_path',
             'dest_path',
             'state',
             'size']

class FileCopier(QObject):
    def __init__(self):
        QObject.__init__(self)
        self.client_id      = ''
        self.next_function  = None
        self.abort_function = None
        self.next_args      = []
        self.copy_files     = []
        self.copy_size      = 0
        self.aborted        = False
        self.is_active      = False
        
        self.process = QProcess()
        self.process.finished.connect(self.processFinished)
        if QT_VERSION >= (5, 6):
            self.process.errorOccurred.connect(self.errorOccurred)
        
        self.timer = QTimer()
        self.timer.setInterval(250)
        self.timer.setSingleShot(True)
        self.timer.timeout.connect(self.checkProgressSize)
        
        
    def getFileSize(self, filepath):
        if not os.path.exists(filepath):
            return 0
        
        try:
            du_full = subprocess.check_output(['nice', '-n', '15', 'du', '-sb', filepath]).decode()
        except:
            du_full = ""
            
        if not du_full:
            return 0
        
        du_str = du_full.split('\t')[0]
        if not du_str.isdigit():
            return 0
        
        return int(du_str)
        
    def checkProgressSize(self):
        current_size = 0
        self.timer.stop()
        
        for copy_file in self.copy_files:
            if copy_file.state == 2:
                current_size += copy_file.size
            elif copy_file.state == 1:
                current_size += self.getFileSize(copy_file.dest_path)
                break

        if current_size and self.copy_size:
            progress = float(current_size/self.copy_size)
            
            if self.client_id:
                server.sendGui('/ray/gui/client/progress', self.client_id, progress)
            else:
                server.sendGui('/ray/gui/server_progress', progress)
        
        self.timer.start()
    
    def processFinished(self, exit_code, exit_status):
        self.timer.stop()
        
        for copy_file in self.copy_files:
            if copy_file.state == 1:
                copy_file.state = 2
                break
        
        if self.aborted:
            ##remove all created files
            for copy_file in self.copy_files:
                if copy_file.state > 0:
                    file_to_remove = copy_file.dest_path
                    
                    if os.path.exists(file_to_remove):
                        try:
                            subprocess.run(['rm', '-R', file_to_remove]) 
                        except:
                            pass
                        
            self.is_active = False
            server.informCopytoGui(False)
            self.abort_function(*self.next_args)
            return
        
        #run next_function if copy is terminated
        for copy_file in self.copy_files:
            if copy_file.state != 2:
                break
        else:
            self.is_active = False
            server.informCopytoGui(False)
            
            if self.next_function:
                self.next_function(*self.next_args)
                
            return
        
        self.nextProcess()
        
    def errorOccurred(self):
        #todo make something else
        self.processFinished(0, 0)
        
    def nextProcess(self):
        self.is_active = True
        
        for copy_file in self.copy_files:
            if copy_file.state == 0:
                copy_file.state = 1
                self.process.start('nice' , ['-n', '+15', 'cp', '-R', copy_file.orig_path, copy_file.dest_path])
                break
            
        self.timer.start()
    
    def start(self, src_list, dest_dir, next_function, abort_function, next_args=[]):
        self.abort_function = abort_function
        self.next_function  = next_function
        self.next_args      = next_args
        
        self.aborted = False
        self.copy_size = 0
        self.copy_files.clear()
        
        dest_path_exists = bool(os.path.exists(dest_dir))
        if dest_path_exists:
            if not os.path.isdir(dest_dir):
                #TODO send error, but it should not append
                self.abort_function(*self.next_args)
                return
        
        for orig_path in src_list:
            copy_file = CopyFile()
            copy_file.state     = 0
            copy_file.orig_path = orig_path
            copy_file.size      = self.getFileSize(orig_path)
            
            self.copy_size+=copy_file.size
            
            if dest_path_exists:
                copy_file.dest_path = "%s/%s" % (dest_dir, basename(orig_path))
            else:
                #WARNING works only with one file !!!
                copy_file.dest_path = dest_dir
            
            self.copy_files.append(copy_file)
        
        
        if self.copy_files:
            server.informCopytoGui(True)
            self.nextProcess()
        else:
            self.next_function(*self.next_args)
        
    def startClientCopy(self, client_id, src_list, dest_dir, next_function, abort_function, next_args=[]):
        self.client_id = client_id
        self.start(src_list, dest_dir, next_function, abort_function, next_args)
        
    def startSessionCopy(self, src_dir, dest_dir, next_function, abort_function):
        self.client_id = ''
        self.start([src_dir], dest_dir, next_function, abort_function)
        
    def abort(self, abort_function=None, next_args=[]):
        if abort_function:
            self.abort_function = abort_function
            self.next_args = next_args
        
        self.timer.stop()
        if self.process.state() == QProcess.Running:
            self.aborted = True
            self.process.terminate()
            
    def isActive(self, client_id=''):
        if client_id and client_id != self.client_id:
            return False
        
        return self.is_active
        
class Client(QObject):
    #can be directly changed by OSC thread
    gui_visible      = True
    _reply_errcode   = 0
    _reply_message   = None
    progress         = 0
    
    #have to be modified by main thread for security
    addr             = None
    pid              = 0
    pending_command  = COMMAND_NONE
    active           = False
    client_id        = ''
    capabilities     = ''
    did_announce     = False
    
    status           = CLIENT_STATUS_STOPPED
    name             = ''
    executable_path  = ''
    arguments        = ''
    tmp_arguments    = ''
    label            = ''
    icon             = ''
    pre_existing     = False
    project_path     = ""
    prefix_mode      = PREFIX_MODE_SESSION_NAME
    auto_start       = True
    start_gui_hidden = False
    check_last_save  = True
    sent_to_gui      = False
    
    def __init__(self):
        QObject.__init__(self)
        self.process = QProcess()
        self.process.started.connect(self.processStarted)
        if QT_VERSION >= (5, 6):
            self.process.errorOccurred.connect(self.errorInProcess)
        self.process.finished.connect(self.processFinished)
        self.process.readyReadStandardError.connect(self.standardError)
        self.process.readyReadStandardOutput.connect(self.standardOutput)
        
        #if client is'n't stopped 2secs after stop, another stop becames a kill!
        self.stopped_since_long = False
        self.stopped_timer = QTimer()
        self.stopped_timer.setSingleShot(True)
        self.stopped_timer.setInterval(2000) #2sec
        self.stopped_timer.timeout.connect(self.stoppedSinceLong)
    
    def readXmlProperties(self, ctx):
        #ctx is an xml sibling for client
        self.executable_path  = ctx.attribute('executable')
        self.arguments        = ctx.attribute('arguments')
        self.name             = ctx.attribute('name')
        self.label            = ctx.attribute('label')
        self.icon             = ctx.attribute('icon')
        self.auto_start       = bool(ctx.attribute('launched') != '0')
        self.check_last_save  = bool(ctx.attribute('check_last_save') != '0')
        self.start_gui_hidden = bool(ctx.attribute('gui_visible') == '0')
        
        prefix_mode = ctx.attribute('prefix_mode')
        
        if prefix_mode and prefix_mode.isdigit():
            if 0 <= int(prefix_mode) <= 2:
                self.prefix_mode = int(prefix_mode)
                if self.prefix_mode == 0:
                    self.project_path = ctx.attribute('project-path')
                    
                    
        if ctx.attribute('id'):
            #session use "id" for absolutely needed client_id
            self.client_id = ctx.attribute('id')
            
        elif ctx.attribute('client_id'):
            #template use "client_id" for wanted client_id
            self.client_id       = session.generateClientId(ctx.attribute('client_id'))
        
    def writeXmlProperties(self, ctx):
        ctx.setAttribute('executable', self.executable_path)
        ctx.setAttribute('name', self.name)
        if self.label:
            ctx.setAttribute('label', self.label)
        if self.icon:
            ctx.setAttribute('icon', self.icon)
        if not self.check_last_save:
            ctx.setAttribute('check_last_save', "0")
        if self.arguments:
            ctx.setAttribute('arguments', self.arguments)
            
        if self.prefix_mode != PREFIX_MODE_SESSION_NAME:
            ctx.setAttribute('prefix_mode', self.prefix_mode)
            
            if self.prefix_mode == PREFIX_MODE_UNDEF:
                ctx.setAttribute('project_path', self.project_path)
                
        if self.isCapableOf(':optional-gui:'):
            if self.executable_path != 'ray-proxy':
                if self.start_gui_hidden:
                    ctx.setAttribute('gui_visible', '0')
            
                
    def setReply(self, errcode, message):
        self._reply_message = message
        self._reply_errcode = errcode
    
    def setLabel(self, label):
        self.label = label
        self.sendGuiClientProperties()
        
    def setIcon(self, icon_name):
        self.icon = icon_name
        self.sendGuiClientProperties()
        
    def hasError(self):
        if self._reply_errcode:
            return self._reply_errcode
        
    def errorCode(self):
        return self._reply_errcode
    
    def getMessage(self):
        return self._reply_message
    
    def isReplyPending(self):
        if self.pending_command:
            return self.pending_command
        
    def isDumbClient(self):
        return bool(not self.did_announce)
    
    def isCapableOf(self, capability):
        return bool(capability in self.capabilities)
    
    def setStatus(self, status):
        #CLIENT_STATUS_COPY is not a status as the other ones.
        #GUI needs to know if client is started/open/stopped while files are copied
        #so self.status doesn't remember CLIENT_STATUS_COPY, although it is sent to GUI
        
        if status != CLIENT_STATUS_COPY:
            self.status = status
            server.sendClientStatusToGui(self)
        
        if status == CLIENT_STATUS_COPY or file_copier.isActive(self.client_id):
            server.sendGui("/ray/gui/client/status", self.client_id, CLIENT_STATUS_COPY)
    
    def getJackClientName(self):
        jack_client_name = self.name
        
        numid = ''
        if '_' in self.client_id:
            numid = self.client_id.rpartition('_')[2]
        if numid.isdigit():
            jack_client_name += '_'
            jack_client_name += numid
        
        return jack_client_name
    
    def getProjectPath(self):
        if self.prefix_mode == PREFIX_MODE_SESSION_NAME:
            return "%s/%s.%s" % (session.path, session.name, self.client_id)
        elif self.prefix_mode == PREFIX_MODE_CLIENT_NAME:
            return "%s/%s.%s" % (session.path, self.name, self.client_id)
        else:
            current_dir = os.getcwd()
            os.chdir(session.path)
            project_path = os.path.realpath(self.project_path)
            os.chdir(current_dir)
            
            return project_path
    
    def start(self):
        session.setRenameable(False)
        
        GUIMSG(_translate("GUIMSG", "Launching %s") % self.executable_path)
        os.environ['NSM_URL'] = server.url
        
        self.pending_command = COMMAND_START
        
        arguments = []
        
        if self.tmp_arguments:
            arguments += shlex.split(self.tmp_arguments)
            
        if self.arguments:
            arguments += shlex.split(self.arguments)
            
        self.process.start(self.executable_path, arguments)
        #self.process.start('konsole', ['--hide-tabbar', '--hide-menubar', '-e', self.executable_path] + arguments)
     
    def terminate(self):
        if self.isRunning():
            self.process.terminate()
        
    def kill(self):
        if self.isRunning():
            self.process.kill()
            
    def isRunning(self):
        return bool(self.process.state() == 2)
    
    def standardError(self):
        standard_error = self.process.readAllStandardError().data()
        CLIENT_MESSAGE(standard_error, self.name, self.client_id)
        
    def standardOutput(self):
        standard_output = self.process.readAllStandardOutput().data()
        CLIENT_MESSAGE(standard_output, self.name, self.client_id)
    
    def processStarted(self):
        self.stopped_since_long = False
        self.pid    = self.process.pid()
        self.setStatus(CLIENT_STATUS_LAUNCH)
        
        #MESSAGE("Process has pid: %i" % self.pid)
        
        
        if session.osc_src_addr:
            server.send(session.osc_src_addr, "/reply", session.osc_path, ERR_OK, "Launched." )
        
    
    def processFinished(self, exit_code, exit_status):
        self.stopped_timer.stop()
        
        if self.pending_command in (COMMAND_KILL, COMMAND_QUIT):
            GUIMSG(_translate('GUIMSG', "Client %s terminated because we told it to.") % self.name)
        else:
            GUIMSG(_translate('GUIMSG', "Client %s died unexpectedly.") % self.name)
        
        if session.wait_for:
            session.endTimerIfLastExpected(self)
        
        if self.pending_command == COMMAND_QUIT:
            session.removeClient(self)
            return
        else:
            self.setStatus(CLIENT_STATUS_STOPPED)
                
        self.pending_command = COMMAND_NONE
        self.active          = False
        self.pid             = 0
        
        session.setRenameable(True)
        
    def errorInProcess(self, error):
        if error == QProcess.FailedToStart:
            GUIMSG(_translate('GUIMSG', "Failed to start %s") % self.name)
            self.active     = False
            self.pid        = 0
            self.setStatus(CLIENT_STATUS_STOPPED)
            self.pending_command = COMMAND_NONE
            
            #if session.osc_src_addr:
                ##Finally, not sure that it's a good idea to display error dialog in this case.
                #server.send(session.osc_src_addr, "/error", session.osc_path, ERR_LAUNCH_FAILED, "Failed to launch process!")
            
            if session.wait_for:
                session.endTimerIfLastExpected(self)
        
        session.setRenameable(True)
    
    def stoppedSinceLong(self):
        self.stopped_since_long = True
        server.sendGui('/ray/gui/client/still_running', self.client_id)
    
    def tellClientSessionIsLoaded(self):
        if self.active and not self.isDumbClient():
            MESSAGE("Telling client %s that session is loaded." % self.name)
            server.send(self.addr, "/nsm/client/session_is_loaded")
    
    def save(self):
        if self.active:
            MESSAGE("Telling %s to save" % self.name)
            server.send(self.addr, "/nsm/client/save")
            
            self.pending_command = COMMAND_SAVE
            self.setStatus(CLIENT_STATUS_SAVE)
        
        elif self.isDumbClient() and self.isRunning():
            self.status = CLIENT_STATUS_NOOP
            server.sendClientStatusToGui(self)
            
        if self.isCapableOf(':optional-gui:'):
            self.start_gui_hidden = not bool(self.gui_visible)
            
    def stop(self):
        GUIMSG(_translate('GUIMSG', "Stopping client %s") % self.name)
        if self.isRunning():
            self.pending_command = COMMAND_KILL
            self.setStatus(CLIENT_STATUS_QUIT)
            self.process.terminate()
            
            if not self.stopped_timer.isActive():
                self.stopped_timer.start()
    
    def quit(self):
        MESSAGE("Commanding %s to quit" % self.name)
        if self.active:
            
            self.pending_command = COMMAND_QUIT
            self.terminate()
            self.setStatus(CLIENT_STATUS_QUIT)
        
        elif self.isDumbClient():
            if self.isRunning():
                self.pending_command = COMMAND_QUIT
                self.terminate()
                self.setStatus(CLIENT_STATUS_QUIT)
            else:
                server.sendGui("/ray/gui/client/status", self.client_id, CLIENT_STATUS_REMOVED)
    
    def switch(self, new_client):
        old_client_id     = self.client_id
        self.client_id    = new_client.client_id
        self.name         = new_client.name
        self.prefix_mode  = new_client.prefix_mode
        self.project_path = new_client.project_path
        self.label        = new_client.label
        self.icon         = new_client.icon
        
        jack_client_name    = self.getJackClientName()
        client_project_path = self.getProjectPath()
        
        MESSAGE("Commanding %s to switch \"%s\"" % (self.name, client_project_path))
        
        server.send(self.addr, "/nsm/client/open", client_project_path,  session.name, jack_client_name)
        
        
        self.pending_command = COMMAND_OPEN
        self.setStatus(CLIENT_STATUS_SWITCH)
            
        server.sendGui("/ray/gui/client/switch", old_client_id, self.client_id)
    
    def sendGuiClientProperties(self, removed=False):
        ad = '/ray/gui/client/update' if self.sent_to_gui else '/ray/gui/client/new'
            
        if removed:
            ad = '/ray/gui/trash/add'
            
        server.sendGui(ad,
                        self.client_id, 
                        self.executable_path,
                        self.arguments,
                        self.name, 
                        self.prefix_mode, 
                        self.project_path,
                        self.label,
                        self.icon,
                        self.capabilities,
                        int(self.check_last_save))
        
        self.sent_to_gui = True
    
    def updateClientProperties(self, client_data):
        self.client_id       = client_data.client_id
        self.executable_path = client_data.executable_path
        self.arguments       = client_data.arguments
        self.prefix_mode     = client_data.prefix_mode
        self.project_path    = client_data.project_path
        self.label           = client_data.label
        self.icon            = client_data.icon
        self.capabilities    = client_data.capabilities
        self.check_last_save = client_data.check_last_save
        
        self.sendGuiClientProperties()
    
    def prettyClientId(self):
        wanted = self.client_id
        
        if self.executable_path == 'ray-proxy':
            proxy_file = "%s/ray-proxy.xml" % self.getProjectPath()
            
            if os.path.exists(proxy_file):
                file = open(proxy_file, 'r')
                xml = QDomDocument()
                xml.setContent(file.read())
                file.close()
                
                content = xml.documentElement()
                if content.tagName() == 'RAY-PROXY':
                    executable = content.attribute('executable')
                    if executable:
                        wanted = executable
            
            
        if '_' in wanted:
            begin, udsc, end = wanted.rpartition('_')
            
            if not end:
                return wanted
            
            if not end.isdigit():
                return wanted
            
            return begin
        
        return wanted
    
    def getProjectFiles(self):
        #return a list of full filenames
        client_files = []
        
        project_path = self.getProjectPath()
        if os.path.exists(project_path):
            client_files.append(project_path)
            
        if project_path.startswith('%s/' % session.path):
            base_project = project_path.replace('%s/' % session.path, '', 1)
            
            for filename in os.listdir(session.path):
                if filename == base_project:
                    full_file_name =  "%s/%s" % (session.path, filename)
                    if not full_file_name in client_files:
                        client_files.append(full_file_name)
                        
                elif filename.startswith('%s.' % base_project):
                    client_files.append('%s/%s' % (session.path, filename))
                    
        return client_files
            
    def saveAsTemplate(self, template_name):
        #copy files
        if self.prefix_mode != PREFIX_MODE_UNDEF:
            client_files = self.getProjectFiles()
                        
            template_dir = "%s/%s" % (client_template_local_root, template_name)
            
            if os.path.exists(template_dir):
                if os.access(template_dir, os.W_OK):
                    shutil.rmtree(template_dir)
                else:
                    #TODO send error
                    return
                
            os.makedirs(template_dir)
            
            if client_files:
                self.setStatus(CLIENT_STATUS_COPY)
                file_copier.startClientCopy(self.client_id, client_files, template_dir, self.saveAsTemplate_step1, self.saveAsTemplateAborted, [template_name])
            else:
                self.saveAsTemplate_step1(template_name)

    def saveAsTemplate_step1(self, template_name):
        self.setStatus(self.status) #see setStatus to see why
        
        if self.prefix_mode != PREFIX_MODE_UNDEF:
            self.adjustFilesAfterCopy(template_name, TEMPLATE_CLIENT_SAVE)
            
        xml_file = "%s/%s" % (client_template_local_root, 'client_templates.xml')
        
        #security check
        if os.path.exists(xml_file):
            if not os.access(xml_file, os.W_OK):
                return
            
            if os.path.isdir(xml_file):
                #should not be a dir, remove it !
                subprocess.run('rm', '-R', xml_file)
        
        
        if not os.path.isdir(client_template_local_root):
            os.makedirs(client_template_local_root)
        
        #create client_templates.xml if not exists
        if not os.path.isfile(xml_file):
            file = open(xml_file, 'w')
            
            xml = QDomDocument()
            rct = xml.createElement('RAY-CLIENT-TEMPLATES')
            xml.appendChild(rct)
            file.write(xml.toString())
            file.close()
            del xml
            
        file = open(xml_file, 'r')
        xml = QDomDocument()
        xml.setContent(file.read())
        file.close()
        content = xml.documentElement()
                
        if not content.tagName() == 'RAY-CLIENT-TEMPLATES':
            return
        
        
        #remove existing template if it has the same name as the new one
        node = content.firstChild()
        while not node.isNull():
            if node.toElement().tagName() != 'Client-Template':
                node = node.nextSibling()
                continue
            
            if node.toElement().attribute('template-name') == template_name:
                content.removeChild(node)
            
            node = node.nextSibling()
        
        #create template
        rct = xml.createElement('Client-Template')
        
        self.writeXmlProperties(rct)
        rct.setAttribute('template-name', template_name)
        rct.setAttribute('client_id', self.prettyClientId())
        
        if not self.isRunning():
            rct.setAttribute('launched', False)
            
        content.appendChild(rct)
        
        file = open(xml_file, 'w')
        file.write(xml.toString())
        file.close()
    
    def saveAsTemplateAborted(self, template_name):
        self.setStatus(self.status)
    
    def adjustFilesAfterCopy(self, new_session_full_name, template_save=TEMPLATE_NONE):            
        old_session_name = session.name
        new_session_name = basename(new_session_full_name)
        new_client_id    = self.client_id
        old_client_id    = self.client_id
        xsessionx   = "XXX_SESSION_NAME_XXX"
        xclient_idx = "XXX_CLIENT_ID_XXX"
        
        if template_save == TEMPLATE_NONE:
            if self.prefix_mode != PREFIX_MODE_SESSION_NAME:
                return
            
            spath = "%s/%s" % (session.root, new_session_full_name)
        
        elif template_save == TEMPLATE_RENAME:
            spath = session.path
            
        elif template_save == TEMPLATE_SESSION_SAVE:
            spath = "%s/%s" % (session_template_root, new_session_full_name)
            new_session_name = xsessionx
            
        elif template_save == TEMPLATE_SESSION_LOAD:
            spath = "%s/%s" % (session.root, new_session_full_name)
            old_session_name = xsessionx
            
        elif template_save == TEMPLATE_CLIENT_SAVE:
            spath = "%s/%s" % (client_template_local_root, new_session_full_name)
            new_session_name = xsessionx
            new_client_id    = xclient_idx
           
        elif template_save == TEMPLATE_CLIENT_LOAD:
            spath = session.path
            old_session_name = xsessionx
            old_client_id    = xclient_idx
        
        old_prefix = old_session_name
        new_prefix = new_session_name
        
        if self.prefix_mode == PREFIX_MODE_CLIENT_NAME:
            old_prefix = new_prefix = self.name
        
        project_path = "%s/%s.%s" % (spath, old_prefix, old_client_id)
        
        if not os.path.exists(project_path):
            for file in os.listdir(spath):
                if ( file.startswith("%s.%s." % (old_prefix, old_client_id)) or
                    file == "%s.%s" %(old_prefix, old_client_id) ):
                    
                    if not os.access("%s/%s" % (spath, file), os.W_OK):
                        continue
                    
                    endfile = file.replace("%s.%s." % (old_prefix, old_client_id), '', 1)
                    
                    os.rename('%s/%s' %(spath, file), "%s/%s.%s.%s" % (spath, new_prefix, new_client_id, endfile))
            return
        
        if not os.path.isdir(project_path):
            if not os.access(project_path, os.W_OK):
                return
            
            os.rename(project_path, "%s/%s.%s" % (spath, new_prefix, new_client_id))
            return
        
        #only for ardour
        ardour_file  = "%s/%s.ardour"     % (project_path, old_prefix)
        ardour_bak   = "%s/%s.ardour.bak" % (project_path, old_prefix)
        ardour_audio = "%s/interchange/%s.%s" % (project_path, old_prefix, old_client_id)
        
        if os.path.isfile(ardour_file) and os.access(ardour_file, os.W_OK):
            os.rename(ardour_file, "%s/%s.ardour" % (project_path, new_prefix))
        if os.path.isfile(ardour_bak) and os.access(ardour_bak, os.W_OK):
            os.rename(ardour_bak, "%s/%s.ardour.bak" % (project_path, new_prefix))
        if os.path.isdir(ardour_audio and os.access(ardour_audio, os.W_OK)):
            os.rename(ardour_audio, "%s/interchange/%s.%s" % (project_path, new_prefix, new_client_id))
        
        #change last_used snapshot of ardour
        instant_file = "%s/instant.xml" % project_path
        if os.path.isfile(instant_file) and os.access(instant_file, os.W_OK):
            try :
                file = open(instant_file, 'r')
                xml = QDomDocument()
                xml.setContent(file.read())
                content = xml.documentElement()
                
                if content.tagName() == 'instant':
                    node = content.firstChild()
                    while not node.isNull():
                        tag = node.toElement()
                        if tag.tagName() == 'LastUsedSnapshot':
                            if tag.attribute('name') == old_prefix:
                                tag.setAttribute('name', new_prefix)
                                file = open(instant_file, 'w')
                                file.write(xml.toString())
                            break
                            
                        node = node.nextSibling()
                file.close()
            except:
                False
        
        #for Vee One Suite
        for extfile in ('samplv1', 'synthv1', 'padthv1', 'drumkv1'):
            old_veeone_file = "%s/%s.%s" % (project_path, old_session_name, extfile)
            new_veeone_file = "%s/%s.%s" % (project_path, new_session_name, extfile)
            if os.path.isfile(old_veeone_file) and os.access(old_veeone_file, os.W_OK) and not os.path.exists(new_veeone_file):
                os.rename(old_veeone_file, new_veeone_file)
        
        
        #for ray-proxy, change config_file name
        proxy_file = "%s/ray-proxy.xml" % project_path
        if os.path.isfile(proxy_file):
            try:
                file = open(proxy_file, 'r')
                xml = QDomDocument()
                xml.setContent(file.read())
                content = xml.documentElement()
                
                if content.tagName() == "RAY-PROXY":
                    cte = content.toElement()
                    config_file = cte.attribute('config_file')
                    
                    if ('$RAY_SESSION_NAME' or '${RAY_SESSION_NAME}') in config_file:
                        for env in ('"$RAY_SESSION_NAME"', '"${RAY_SESSION_NAME}"', "$RAY_SESSION_NAME", "${RAY_SESSION_NAME}"):
                            config_file = config_file.replace(env, old_session_name)
                        
                        if config_file and config_file.split('.')[0] == old_session_name:
                            config_file_path = "%s/%s" % (project_path, config_file)
                            
                            if os.path.exists(config_file_path) and os.access(config_file_path, os.W_OK):
                                os.rename(config_file_path, "%s/%s" % (project_path, config_file.replace(old_session_name, new_session_name)))
                                            
                file.close()
                        
            except:
                False
        
        if os.access(project_path, os.W_OK):
            subprocess.run(['mv', project_path, "%s/%s.%s" % (spath, new_prefix, new_client_id)])
    
    def serverAnnounce(self, path, args, src_addr, is_new):
        client_name, capabilities, executable_path, major, minor, pid = args
        
        if self.pending_command in (COMMAND_QUIT, COMMAND_KILL):
            return
        
        if major > NSM_API_VERSION_MAJOR:
            MESSAGE("Client is using incompatible and more recent API version %i.%i" % (major, minor))
            server.send(src_addr, "/error", path, ERR_INCOMPATIBLE_API, "Server is using an incompatible API version." )
            return
        
        #self.pid          = pid
        self.capabilities = capabilities
        self.addr         = src_addr
        self.name         = client_name
        self.active       = True
        self.did_announce = True
        
        if self.executable_path in known_as_non_active:
            known_as_non_active.remove(self.executable_path)
        
        MESSAGE("Process has pid: %i" % pid )
        MESSAGE("The client \"%s\" at \"%s\" informs us it's ready to receive commands." % (self.name, self.addr.url) )
        server.send(src_addr, "/reply", path, "Well hello, stranger. Welcome to the party." if is_new else "Howdy, what took you so long?", APP_TITLE, ":server-control:broadcast:optional-gui:" )
        
        self.sendGuiClientProperties()
        self.setStatus(CLIENT_STATUS_OPEN)
        
        if self.isCapableOf(":optional-gui:"):
            server.sendGui("/ray/gui/client/has_optional_gui", self.client_id)
            
            if self.start_gui_hidden:
                server.send(src_addr, "/nsm/client/hide_optional_gui")
                
        jack_client_name    = self.getJackClientName()
        client_project_path = self.getProjectPath()
        
        server.send(src_addr, "/nsm/client/open", client_project_path,  session.name, jack_client_name)
        self.pending_command = COMMAND_OPEN
       
class Session(QObject):
    def __init__(self):
        QObject.__init__(self)
        self.clients = []
        self.new_clients = []
        self.removed_clients = []
        self.name    = ""
        self.path    = ""
        self.root    = ""
        
        self.is_renameable = True
        self.forbidden_ids_list = []
    
    #############
    
    def setRoot(self, session_root):
        if self.name:
            return
        self.root = session_root
    
    def setName(self, session_name):
        self.name = session_name
    
    def setPath(self, session_path):
        self.path = session_path
        self.setName(session_path.rpartition('/')[2])
    
    def setRenameable(self, renameable):
        if not renameable:
            if self.is_renameable:
                self.is_renameable = False
                server.sendGui('/ray/gui/session/renameable', 0)
            return
        
        for client in self.clients:
            if client.isRunning():
                return
            
        self.is_renameable = True
        server.sendGui('/ray/gui/session/renameable', 1)
    
    def getClient(self, client_id):
        for client in self.clients:
            if client.client_id == client_id:
                return client
        else:
            ifDebug("client_id %s is not in ray-daemon session")
    
    def newClient(self, executable, client_id=None):
        client = Client()
        client.executable_path = executable
        client.name = basename(executable)
        client.client_id = client_id if client_id else self.generateClientId(executable)
        self.clients.append(client)
        return client
    
    def removeClient(self, client):
        if not client in self.clients:
            return
        
        client.setStatus(CLIENT_STATUS_REMOVED)
        
        if client.getProjectFiles():
            self.removed_clients.append(client)
            client.sendGuiClientProperties(removed=True)
        self.clients.remove(client)
    
    def restoreClient(self, client):
        client.sent_to_gui = False
        
        self.addClient(client)
        
        server.sendGui('/ray/gui/trash/remove', client.client_id)
        self.removed_clients.remove(client)
        
        if client.auto_start:
            client.start()
    
    def tellAllClientsSessionIsLoaded(self):
        MESSAGE("Telling all clients that session is loaded...")
        for client in self.clients:
            client.tellClientSessionIsLoaded()
    
    def purgeInactiveClients(self):
        remove_item_list = []
        for i in range(len(self.clients)):
            if not self.clients[i].active:
                server.sendGui("/ray/gui/client/status", session.clients[i].client_id, CLIENT_STATUS_REMOVED)
                remove_item_list.append(i)
        
        remove_item_list.reverse()
        
        for i in remove_item_list:
            self.clients.__delitem__(i)
            
        del remove_item_list
            
    def clientsHaveErrors(self):
        for client in self.clients:
            if client.active and client.hasError():
                return True
        return False
    
    def updateForbiddenIdsList(self):
        if not self.path:
            return
        
        self.forbidden_ids_list.clear()
        
        for file in os.listdir(self.path):
            if os.path.isdir("%s/%s" % (self.path, file)) and '.' in file:
                client_id = file.rpartition('.')[2]
                if not client_id in self.forbidden_ids_list:
                    self.forbidden_ids_list.append(client_id)
                    
            elif os.path.isfile("%s/%s" % (self.path, file)) and '.' in file:
                for string in file.split('.')[1:]:
                    if not string in self.forbidden_ids_list:
                        self.forbidden_ids_list.append(string)
                        
        for client in self.clients + self.removed_clients:
            if not client.client_id in self.forbidden_ids_list:
                self.forbidden_ids_list.append(client.client_id)
    
    def generateClientIdAsNsm(self):
        client_id = 'n'
        for l in range(4):
            client_id += random.choice(string.ascii_uppercase)
            
        return client_id
    
    def generateClientId(self, wanted_id=""):
        self.updateForbiddenIdsList()
        
        if wanted_id:
            for to_rm in ('ray-', 'non-', 'carla-'):
                if wanted_id.startswith(to_rm):
                    wanted_id = wanted_id.replace(to_rm, '', 1)
                    break
            
            wanted_id = wanted_id.replace('jack', '')
            
            #reduce string if contains '-'
            if '-' in wanted_id:
                new_wanted_id = ''
                seplist = wanted_id.split('-')
                for sep in seplist[:-1]:
                    if len(sep) > 0:
                        new_wanted_id += (sep[0] + '_')
                new_wanted_id += seplist[-1]
                wanted_id = new_wanted_id
            
            
            #prevent non alpha numeric characters
            new_wanted_id = ''
            last_is_ = False
            for char in wanted_id:
                if char.isalnum():
                    new_wanted_id += char
                else:
                    if not last_is_:
                        new_wanted_id += '_'
                        last_is_ = True
            
            wanted_id = new_wanted_id
            
            while wanted_id and wanted_id.startswith('_'):
                wanted_id = wanted_id[1:]
            
            while wanted_id and wanted_id.endswith('_'):
                wanted_id = wanted_id[:-1]
            
            if not wanted_id:
                wanted_id = self.generateClientIdAsNsm()
                while wanted_id in self.forbidden_ids_list:
                    wanted_id = self.generateClientIdAsNsm()
            
            #limit string to 10 characters
            if len(wanted_id) >= 11:
                wanted_id = wanted_id[:10]
            
            if not wanted_id in self.forbidden_ids_list:
                self.forbidden_ids_list.append(wanted_id)
                return wanted_id
            
            n=2
            while "%s_%i" % (wanted_id, n) in self.forbidden_ids_list:
                n+=1
            
            self.forbidden_ids_list.append(wanted_id)
            return "%s_%i" % (wanted_id, n)
                
                
        client_id = 'n'
        for l in range(4):
            client_id += random.choice(string.ascii_uppercase)
        
        while client_id in self.forbidden_ids_list:
            client_id = 'n'
            for l in range(4):
                client_id += random.choice(string.ascii_uppercase)
        
        self.forbidden_ids_list.append(client_id)
        return client_id
    
    def getListOfExistingClientIds(self):
        if not self.path:
            return []
        
        client_ids_list = []
        
        for file in os.listdir(self.path):
            if os.path.isdir(file) and file.contains('.'):
                client_ids_list.append(file.rpartition('.')[2])
            elif os.path.isfile(file) and file.contains('.'):
                file_without_extension = file.rpartition('.')[0]
                
    
    def addClient(self, client):
        self.clients.append(client)
        client.sendGuiClientProperties()
        
    def reOrderClients(self, client_ids_list):
        client_newlist  = []
        
        for client_id in client_ids_list:
            for client in self.clients:
                if client.client_id == client_id:
                    client_newlist.append(client)
                    break
        
        if len(client_ids_list) != len(self.clients):
            return
        
        self.clients.clear()
        for client in client_newlist:
            self.clients.append(client)

class OperatingSession(Session):
    #Session is separated in 3 parts only for faster search and modifications.
    def __init__(self):
        Session.__init__(self)
        self.wait_for = WAIT_FOR_NONE
        
        self.timer = QTimer()
        self.expected_clients = []
        
        self.timer_launch = QTimer()
        self.timer_launch.setInterval(100)
        self.timer_launch.timeout.connect(self.timerLaunchTimeOut)
        self.clients_to_launch = []
        
        self.timer_quit = QTimer()
        self.timer_quit.setInterval(100)
        self.timer_quit.timeout.connect(self.timerQuitTimeOut)
        self.clients_to_quit = []
        
        self.err_loading = ERR_OK
        self.err_saving  = ERR_OK
        
        self.osc_path     = None
        self.osc_args     = None
        self.osc_src_addr = None
        
        self.process_order = []
        
        self.terminated_yet = False
        
        
    
    def rememberOscArgs(self, path, args, src_addr):
        self.osc_path     = path
        self.osc_args     = args
        self.osc_src_addr = src_addr
    
    def waitAndGoTo(self, duration, follow, wait_for, single_shot=True):
        self.timer.stop()
        
        #we need to delete timer to change the timeout connect
        del self.timer
        self.timer = QTimer()
        
        if self.expected_clients:
            if wait_for == WAIT_FOR_ANNOUNCE:
                GUIMSG(_translate('GUIMSG', 'waiting for clients announces...'))
            elif wait_for == WAIT_FOR_STOP:
                GUIMSG(_translate('GUIMSG', 'waiting for clients to die...'))
            
            self.wait_for = wait_for
            self.timer.setSingleShot(True)
            self.timer.timeout.connect(follow)
            self.timer.start(duration)
        else:
            follow()
    
    def endTimerIfLastExpected(self, client):
        if client in self.expected_clients:
            self.expected_clients.remove(client)
        if not self.expected_clients:
            self.timer.setSingleShot(True)
            self.timer.stop()
            self.timer.start(0)
    
    def cleanExpected(self):
        if self.expected_clients:
            client_names = ""
            for client in self.expected_clients:
                client_names += client.name + ', ' 
            
            if self.wait_for == WAIT_FOR_ANNOUNCE:
                GUIMSG(_translate('GUIMSG', "%sdidn't announce") % client_names)
            elif self.wait_for == WAIT_FOR_STOP:
                GUIMSG(_translate('GUIMSG', "%sstill alive !") % client_names)
                
            self.expected_clients.clear()
        else:
            if self.wait_for == WAIT_FOR_ANNOUNCE:
                GUIMSG(_translate('GUIMSG', 'All expected clients are announced'))
            elif self.wait_for == WAIT_FOR_STOP:
                GUIMSG(_translate('GUIMSG', 'All expected clients are died'))
        self.wait_for = WAIT_FOR_NONE
    
    def nextFunction(self):
        if len(self.process_order) > 0:
            next_function = self.process_order[0]
            self.process_order.__delitem__(0)
            next_function()
    
    def timerLaunchTimeOut(self):
        if self.clients_to_launch:
            waitForJack()
            self.clients_to_launch[0].start()
            self.clients_to_launch.__delitem__(0)
            
        if not self.clients_to_launch:
            self.timer_launch.stop()
            
    def timerQuitTimeOut(self):
        if self.clients_to_quit:
            waitForJack()
            self.clients_to_quit[0].quit()
            self.clients_to_quit.__delitem__(0)
            
        if not self.clients_to_quit:
            self.timer_quit.stop()
    
    def sendError(self, err, error_message):
        #clear process order to allow other new operations
        self.process_order.clear()
        
        if not (self.osc_src_addr or self.osc_path):
            return
        
        server.send(self.osc_src_addr, "/error", self.osc_path, err, error_message)
    
    def adjustFilesAfterCopy(self, template_mode):
        new_session_full_name = self.osc_args[0]
        new_session_name = basename(new_session_full_name)
        spath = "%s/%s" % (self.root, new_session_full_name)
        
        #create temp clients from raysession.xml to adjust Files after copy
        session_file = "%s/%s" % (spath, "raysession.xml")
        
        try:
            ray_file = open(session_file, 'r')
        except:
            self.sendError(ERR_BAD_PROJECT, _translate("error", "impossible to read %s") % session_file)
            return
        
        tmp_clients = []
        
        xml = QDomDocument()
        xml.setContent(ray_file.read())

        content = xml.documentElement()
        
        if content.tagName() != "RAYSESSION":
            ray_file.close()
            self.err_loading = ERR_BAD_PROJECT
            self.loadError()
            return
        
        content.setAttribute('name', new_session_name)
        
        node = content.firstChild()
        while not node.isNull():
            tag_name = node.toElement().tagName()
            if tag_name in ('Clients', 'RemovedClients'):
                client_xml = node.toElement().firstChild()
                while not client_xml.isNull():
                    client = Client()
                    cx = client_xml.toElement()
                    client.readXmlProperties(cx)
                    
                    tmp_clients.append(client)
                    
                    client_xml = client_xml.nextSibling()
                    
            node = node.nextSibling()
        
        ray_file.close()
        
        ray_file_w = open(session_file, 'w')
        ray_file_w.write(xml.toString())
        ray_file_w.close()
        
        
        for client in tmp_clients:
            client.adjustFilesAfterCopy(new_session_full_name, template_mode)
    
    
    ############################## COMPLEX OPERATIONS ###################
    #all functions are splitted when we need to wait clients for something (announce, reply, quit)
    #for example, at the end of save(), timer is launched, 
    #then, when timer is timeout or when all client replied, save_step1 is launch
        
    def save(self):
        if not self.path:
            self.nextFunction()
            return
        
        server.setServerStatus(SERVER_STATUS_SAVE)
        
        for client in self.clients:
            if client.active:
                self.expected_clients.append(client)
                client.save()
                
        self.waitAndGoTo(10000, self.save_step1, WAIT_FOR_REPLY)
            
    def save_step1(self):
        self.cleanExpected()
        
        if not self.path:
            self.nextFunction()
            return
        
        session_file = self.path + '/raysession.xml'
        if os.path.isfile(session_file) and not os.access(session_file, os.W_OK):
            self.err_saving = ERR_CREATE_FAILED
            self.saveError()
            return
        
        try:
            file = open(session_file, 'w')
        except:
            self.err_saving = ERR_CREATE_FAILED
            self.saveError()
            return
        
        self.err_saving = ERR_OK
        
        xml = QDomDocument()
        p = xml.createElement('RAYSESSION')
        p.setAttribute('VERSION', VERSION)
        p.setAttribute('name', self.name)
        
        xml_cls = xml.createElement('Clients')
        xml_rmcls = xml.createElement('RemovedClients')
        
        for client in self.clients:
            cl = xml.createElement('client')
            cl.setAttribute('id', client.client_id)
            cl.setAttribute('launched', int(bool(client.isRunning())) )
            
            client.writeXmlProperties(cl)
            
            xml_cls.appendChild(cl)
            
        for client in self.removed_clients:
            cl = xml.createElement('client')
            cl.setAttribute('id', client.client_id)
            
            client.writeXmlProperties(cl)
            
            xml_rmcls.appendChild(cl)
            
        p.appendChild(xml_cls)
        p.appendChild(xml_rmcls)
        xml.appendChild(p)
        
        contents = ("<?xml version='1.0' encoding='UTF-8'?>\n"
                    "<!DOCTYPE RAYSESSION>\n")
        
        contents += xml.toString()
        
        
        file.write(contents)
        file.close()
        
        GUIMSG(_translate('GUIMSG', "Session saved."))
        MESSAGE("Session saved.")
        self.nextFunction()
    
    def saveDone(self):
        if not self.err_loading:
            MESSAGE("Done.")
            server.send(self.osc_src_addr, "/reply", self.osc_path, "Saved." )
        server.setServerStatus(SERVER_STATUS_READY)
    
    def saveError(self):
        MESSAGE("Failed")
        m = _translate('Load Error', "Unknown error")
        if self.err_saving == ERR_CREATE_FAILED:
            m = _translate('GUIMSG', "Can't save session, session file is unwriteable !")
        
        MESSAGE(m)
        GUIMSG(m)
        server.send(self.osc_src_addr, "/error", self.osc_path, ERR_CREATE_FAILED, m)
        
        self.process_order.clear()
        server.setServerStatus(SERVER_STATUS_READY)
        
    def close(self):
        GUIMSG(_translate('GUIMSG', "Commanding attached clients to quit."))
        self.expected_clients.clear()
        self.removed_clients.clear()
        
        if not self.path:
            self.nextFunction()
            return
        
        server.setServerStatus(SERVER_STATUS_CLOSE)
        server.sendGui('/ray/gui/trash/clear')
        
        
        for client in self.clients.__reversed__():
            if client.isRunning():
                self.expected_clients.append(client)
                self.clients_to_quit.append(client)
                self.timer_quit.start()
        
        self.waitAndGoTo(30000, self.close_step1, WAIT_FOR_STOP)
    
    def close_step1(self):
        for client in self.expected_clients:
            client.kill()
            
        self.waitAndGoTo(1000, self.close_step2, WAIT_FOR_STOP)
    
    def close_step2(self):
        self.cleanExpected()
        
        self.purgeInactiveClients()
        self.clients.clear()
        
        if self.path:
            lock_file =  self.path + '/.lock'
            if os.path.isfile(lock_file):
                os.remove(lock_file)
                
            self.setPath('')
            
        server.sendGui("/ray/gui/session/name", "", "" )
        self.nextFunction()
    
    def closeDone(self):
        server.send(self.osc_src_addr, "/reply", self.osc_path, "Closed.")
        MESSAGE("Done")
        server.setServerStatus(SERVER_STATUS_OFF)
    
    def abortDone(self):
        server.send(self.osc_src_addr, "/reply", self.osc_path, "Aborted.")
        MESSAGE("Done")
        server.setServerStatus(SERVER_STATUS_OFF)
        
    def new(self):
        GUIMSG(_translate('GUIMSG', "Creating new session \"%s\"") % self.osc_args[0])
        spath = self.root + '/' + self.osc_args[0]
        
        try:
            os.makedirs(spath)
        except:
            server.send(self.osc_src_addr, "/error", self.osc_path, ERR_CREATE_FAILED, "Could not create the session directory" )
            return
        
        server.setServerStatus(SERVER_STATUS_NEW)
        self.setPath(spath)
        server.send(self.osc_src_addr, "/reply", self.osc_path, "Created." )
        server.sendGui("/ray/gui/session/session", self.osc_args[0])
        server.sendGui("/ray/gui/session/name", self.osc_args[0], self.osc_args[0])
        
        server.send(self.osc_src_addr, "/reply", self.osc_path, "Session created")
        self.nextFunction()
    
    def newDone(self):
        GUIMSG(_translate('GUIMSG', 'Session is ready'))
        server.setServerStatus(SERVER_STATUS_READY)
    
    def duplicate(self):
        if self.clientsHaveErrors():
            self.sendError(ERR_GENERAL_ERROR, _translate('error', "Some clients could not save"))
            self.process_order.clear()
            return
        
        new_session_full_name = self.osc_args[0]
        spath = "%s/%s" % (self.root, new_session_full_name)
        
        server.sendGui('/ray/gui/trash/clear')
        
        server.setServerStatus(SERVER_STATUS_COPY)
        file_copier.startSessionCopy(self.path, spath, self.duplicate_step1, self.duplicateAborted)
    
    def duplicate_step1(self):
        self.adjustFilesAfterCopy(TEMPLATE_NONE)           
        self.nextFunction()
    
    def duplicateAborted(self):
        self.process_order.clear()
        server.setServerStatus(SERVER_STATUS_READY)
    
    def saveSessionTemplate(self):
        if self.clientsHaveErrors():
            self.sendError(ERR_GENERAL_ERROR, _translate('error', "Some clients could not save"))
            self.process_order.clear()
            return
        
        session_template_name = self.osc_args[0]
        spath = "%s/%s" % (session_template_root, session_template_name)
        
        #overwrite existing template
        if os.path.isdir(spath):
            if not os.access(spath, os.W_OK):
                self.sendError(ERR_GENERAL_ERROR, _translate("error", "Impossible to save template, unwriteable file !" ))
                server.setServerStatus(SERVER_STATUS_READY)
                return
            shutil.rmtree(spath)
        
        if not os.path.exists(session_template_root):
            os.makedirs(session_template_root)
        
        server.setServerStatus(SERVER_STATUS_COPY)
        file_copier.startSessionCopy(self.path, spath, self.saveSessionTemplate_step_1, self.saveSessionTemplateAborted)
        
    def saveSessionTemplate_step_1(self):
        session_template_name = self.osc_args[0]
        
        for client in self.clients + self.removed_clients:
            client.adjustFilesAfterCopy(session_template_name, TEMPLATE_SESSION_SAVE)
        
        MESSAGE("Done")
        server.send(self.osc_src_addr, "/reply", self.osc_path, "Saved as template.")
        server.setServerStatus(SERVER_STATUS_READY)
    
    def saveSessionTemplateAborted(self):
        self.process_order.clear()
        server.setServerStatus(SERVER_STATUS_READY)
    
    def prepareTemplate(self):
        if len(self.osc_args) != 2:
            return
        
        template_name = self.osc_args[1]
        template_path = "%s/%s" % (session_template_root, template_name)
        
        if template_name.startswith('///'):
            template_name = template_name.replace('///', '')
            template_path = "%s/%s" % (session_template_factory_root, template_name)
            
        if not os.path.isdir(template_path):
            self.sendError(ERR_GENERAL_ERROR, _translate("error", "No template named %s") % template_name)
            return
        
        new_session_full_name = self.osc_args[0]
        new_session_name = basename(new_session_full_name)
        spath = "%s/%s" % (self.root, new_session_full_name)
        
        if os.path.exists(spath):
            self.sendError(ERR_CREATE_FAILED, _translate("error", "Folder \n%s \nalready exists") % spath)
            return
        
        if self.path:
            server.setServerStatus(SERVER_STATUS_COPY)
        else:
            server.setServerStatus(SERVER_STATUS_PRECOPY)
            server.sendGui("/ray/gui/session/name",  new_session_name, new_session_name)
            
        file_copier.startSessionCopy(template_path, spath, self.prepareTemplate_step1, self.prepareTemplateAborted)
        
    def prepareTemplate_step1(self):
        self.adjustFilesAfterCopy(TEMPLATE_SESSION_LOAD)
        self.nextFunction()
    
    def prepareTemplateAborted(self):
        self.process_order.clear()
        if self.name:
            server.setServerStatus(SERVER_STATUS_READY)
        else:
            server.setServerStatus(SERVER_STATUS_OFF)
        
            self.setPath('')
            server.sendGui('/ray/gui/session/name', '', '')
        
    
    def load(self):
        #terminate or switch clients
        session_full_name = self.osc_args[0]
        
        spath = self.root + '/' + session_full_name
        
        #will be used to set raysession as nsm client in the future
        #if session_full_name.startswith('/') or server.is_nsm_locked:
        if session_full_name.startswith('/'):
            spath = session_full_name
            
        if not os.path.exists(spath):
            try:
                os.makedirs(spath)
            except:
                self.err_loading = ERR_CREATE_FAILED
                self.loadError()
                return
            
        MESSAGE("Attempting to open %s" % spath)
        
        session_ray_file = spath + '/raysession.xml'
        session_nsm_file = spath + '/session.nsm'
        session_lock = spath + '/.lock'
        
        self.err_loading = ERR_OK
        
        if os.path.isfile(session_lock):
            WARNING("Session is locked by another process")
            self.err_loading = ERR_SESSION_LOCKED
            self.loadError()
            return
        
        is_ray_file = True
        
        try:
            ray_file = open(session_ray_file, 'r')
        except:
            is_ray_file = False
            
        if not is_ray_file:
            try:
                file = open(session_nsm_file, 'r')
                server.sendGui('/ray/opening_nsm_session')
            except:
                try:
                    ray_file = open(session_ray_file, 'w')
                    xml = QDomDocument()
                    p = xml.createElement('RAYSESSION')
                    p.setAttribute('VERSION', VERSION)
                    
                    if server.is_nsm_locked:
                        name = basename(session_full_name).rpartition('.')[0]
                        p.setAttribute('name', name)
                    
                    xml.appendChild(p)
                    
                    ray_file.write(xml.toString())
                    ray_file.close()
                    
                    ray_file = open(session_ray_file, 'r')
                    
                    is_ray_file = True
                    
                except:
                    self.err_loading = ERR_CREATE_FAILED
                    self.loadError()
                    return
                
        print('moakdj', is_ray_file)
                
        GUIMSG(_translate('GUIMSG', "Opening session %s") % self.osc_args[0])
        
        self.removed_clients.clear()
        server.sendGui('/ray/gui/trash/clear')
        
        
        self.new_clients = []
        new_client_executables = []
        
        self.setPath(spath)
        
        if is_ray_file:
            xml = QDomDocument()
            xml.setContent(ray_file.read())

            content = xml.documentElement()
            
            if content.tagName() != "RAYSESSION":
                ray_file.close()
                self.err_loading = ERR_BAD_PROJECT
                self.loadError()
                return
            
            sess_name = content.attribute('name')
            if sess_name:
                self.name = sess_name
            
            node = content.firstChild()
            while not node.isNull():
                tag_name = node.toElement().tagName()
                if tag_name in ('Clients', 'RemovedClients'):
                    client_xml = node.toElement().firstChild()
                    while not client_xml.isNull():
                        client = Client()
                        cx = client_xml.toElement()
                        client.readXmlProperties(cx)
                        
                        if tag_name == 'Clients':
                            if client.auto_start:
                                new_client_executables.append(client.executable_path)
                            
                            self.new_clients.append(client)
                            
                        elif tag_name == 'RemovedClients':
                            self.removed_clients.append(client)
                            client.sendGuiClientProperties(removed=True)
                        
                        client_xml = client_xml.nextSibling()
                        
                node = node.nextSibling()
            
            ray_file.close()
        else:
            for line in file.read().split('\n'):
                elements = line.split(':')
                if len(elements) >= 3:
                    client = Client()
                    client.name            = elements[0]
                    client.executable_path = elements[1]
                    client.client_id       = elements[2]
                    client.prefix_mode     = PREFIX_MODE_CLIENT_NAME
                    self.new_clients.append(client)
                    new_client_executables.append(client.executable_path)
                    
            file.close()
        
        MESSAGE("Commanding unneeded and dumb clients to quit")
        
        for client in session.clients:
            if client.active and client.isCapableOf(':switch:') and client.executable_path in new_client_executables:
                new_client_executables.remove(client.executable_path)
            else:
                #client is not capable of switch, or is not wanted in the new session
                if client.isRunning():
                    self.expected_clients.append(client)
                client.quit()
        
        if self.expected_clients:
            server.setServerStatus(SERVER_STATUS_CLEAR)
        
        self.waitAndGoTo(20000, self.load_step1, WAIT_FOR_STOP)
    
    def load_step1(self):
        self.cleanExpected()
        self.purgeInactiveClients()
        
        for client in session.clients:
            client.pre_existing = True
            
        MESSAGE("Commanding smart clients to switch")
        
        has_switch = False
        
        new_client_id_list = []
        
        for new_client in self.new_clients:
            #/* in a duplicated session, clients will have the same
            #* IDs, so be sure to pick the right one to avoid race
            #* conditions in JACK name registration. */
            client = getClientByExecutableAndId(new_client.executable_path, new_client.client_id)
            if not client:
                client = getClientByExecutable(new_client.executable_path)
            
            if client and client.active and client.pre_existing and not client.isReplyPending():
                #since we already shutdown clients not capable of 'switch', we can assume that these are.
                client.switch(new_client)
                has_switch = True
            else:
                #* sleep a little bit because liblo derives its sequence
                #* of port numbers from the system time (second
                #* resolution) and if too many clients start at once they
                #* won't be able to find a free port. */
                self.addClient(new_client)
                if new_client.auto_start:
                    self.clients_to_launch.append(new_client)
                    if not new_client.executable_path in known_as_non_active:
                        self.expected_clients.append(new_client)
            
            new_client_id_list.append(new_client.client_id)
            
        server.sendGui("/ray/gui/session/name",  session.name, session.name)
        
        if has_switch:
            server.setServerStatus(SERVER_STATUS_SWITCH)
        else:
            server.setServerStatus(SERVER_STATUS_LAUNCH) 
        
        
        #* this part is a little tricky... the clients need some time to
        #* send their 'announce' messages before we can send them 'open'
        #* and know that a reply is pending and we should continue waiting
        #* until they finish.

        #* dumb clients will never send an 'announce message', so we need
        #* to give up waiting on them fairly soon. */
        
        self.timer_launch.start()
        
        self.reOrderClients(new_client_id_list)
        server.sendGui('/ray/gui/clients_reordered', *new_client_id_list)
        
        self.waitAndGoTo(5000, self.load_step2, WAIT_FOR_ANNOUNCE)
    
    def load_step2(self):
        for client in self.expected_clients:
            known_as_non_active.append(client.executable_path)
        settings.setValue('daemon/non_active_list', known_as_non_active)
        settings.sync()
        
        self.cleanExpected()
        
        server.setServerStatus(SERVER_STATUS_OPEN)
        
        for client in self.clients:
            if client.active and client.isReplyPending():
                self.expected_clients.append(client)
        self.waitAndGoTo(10000, self.load_step3, WAIT_FOR_REPLY)
        
    def load_step3(self):
        self.cleanExpected()
        self.tellAllClientsSessionIsLoaded()
        MESSAGE('Loaded')
        
        server.sendGui("/ray/gui/session/name",  session.name, session.name)
        server.send(self.osc_src_addr, "/reply", self.osc_path, "Loaded.")
        
        self.nextFunction()
    
    def loadDone(self):
        MESSAGE("Done")
        server.setServerStatus(SERVER_STATUS_READY)
    
    def loadError(self):
        MESSAGE("Failed")
        m = _translate('Load Error', "Unknown error")
        if self.err_loading == ERR_CREATE_FAILED:
            m = _translate('Load Error', "Could not create session file!")
        elif self.err_loading == ERR_SESSION_LOCKED:
            m = _translate('Load Error', "Session is locked by another process!")
        elif self.err_loading == ERR_NO_SUCH_FILE:
            m = _translate('Load Error', "The named session does not exist.")
        elif self.err_loading == ERR_BAD_PROJECT:
            m = _translate('Load Error', "Could not load session file.")
        
        server.send(self.osc_src_addr, "/error", self.osc_path, self.err_loading, m)
        
        if self.name:
            server.setServerStatus(SERVER_STATUS_READY)
        else:
            server.setServerStatus(SERVER_STATUS_OFF)
            
        self.process_order.clear()
    
    def duplicateDone(self):
        MESSAGE("Done")
        server.send(self.osc_src_addr, "/reply", self.osc_path, "Duplicated.")
        server.setServerStatus(SERVER_STATUS_READY)
        
    def exitNow(self):
        MESSAGE("Bye Bye...")
        server.setServerStatus(SERVER_STATUS_OFF)
        app.quit()
        
class SignaledSession(OperatingSession):
    def __init__(self):
        OperatingSession.__init__(self)
        signaler.server_new.connect(self.serverNewSession)
        signaler.server_new_from_tp.connect(self.serverNewSessionFromTemplate)
        signaler.server_open.connect(self.serverOpenSession)
        signaler.server_save.connect(self.serverSaveSession)
        signaler.server_rename.connect(self.serverRenameSession)
        signaler.server_duplicate.connect(self.serverDuplicateSession)
        signaler.server_save_session_template.connect(self.serverSaveSessionTemplate)
        signaler.server_close.connect(self.serverCloseSession)
        signaler.server_abort.connect(self.serverAbortSession)
        signaler.server_list_sessions.connect(self.serverListSessions)
        
        signaler.server_reorder_clients.connect(self.serverReorderClients)
        
        signaler.server_add.connect(self.serverAdd)
        signaler.server_add_proxy.connect(self.serverAddProxy)
        signaler.server_add_user_client_template.connect(self.serverAddUserClientTemplate)
        signaler.server_add_factory_client_template.connect(self.serverAddFactoryClientTemplate)
        
        signaler.server_announce.connect(self.serverAnnounce)
        signaler.server_reply.connect(self.serverReply)
        
        signaler.gui_client_stop.connect(self.guiClientStop)
        signaler.gui_client_kill.connect(self.guiClientKill)
        signaler.gui_client_remove.connect(self.guiClientRemove)
        signaler.gui_client_resume.connect(self.guiClientResume)
        signaler.gui_client_save.connect(self.guiClientSave)
        signaler.gui_client_save_template.connect(self.guiClientSaveTemplate)
        signaler.gui_client_label.connect(self.guiClientLabel)
        signaler.gui_client_icon.connect(self.guiClientIcon)
        signaler.gui_update_client_properties.connect(self.updateClientProperties)
        
        signaler.gui_trash_restore.connect(self.guiTrashRestore)
        signaler.gui_trash_remove_definitely.connect(self.guiTrashRemoveDefinitely)
        
        signaler.copy_aborted.connect(self.abortCopy)
        
    ############################# FUNCTIONS CONNECTED TO SIGNALS FROM OSC ###############################
    
    def serverNewSession(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, self.close, self.new, self.save, self.newDone]
        self.nextFunction()
        
    def serverNewSessionFromTemplate(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, self.prepareTemplate, self.load, self.loadDone]
        self.nextFunction()
        
    def serverOpenSession(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, self.load, self.loadDone]
        self.nextFunction()
    
    #def serverOpenSessionWithTemplate(self, path, args, src_addr):
        #if self.process_order:
            #return
        
        #self.rememberOscArgs(path, args, src_addr)
        
    
    def serverSaveSession(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, self.saveDone]
        self.nextFunction()
        
    def serverCloseSession(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, self.close, self.closeDone]
        self.nextFunction()
    
    def serverRenameSession(self, new_session_name):
        if self.process_order:
            return
        
        if not self.path:
            return
        
        if file_copier.isActive():
            return
        
        if new_session_name == self.name:
            return
        
        if not server.is_nsm_locked:
            for filename in os.listdir(dirname(self.path)):
                if filename == new_session_name:
                    return
        
        for client in self.clients:
            if client.isRunning():
                GUIMSG(_translate('GUIMSG', 'Stop all clients before rename session !'))
                return
        
        for client in self.clients + self.removed_clients:
            client.adjustFilesAfterCopy(new_session_name, TEMPLATE_RENAME)
        
        GUIMSG(_translate('GUIMSG', 'Session %s has been renamed to %s .') % (self.name, new_session_name))
        
        if not server.is_nsm_locked:
            try:
                spath = "%s/%s" % (dirname(self.path), new_session_name)
                subprocess.run(['mv', self.path, spath])
                self.path = spath
                GUIMSG(_translate('GUIMSG', 'Session directory is now: %s') % self.path)
            except:
                pass
        
        self.name = new_session_name
        
        server.sendGui('/ray/gui/session/name', self.name, self.name)
    
    def serverDuplicateSession(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, self.duplicate, self.load, self.duplicateDone]
        self.nextFunction()
        
    def serverSaveSessionTemplate(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, self.saveSessionTemplate]
        self.nextFunction()
        
    def serverAbortSession(self, path, args, src_addr):
        self.wait_for = WAIT_FOR_NONE
        self.timer.stop()
        
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.close, self.abortDone]
        
        if file_copier.isActive():
            file_copier.abort(self.nextFunction, [])
        else:
            self.nextFunction()
    
    def serverListSessions(self, path, args, src_addr):
        if not self.root:
            return
        
        for fds in os.walk(self.root):
            folder, folders, files = fds
            if folder == session.root:
                continue
            
            already_send = False
            
            for file in files:
                if file in ('raysession.xml', 'session.nsm'):
                    if not already_send:
                        basefolder = folder.replace(session.root + '/', '')
                        server.send(src_addr, "/reply", "/nsm/server/list", basefolder)
                        already_send = True
                    
        server.send(src_addr, path, ERR_OK, "Done.")
        
    def serverReorderClients(self, path, args):
        client_ids_list = args
        
        self.reOrderClients(client_ids_list)
        
    
    def serverAdd(self, path, args, src_addr):
        self.rememberOscArgs(path, args, src_addr)
        executable = args[0]
        
        client = Client()
        client.executable_path = executable
        client.name            = basename(executable)
        client.client_id       = self.generateClientId(executable)
        client.icon            = client.name.lower().replace('_', '-')
        
        self.addClient(client)
        client.start()
    
    def serverAddProxy(self, path, args, src_addr):
        self.rememberOscArgs(path, args, src_addr)
        executable = args[0]
        
        client = Client()
        client.executable_path = 'ray-proxy'
        
        client.tmp_arguments  = "--executable %s" % executable
        if debug:
            client.tmp_arguments += " --debug"
            
        client.name            = basename(executable)
        client.client_id       = self.generateClientId(client.name)
        client.icon            = client.name.lower().replace('_', '-')
        
        self.addClient(client)
        client.start()
    
    def addClientTemplate(self, template_name, factory=False):
        templates_root = client_template_local_root
        if factory:
            templates_root = client_template_factory_root
            
        xml_file = "%s/%s" % (templates_root, 'client_templates.xml')
        file = open(xml_file, 'r')
        xml = QDomDocument()
        xml.setContent(file.read())
        file.close()
        
        if xml.documentElement().tagName() != 'RAY-CLIENT-TEMPLATES':
            return
        
        node = xml.documentElement().firstChild()
        while not node.isNull():
            ct = node.toElement()
            if ct.tagName() != 'Client-Template':
                node = node.nextSibling()
                continue
            
            if ct.attribute('template-name') == template_name:
                client = Client()
                client.readXmlProperties(ct)
                
                needed_version = ct.attribute('needed-version')
                
                if needed_version.startswith('.') or needed_version.endswith('.') or not needed_version.replace('.', '').isdigit():
                    #needed-version not writed correctly, ignores it
                    needed_version = ''
                
                if factory and needed_version:
                    full_program_version = subprocess.check_output([client.executable_path, '--version']).decode()
                    previous_is_digit = False
                    program_version = ''
                    for character in full_program_version:
                        if character.isdigit():
                            program_version+=character
                            previous_is_digit = True
                        elif character == '.':
                            if previous_is_digit:
                                program_version+=character
                            previous_is_digit = False
                        else:
                            if program_version:
                                break
                            
                    if not program_version:
                        node = node.nextSibling()
                        continue
                    
                    
                    neededs = []
                    progvss = []
                    
                    for n in needed_version.split('.'):
                        neededs.append(int(n))
                        
                    for n in program_version.split('.'):
                        progvss.append(int(n))
                    
                    if neededs > progvss:
                        node = node.nextSibling()
                        continue
                
                full_name_files = []
                
                if not needed_version: 
                    #if there is a needed version, 
                    #then files are ignored because factory templates with version must be NSM compatible and dont need files (factory)
                    template_path = "%s/%s" % (templates_root, template_name)
                    
                    if os.path.isdir(template_path):
                        for file in os.listdir(template_path):
                            full_name_files.append("%s/%s" % (template_path, file))
                            
                
                self.addClient(client)
                
                if full_name_files:
                    client.setStatus(CLIENT_STATUS_PRECOPY)
                    file_copier.startClientCopy(client.client_id, full_name_files, self.path, self.addClientTemplate_step_1, self.addClientTemplateAborted, [client])
                else:
                    self.addClientTemplate_step_1(client)
                    
                break
            
            node = node.nextSibling()
    
    def addClientTemplate_step_1(self, client):
        client.adjustFilesAfterCopy(self.name, TEMPLATE_CLIENT_LOAD)
        
        if client.auto_start:
            client.start()
    
    def addClientTemplateAborted(self, client):
        self.removeClient(client)
    
    def serverAddUserClientTemplate(self, path, args, src_addr):
        self.rememberOscArgs(path, args, src_addr)
        template_name = args[0]
        
        self.addClientTemplate(template_name, False)
        
    def serverAddFactoryClientTemplate(self, path, args, src_addr):
        self.rememberOscArgs(path, args, src_addr)
        template_name = args[0]
        
        self.addClientTemplate(template_name, True)
     
    def serverAnnounce(self, path, args, src_addr):
        client_name, capabilities, executable_path, major, minor, pid = args
        
        if self.wait_for == WAIT_FOR_STOP:
            return
        
        #we can't be absolutely sure that the announcer is the good one
        #but if client announce a known PID, we can be sure of which client is announcing
        print('announce1', client_name, executable_path)
        for client in self.clients: 
            if client.pid == pid and not client.active and client.isRunning():
                client.serverAnnounce(path, args, src_addr, False)
                break
        else:
            print('announce2')
            n=0
            for client in self.clients:
                if (basename(client.executable_path) == basename(executable_path)
                    and not client.active
                    and client.pending_command == COMMAND_START):
                        n+=1
                        if n>1:
                            break
            
            if n==1:
                print('announc3')
                for client in self.clients:
                    if (basename(client.executable_path) == basename(executable_path)
                        and not client.active
                        and client.pending_command == COMMAND_START):
                            client.serverAnnounce(path, args, src_addr, False)
                            break
            else:
                print('announce4')
                for client in self.clients:
                    if not client.active and client.pending_command == COMMAND_START:
                        if isPIdChildOf(pid, client.pid):
                            client.serverAnnounce(path, args, src_addr, False)
                            break
                
                #Ray Session won't add clients that aren't launched by Ray Session itself. 
            
        if self.wait_for == WAIT_FOR_ANNOUNCE:
            self.endTimerIfLastExpected(client)
    
    def serverReply(self, path, args, src_addr):
        if self.wait_for == WAIT_FOR_STOP:
            return
        
        message = args[1]
        client = getClientByAddress(src_addr)
        if client:
            client.setReply(ERR_OK, message)
            #MESSAGE( "Client \"%s\" replied with: %s in %fms" % ( client.name, message, client.milliseconds_since_last_command() ))
            client.pending_command = COMMAND_NONE
            
            client.setStatus(CLIENT_STATUS_READY)
            
            if self.wait_for == WAIT_FOR_REPLY:
                self.endTimerIfLastExpected(client)
        else:
            MESSAGE("Reply from unknown client")
            
    def guiClientStop(self, path, args):
        for client in self.clients:
            if client.client_id == args[0]:
                client.stop()
                server.sendGui("/reply", "Client stopped." )
                break
        else:
            server.sendGui("/error", -10, "No such client." )
    
    def guiClientKill(self, path, args):
        for client in self.clients:
            if client.client_id == args[0]:
                client.kill()
                server.sendGui("/reply", "Client killed." )
                break
        else:
            server.sendGui("/error", -10, "No such client." )
    
    def guiClientRemove(self, path, args):
        client_id = args[0]
        
        for client in self.clients:
            if client.client_id == client_id:
                if client.isRunning():
                    return
                
                if file_copier.isActive(client_id):
                    file_copier.abort()
                    return
                
                self.removeClient(client)
                
                server.sendGui("/reply", "Client removed.")
                break
        else:
            server.sendGui("/error", -10, "No such client.")
            
    def guiClientResume(self, path, args):
        for client in self.clients:
            if client.client_id == args[0] and not client.isRunning():
                if file_copier.isActive(client.client_id):
                    server.sendGui("/error", -13, "Impossible, copy running")
                    return
                
                client.start()
                break
    
    def guiClientSave(self, path, args):
        for client in self.clients:
            if client.client_id == args[0] and client.active:
                if file_copier.isActive(client.client_id):
                    server.sendGui("/error", -13, "Impossible, copy running")
                    return
                client.save()
                break
    
    def guiClientSaveTemplate(self, path, args):
        if file_copier.isActive():
            server.sendGui("/error", -13, "Impossible, copy running")
            return
        
        for client in self.clients:
            if client.client_id == args[0]:
                client.saveAsTemplate(args[1])
                break
    
    def guiClientLabel(self, client_id, label):
        for client in self.clients:
            if client.client_id == client_id:
                client.setLabel(label)
                break
            
    def guiClientIcon(self, client_id, icon):
        for client in self.clients:
            if client.client_id == client_id:
                client.setIcon(icon)
                break
    
    def updateClientProperties(self, client_data):
        for client in self.clients:
            if client.client_id == client_data.client_id:
                client.updateClientProperties(client_data)
                break
    
    def guiTrashRestore(self, client_id):
        for client in self.removed_clients:
            if client.client_id == client_id:
                self.restoreClient(client)
                break
        else:
            server.sendGui("/error", -10, "No such client.")
            
    def guiTrashRemoveDefinitely(self, client_id):
        for client in self.removed_clients:
            if client.client_id == client_id:
                break
        else:
            return
        
        server.sendGui('/ray/gui/trash/remove', client_id)
        
        for file in client.getProjectFiles():
            try:
                subprocess.run(['rm', '-R', file])
            except:
                continue
            
        self.removed_clients.remove(client)
    
    def abortCopy(self):
        file_copier.abort()
    
    def terminate(self):
        if self.terminated_yet:
            return
        
        if file_copier.isActive():
            file_copier.abort()
        
        self.terminated_yet = True
        self.process_order = [self.close, self.exitNow]
        self.nextFunction()
        
def getClientById(client_id):
    for client in session.clients:
        if client.client_id == client_id:
            return client

def getClientByExecutableAndId(executable, client_id):
    for client in session.clients:
        if client.client_id == client_id and client.executable_path == executable:
            return client
        
def getClientByExecutable(executable):
    for client in session.clients:
        if client.executable_path == executable:
            return client
        
def getClientByNameAndId(name, client_id):
    for client in session.clients:
        if client.client_id == client_id and client.name == name:
            return client
        
def getClientByName(client_name):
    for client in session.clients:
        if client.name == client_name:
            return client

def getClientByAddress(addr):
    if not addr:
        return None
    
    for client in session.clients:
        if client.addr and client.addr.url == addr.url:
            return client

def getClientByPid(pid):
    for client in session.clients:
        if client.pid == pid:
            return client
    
def pathIsValid(path):
    return not bool('../' in path)
    
def generateClientId():
    client_id = 'n'
    for l in range(4):
        client_id += random.choice(string.ascii_uppercase)
    
    return client_id

##########################

class Signaler(QObject):
    server_announce    = pyqtSignal(str, list, object)
    server_reply       = pyqtSignal(str, list, object)
    server_rename      = pyqtSignal(str)
    server_duplicate   = pyqtSignal(str, list, object)
    server_save_session_template = pyqtSignal(str, list, object)
    server_abort       = pyqtSignal(str, list, object)
    server_close       = pyqtSignal(str, list, object)
    server_new         = pyqtSignal(str, list, object)
    server_new_from_tp = pyqtSignal(str, list, object)
    server_open        = pyqtSignal(str, list, object)
    server_save        = pyqtSignal(str, list, object)
    server_list_sessions = pyqtSignal(str, list, object)
    server_add       = pyqtSignal(str, list, object)
    server_add_proxy = pyqtSignal(str, list, object)
    server_add_user_client_template    = pyqtSignal(str, list, object)
    server_add_factory_client_template = pyqtSignal(str, list, object)
    server_reorder_clients = pyqtSignal(str, list)
    gui_client_stop    = pyqtSignal(str, list)
    gui_client_kill    = pyqtSignal(str, list)
    gui_client_remove  = pyqtSignal(str, list)
    gui_client_resume  = pyqtSignal(str, list)
    gui_client_save    = pyqtSignal(str, list)
    gui_client_save_template = pyqtSignal(str, list)
    gui_client_label = pyqtSignal(str, str)
    gui_client_icon  = pyqtSignal(str, str)
    gui_update_client_properties = pyqtSignal(object)
    copy_aborted = pyqtSignal()
    gui_trash_restore           = pyqtSignal(str)
    gui_trash_remove_definitely = pyqtSignal(str)
    

class OscServerThread(ServerThread):
    def __init__(self, osc_num=0):
        ServerThread.__init__(self, osc_num)
        self.gui_list = []
        self.server_status = SERVER_STATUS_OFF
        self.is_nsm_locked = False

    @make_method('/nsm/server/announce', 'sssiii')
    def nsmServerAnnounce(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "Sorry, but there's no session open for this application to join." )
            return
        
        signaler.server_announce.emit(path, args, src_addr)
        
    @make_method('/reply', 'ss')
    def reply(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        signaler.server_reply.emit(path, args, src_addr)
            
    @make_method('/error', 'sis')
    def error(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client = getClientByAddress(src_addr)
        if not client:
            WARNING("Error from unknown client")
            return
        
        err_code = args[1]
        message  = args[2]
        client.setReply(err_code, message)
        
        MESSAGE( "Client \"%s\" replied with error: %s (%i)" % ( client.name, message, err_code ))
        client.pending_command = COMMAND_NONE
        #client.status          = CLIENT_STATUS_ERROR
        
        #self.sendClientStatusToGui(client)
        client.setStatus(CLIENT_STATUS_ERROR)

    @make_method('/ray/server/set_nsm_locked', '')
    def rayServerSetNsmLocked(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        self.is_nsm_locked = True
    
    @make_method('/nsm/client/progress', 'f')
    def nsmClientProgress(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        client = getClientByAddress(src_addr)
        if not client:
            return
        
        client.progress = args[0]
        self.sendGui("/ray/gui/client/progress", client.client_id, client.progress)
    
    @make_method('/nsm/client/is_dirty', '')
    def nsmClientIs_dirty(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        MESSAGE("Client sends dirty")
        
        client = getClientByAddress(src_addr)
        if not client:
            return
        
        client.dirty = 1
        
        self.sendGui("/ray/gui/client/dirty", client.client_id, client.dirty)

    @make_method('/nsm/client/is_clean', '')
    def nsmClientIs_clean(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        MESSAGE("Client sends clean")
        
        client = getClientByAddress(src_addr)
        if not client:
            return
        
        client.dirty = 0
        
        self.sendGui("/ray/gui/client/dirty", client.client_id, client.dirty)
    
    @make_method('/nsm/client/message', 'is')
    def nsmClientMessage(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client = getClientByAddress(src_addr)
        if not client:
            return
        
        self.sendGui("/ray/gui/client/message", client.client_id, args[0], args[1])

    @make_method('/nsm/client/gui_is_hidden', '')
    def nsmClientGui_is_hidden(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        MESSAGE("Client sends gui hidden")
        
        client = getClientByAddress(src_addr)
        if not client:
            return
        
        client.gui_visible = False
        
        self.sendGui("/ray/gui/client/gui_visible", client.client_id, int(client.gui_visible))

    @make_method('/nsm/client/gui_is_shown', '')
    def nsmClientGui_is_shown(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        MESSAGE("Client sends gui shown")
        
        client = getClientByAddress(src_addr)
        if not client:
            return
        
        client.gui_visible = True
        
        self.sendGui("/ray/gui/client/gui_visible", client.client_id, int(client.gui_visible))

    @make_method('/nsm/client/label', 's')
    def nsmClientLabel(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client = getClientByAddress(src_addr)
        if not client:
            return
        
        label = args[0]
        signaler.gui_client_label.emit(client.client_id, label)
            
    @make_method('/ray/gui/gui_announce', 'i')
    def rayGuiGui_announce(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        self.announceGui(src_addr.url)

    @make_method('/ray/gui/gui_disannounce', '')
    def rayGuiGui_disannounce(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        for addr in self.gui_list:
            if addr.url == src_addr.url:
                break
        else:
            return
        
        self.gui_list.remove(addr)
        
    @make_method('/ray/gui/client/stop', 's')
    def rayGuiClientStop(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        signaler.gui_client_stop.emit(path, args)
    
    @make_method('/ray/gui/client/kill', 's')
    def rayGuiClientKill(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        signaler.gui_client_kill.emit(path, args)            
    
    @make_method('/ray/gui/client/remove', 's')
    def rayGuiClientRemove(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        signaler.gui_client_remove.emit(path, args)
    
    @make_method('/ray/gui/client/resume', 's')
    def rayGuiClientResume(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        signaler.gui_client_resume.emit(path, args)
                
    @make_method('/ray/gui/client/save', 's')
    def rayGuiClientSave(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        signaler.gui_client_save.emit(path, args)

    @make_method('/ray/gui/client/save_as_template', 'ss')
    def rayGuiClientSaveAsTemplate(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        signaler.gui_client_save_template.emit(path, args)
    
    @make_method('/ray/gui/client/show_optional_gui', 's')
    def nsmGuiClientShow_optional_gui(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client = getClientById(args[0])
        
        if client and client.active:
            self.send(client.addr, "/nsm/client/show_optional_gui")

    @make_method('/ray/gui/client/hide_optional_gui', 's')
    def nsmGuiClientHide_optional_gui(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client = getClientById(args[0])
        
        if client and client.active:
            self.send(client.addr, "/nsm/client/hide_optional_gui")

    @make_method('/ray/gui/client/update_properties', 'ssssissssi')
    def rayGuiClientUpdateProperties(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client_data = ClientData(*args)
        signaler.gui_update_client_properties.emit(client_data)

    @make_method('/osc/ping', '')
    def oscPing(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        self.send(src_addr, "/reply", path)

    @make_method('/nsm/server/broadcast', None)
    def nsmServerBroadcast(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not args:
            return
        
        #don't allow clients to broadcast NSM commands
        if args[0].startswith('/nsm/') or args[0].startswith('/ray'):
            return
        
        for client in session.clients:
            if not client.addr:
                continue
            
            if client.addr.url != src_addr.url:
                self.send(client.addr, Message(*args))
                
            for gui_addr in self.gui_list:
                #also relay to attached GUI so that the broadcast can be
                #propagated to another NSMD instance
                if gui_addr.url != src_addr.url:
                    self.send(gui_addr, Message(*args))
        
    @make_method('/ray/server/rename', 's')
    def rayServerRename(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        new_session_name = args[0]
        
        if '/' in new_session_name:
            self.send(src_addr, "/error", path, ERR_CREATE_FAILED, "Invalid session name.")
            return
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to rename.")
            return
        
        signaler.server_rename.emit(new_session_name)
      
      
    @make_method('/nsm/server/duplicate', 's')
    def nsmServerDuplicate(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.is_nsm_locked:
            return
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to duplicate.")
            return
        
        if not pathIsValid(args[0]):
            self.send(src_addr, "/error", path, ERR_CREATE_FAILED, "Invalid session name.")
            return
        
        signaler.server_duplicate.emit(path, args, src_addr)
        
    @make_method('/ray/server/save_session_template', 's')
    def nsmServerSaveSessionTemplate(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to save as template.")
            return
        
        if not pathIsValid(args[0]):
            self.send(src_addr, "/error", path, ERR_CREATE_FAILED, "Invalid session name.")
            return
        
        signaler.server_save_session_template.emit(path, args, src_addr)
        
    
    @make_method('/nsm/server/abort', '')
    def nsmServerAbort(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.server_status == SERVER_STATUS_PRECOPY:
            signaler.copy_aborted.emit()
            return
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to abort." )
            return
        
        signaler.server_abort.emit(path, args, src_addr)

    @make_method('/nsm/server/list', '')
    def nsmServerList(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        signaler.server_list_sessions.emit(path, args, src_addr)
        
    @make_method('/nsm/server/add', 's')
    def nsmServerAdd(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "Cannot add to session because no session is loaded." )
            return
        
        signaler.server_add.emit(path, args, src_addr)
    
    @make_method('/ray/server/add_proxy', 's')
    def rayServerAddProxy(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "Cannot add to session because no session is loaded." )
            return
        
        signaler.server_add_proxy.emit(path, args, src_addr)

    

    @make_method('/ray/server/add_user_client_template', 's')
    def rayServerAddUserClientTemplate(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "Cannot add to session because no session is loaded." )
            return
        
        signaler.server_add_user_client_template.emit(path, args, src_addr)

    @make_method('/ray/server/add_factory_client_template', 's')
    def rayServerAddFactoryClientTemplate(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "Cannot add to session because no session is loaded." )
            return
        
        signaler.server_add_factory_client_template.emit(path, args, src_addr)

    
    @make_method('/nsm/server/new', 's')
    def nsmServerNew(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.is_nsm_locked:
            return
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not pathIsValid(args[0]):
            self.send(src_addr, "/error", path, ERR_CREATE_FAILED, "Invalid session name.")
            return
        
        signaler.server_new.emit(path, args, src_addr)
    
    @make_method('/ray/server/new_from_template', 'ss')
    def rayServerNewFromTemplate(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.is_nsm_locked:
            return
        
        if self.isOperationPending(src_addr, path):
            return
        
        signaler.server_new_from_tp.emit(path, args, src_addr)
    
    @make_method('/nsm/server/save', '')
    def nsmServerSave(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to save.")
            return 0
        
        signaler.server_save.emit(path, args, src_addr)

    @make_method('/nsm/server/open', 's')
    def nsmServerOpen(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        signaler.server_open.emit(path, args, src_addr)
          
    @make_method('/nsm/server/open', 'ss')
    def nsmServerOpenWithTemplate(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        signaler.server_new_from_tp.emit(path, args, src_addr)
          
    @make_method('/nsm/server/close', '')
    def nsmServerClose(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not  session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to close.")
            return 0
        
        signaler.server_close.emit(path, args, src_addr)
        
    @make_method('/nsm/server/quit', '')
    def nsmServerQuit(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        sys.exit(0)
    
    @make_method('/ray/server/abort_copy', '')
    def rayServerAbortCopy(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        signaler.copy_aborted.emit()
        
    ###Additional Ray features###
    
    @make_method('/ray/server/openfolder', '')
    def rayServerOpenFolder(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        if  session.path:
            subprocess.Popen(['xdg-open',  session.path])
        
    @make_method('/ray/server/reorder_clients', None)
    def rayServerReorderClients(self, path, args):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not areTheyAllString(args):
            return
        
        signaler.server_reorder_clients.emit(path, args)
        
    @make_method('/ray/server/change_root', 's')
    def rayServerChangeRoot(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if session.path:
            self.send(src_addr, '/reply', "Can't change session_root while a session is running")
            return
        
        session.setRoot(args[0])
    
    @make_method('/ray/server/list_path', '')
    def rayServerListPath(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        exec_list = []
        tmp_exec_list = []
        
        pathlist = os.getenv('PATH').split(':')
        for path in pathlist:
            if os.path.isdir(path):
                listexe = os.listdir(path)
                for exe in listexe:
                    fullexe = path + '/' + exe
                    if os.path.isfile(fullexe) and os.access(fullexe, os.X_OK) and not exe in exec_list:
                        exec_list.append(exe)
                        tmp_exec_list.append(exe)
                        if len(tmp_exec_list) == 100:
                            self.send(src_addr, '/reply_path', *tmp_exec_list)
                            tmp_exec_list.clear()
        
        if tmp_exec_list:
            self.send(src_addr, '/reply_path', *tmp_exec_list)
            
    @make_method('/ray/server/list_session_templates', '')
    def rayServerListSessionTemplates(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not os.path.isdir(session_template_root):
            return
        
        template_list = []
        
        all_files = os.listdir(session_template_root)
        for file in all_files:
            if os.path.isdir("%s/%s" % (session_template_root, file)):
                template_list.append(file)
                
                if len(template_list) == 100:
                    self.send(src_addr, '/reply_session_templates', *template_list)
                    template_list.clear()
                    
        if template_list:
            self.send(src_addr, '/reply_session_templates', *template_list) 
    
    
    @make_method('/ray/server/list_user_client_templates', '')
    def rayServerListUserClientTemplates(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        self.listClientTemplates(src_addr, False)
    
    @make_method('/ray/server/list_factory_client_templates', '')
    def rayServerListFactoryClientTemplates(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        self.listClientTemplates(src_addr, True)
    
    @make_method('/ray/gui/trash/restore', 's')
    def rayGuiTrashRestore(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "Cannot add to session because no session is loaded." )
            return
        
        client_id = args[0]
        
        signaler.gui_trash_restore.emit(client_id)
        
    @make_method('/ray/gui/trash/remove_definitely', 's')
    def rayGuiTrashRemoveDefinitely(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-daemon_receives %s, %s' % (path, str(args)))
        
        client_id = args[0]
        
        signaler.gui_trash_remove_definitely.emit(client_id)
    
    def isOperationPending(self, src_addr, path):
        if file_copier.isActive():
            print('file copier is active, should send error')
            self.send(src_addr, "/error", path, ERR_COPY_RUNNING, "ray-daemon is copying files. Wait copy finish or abort copy, and restart operation !")
            return True
        
        if session.process_order:
            self.send(src_addr, "/error", path, ERR_OPERATION_PENDING, "An operation pending.")
            return True
        
        return False
        
    def sendGui(self, *args):
        for gui_addr in self.gui_list:
            self.send(gui_addr, *args)
    
    def sendClientStatusToGui(self, client):
        self.sendGui("/ray/gui/client/status", client.client_id, client.status)
            
    def setServerStatus(self, server_status):
        self.server_status = server_status
        self.sendGui('/ray/server_status', server_status) 
    
    def informCopytoGui(self, copy_state):
        self.sendGui('/ray/gui/server/copying', int(copy_state))
    
    def listClientTemplates(self, src_addr, factory=False):
        template_list = []
        tmp_template_list = []
        
        templates_root    = client_template_local_root
        response_osc_path = '/reply_user_client_templates'
        
        if factory:
            templates_root    = client_template_factory_root
            response_osc_path = '/reply_factory_client_templates'
        
        
        templates_file = "%s/%s" % (templates_root, 'client_templates.xml')
        
        if not os.path.isfile(templates_file):
            return
        
        if not os.access(templates_file, os.R_OK):
            return
        
        file = open(templates_file)
        xml = QDomDocument()
        xml.setContent(file.read())
        file.close()
        
        content = xml.documentElement()
        
        if content.tagName() != "RAY-CLIENT-TEMPLATES":
            return
        
        node = content.firstChild()
        while not node.isNull():
            ct = node.toElement()
            tag_name = ct.tagName()
            if tag_name != 'Client-Template':
                node = node.nextSibling()
                continue
            
            template_name = ct.attribute('template-name')
            
            if not template_name or template_name in template_list:
                node = node.nextSibling()
                continue
            
            executable = ct.attribute('executable') 
            
            if not executable:
                node = node.nextSibling()
                continue
            
            try_exec_line = ct.attribute('try-exec')
            
            try_exec_list = []
            if try_exec_line:
                try_exec_list = ct.attribute('try-exec').split(';')
                
            try_exec_list.append(executable)
            try_exec_ok = True
            
            for try_exec in try_exec_list:
                path = shutil.which(try_exec)
                if not path:
                    try_exec_ok = False
                    break
            
            if not try_exec_ok:
                node = node.nextSibling()
                continue
            
            template_list.append("%s/%s" % (template_name, ct.attribute('icon') ))
            tmp_template_list.append("%s/%s" % (template_name, ct.attribute('icon') ))
            
            if len(tmp_template_list) == 100:
                self.send(src_addr, response_osc_path, *tmp_template_list)
                template_list.clear()
        
            node = node.nextSibling()
        
        if tmp_template_list:
            self.send(src_addr, response_osc_path, *tmp_template_list)
    
    def announceGui(self, url):
        gui_addr = Address(url)
        
        #if is_reply:
            #self.send(gui_addr, "/ray/gui/gui_announce", "hi" )
        #else:
        self.send(gui_addr, "/ray/gui/server_announce", self.server_status, int(self.is_nsm_locked), session.root)
        
        self.send(gui_addr, "/ray/server_status", self.server_status)
        self.send(gui_addr, "/ray/gui/session/name",  session.name,  session.path)
        
        for client in session.clients:
            self.send(  gui_addr, 
                        '/ray/gui/client/new',
                        client.client_id, 
                        client.executable_path,
                        client.arguments,
                        client.name, 
                        client.prefix_mode, 
                        client.project_path,
                        client.label,
                        client.icon,
                        client.capabilities,
                        int(client.check_last_save))
            
            self.send(gui_addr, "/ray/gui/client/status", client.client_id,  client.status)
        
        self.gui_list.append(gui_addr)
        MESSAGE("Registered with GUI")
        
    
if __name__ == '__main__':
    #Add RaySession/src to $PATH to can use ray-proxy and maybe future executables after make, whitout install
    os.environ['PATH']="%s:%s" % (os.path.realpath(dirname(sys.argv[0])), os.environ['PATH'])
    
    
    parser = argparse.ArgumentParser()
    parser.add_argument('--session-root', '-r', help='set root folder for sessions')
    parser.add_argument('--osc-port', type=int, default=16187, help='select OSC port for the daemon')
    parser.add_argument('--gui-url', type=getLibloAddress, help=argparse.SUPPRESS)
    parser.add_argument('--findfreeport', action='store_true', help='find another port if port is not free')
    parser.add_argument('--debug','-d',  action='store_true', help='see all OSC messages')
    parser.add_argument('--debug-only', '-do', action='store_true', help='debug without client messages')
    parser.add_argument('-v', '--version', action='version', version=VERSION)
    parsed_args = parser.parse_args()
    
    debug        = parsed_args.debug
    debug_only   = parsed_args.debug_only
    if debug_only:
        debug = True
    
    session_root = parsed_args.session_root
    osc_num      = parsed_args.osc_port
    gui_address  = parsed_args.gui_url
    findfreeport = parsed_args.findfreeport
    
    
    signal.signal(signal.SIGINT,  signalHandler)
    signal.signal(signal.SIGTERM, signalHandler)
    
    app = QCoreApplication(sys.argv)
    app.setApplicationName("RaySession")
    #app.setApplicationVersion(VERSION)
    app.setOrganizationName("RaySession")
    settings = QSettings()
    
    app_config_path = "%s/%s" % (QStandardPaths.writableLocation(QStandardPaths.ConfigLocation), app.organizationName())
    session_template_root = "%s/%s" % (app_config_path, 'session_templates')
    session_template_factory_root = "%s/session_templates" % dirname(dirname(sys.argv[0]))
    client_template_local_root = "%s/%s" % (app_config_path, 'client_templates')
    client_template_factory_root = "%s/client_templates" % dirname(dirname(sys.argv[0]))
    
    ### Translation process
    locale = QLocale.system().name()
    appTranslator = QTranslator()
    if appTranslator.load("%s/locale/raysession_%s" % (dirname(dirname(sys.argv[0])), locale)):
        app.installTranslator(appTranslator)
    _translate = app.translate
    init_translation(_translate)
    
    
    if not session_root:
        session_root = "%s/%s" % (os.getenv('HOME'), _translate('daemon', 'Ray Network Sessions'))
    
    #make session_root folder if needed
    if not os.path.isdir(session_root):
        if os.path.exists(session_root):
            sys.stderr.write("%s exists and is not a dir, please choose another path !\n" % session_root)
            sys.exit(1)
        
        try:
            os.makedirs(session_root)
        except:
            sys.stderr.write("impossible to make dir %s , aborted !\n" % session_root)
            sys.exit(1)
            
    #this method works differently with pyqt or qt versions (probably) , so we need to ensure ray-daemon won't crash because of that.
    known_as_non_active = []
    
    try:
        known_as_non_active = settings.value('daemon/non_active_list', [], type=list)
    except:
        try:
            known_as_non_active = settings.value('daemon/non_active_list', [])
        except:
            known_as_non_active = []
    
    timer = QTimer()
    timer.setInterval(200)
    timer.timeout.connect(lambda: None)
    timer.start()
    
    signaler    = Signaler()
    file_copier = FileCopier()
    session     = SignaledSession()
    
    session.setRoot(session_root)
    
    if findfreeport:
        server = OscServerThread(getFreeOscPort(osc_num))
    else:
        if isOscPortFree(osc_num):
            server = OscServerThread(osc_num)
        else:
            sys.stderr.write(_translate('daemon', 'port %i is not free, try another one\n') % osc_num)
            sys.exit()
        
        
    server.start()
    
    if gui_address:
        server.announceGui(gui_address.url)
        
    MESSAGE(server.url)
    
    app.exec()
    
    settings.setValue('daemon/non_active_list', known_as_non_active)
    settings.sync()
    
    server.stop()
    del server
    del session
    del app
    
