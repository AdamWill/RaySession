#!/usr/bin/python3

import os, sys, shutil, string, random, time, subprocess, signal, unicodedata
from liblo import ServerThread, Address, make_method, Message
from PyQt5.QtCore import QCoreApplication, pyqtSignal, qDebug, QObject, QTimer, QProcess, QSettings, QStandardPaths
from PyQt5.QtXml import QDomDocument

from shared import *



#ray-deamon doesn't really cares if jack is running or not
#but if jack is running, it just ask all jack ports between many clients launchs or stops
#It 'maybe' prevent some jack bugs
try:
    import dbus
    bus = dbus.SessionBus()
    jack_bus = bus.get_object('org.jackaudio.service', '/org/jackaudio/Controller')
except:
    jack_bus = None

NSM_API_VERSION_MAJOR = 1
NSM_API_VERSION_MINOR = 0

ERR_OK                =  0
ERR_GENERAL_ERROR     = -1
ERR_INCOMPATIBLE_API  = -2
ERR_BLACKLISTED       = -3
ERR_LAUNCH_FAILED     = -4
ERR_NO_SUCH_FILE      = -5
ERR_NO_SESSION_OPEN   = -6
ERR_UNSAVED_CHANGES   = -7
ERR_NOT_NOW           = -8
ERR_BAD_PROJECT       = -9
ERR_CREATE_FAILED     = -10
ERR_SESSION_LOCKED    = -11
ERR_OPERATION_PENDING = -12

COMMAND_NONE      = 0
COMMAND_QUIT      = 1
COMMAND_KILL      = 2
COMMAND_SAVE      = 3
COMMAND_OPEN      = 4
COMMAND_START     = 5
COMMAND_CLOSE     = 6
COMMAND_DUPLICATE = 7
COMMAND_NEW       = 8

WAIT_FOR_NONE     = 0
WAIT_FOR_STOP     = 1
WAIT_FOR_ANNOUNCE = 2
WAIT_FOR_REPLY    = 3

TEMPLATE_NONE = 0
TEMPLATE_SESSION_SAVE = 1
TEMPLATE_SESSION_LOAD = 2
TEMPLATE_CLIENT_SAVE  = 3
TEMPLATE_CLIENT_LOAD  = 4

debug = False
last_client_message = None
known_as_non_active = []

def signalHandler(sig, frame):
    if sig in (signal.SIGINT, signal.SIGTERM):
        session.terminate()
        
def remove_accents(input_str):
    nfkd_form = unicodedata.normalize('NFKD', input_str)
    return u"".join([c for c in nfkd_form if not unicodedata.combining(c)]).lower()    

def ifDebug(string):
    if debug:
        #qDebug(remove_accents(string))
        print(string, file=sys.stderr)

def MESSAGE(string):
    global last_client_message
    last_client_message = 'deamon'
    print('[' + '\033[90m' + 'ray-deamon' + '\033[0m' + '] ' + '\033[92m' + string + '\033[0m', file=sys.stderr)

def CLIENT_MESSAGE(string, client_name, client_id):
    global last_client_message
    client_str = client_name + '.' + client_id
    if last_client_message == client_str:
        print(string, file=sys.stderr)
    else:
        print('[' + '\033[90m' + client_name + '-' + client_id + '\033[0m' + ']\n' + string, file=sys.stderr)
    last_client_message = client_str

def WARNING(string):
    print('[' + '\033[90m' + 'ray-deamon' + '\033[0m' + '] ' + '\033[93m' + string + '\033[0m', file=sys.stderr)
    
def GUIMSG(message):
    server.sendGui('/ray/gui/server/message', message)

def waitForJack():
    if jack_bus and jack_bus.IsStarted():
        all_ports = jack_bus.GetAllPorts()
        del all_ports
        
def quitRay(sig, frame):
    for client in session.clients:
        if client.isRunning():
            MESSAGE(_translate('GUIMSG', 'Good Bye ! Clients are still running.'))
            break
    else:
        MESSAGE(_translate('GUIMSG', 'Good Bye !'))
    app.quit()

class Client(QObject):
    #can be directly changed by OSC thread
    gui_visible     = True
    _reply_errcode  = 0
    _reply_message  = None
    progress        = 0
    
    #have to be modified by main thread for security
    addr            = None
    pid             = 0
    pending_command = COMMAND_NONE
    active          = False
    client_id       = ''
    capabilities    = None
    
    status          = CLIENT_STATUS_STOPPED
    name            = ''
    executable_path = ''
    arguments_line  = ''
    label           = ''
    icon            = ''
    pre_existing    = False
    project_path    = ""
    prefix_mode     = PREFIX_MODE_SESSION_NAME
    auto_start      = True
    sent_to_gui     = False
    
    def __init__(self):
        QObject.__init__(self)
        #signaler.server_announce.connect(self.serverAnnounce)
        
        self.process = QProcess()
        self.process.started.connect(self.processStarted)
        self.process.errorOccurred.connect(self.errorInProcess)
        self.process.finished.connect(self.processFinished)
        self.process.readyReadStandardError.connect(self.standardError)
        self.process.readyReadStandardOutput.connect(self.standardOutput)
        
        #if client is'n't stopped 2secs after stop, another stop becames a kill!
        self.stopped_since_long = False
        self.stopped_timer = QTimer()
        self.stopped_timer.setSingleShot(True)
        self.stopped_timer.setInterval(2000) #2sec
        self.stopped_timer.timeout.connect(self.stoppedSinceLong)
    
    
    def setReply(self, errcode, message):
        self._reply_message = message
        self._reply_errcode = errcode
    
    def setLabel(self, label):
        self.label = label
        self.sendGuiClientProperties()
        
    def setIcon(self, icon_name):
        self.icon = icon_name
        self.sendGuiClientProperties()
        
    def hasError(self):
        if self._reply_errcode:
            return self._reply_errcode
        
    def errorCode(self):
        return self._reply_errcode
    
    def getMessage(self):
        return self._reply_message
    
    def isReplyPending(self):
        if self.pending_command:
            return self.pending_command
        
    def isDumbClient(self):
        return bool(self.capabilities == None)
    
    def isCapableOf(self, capability):
        if self.capabilities == None:
            return False
        return bool(capability in self.capabilities)
    
    def getJackClientName(self):
        jack_client_name = self.name
        
        numid = ''
        if '_' in self.client_id:
            numid = self.client_id.rpartition('_')[2]
        if numid.isdigit():
            jack_client_name += '_'
            jack_client_name += numid
        
        return jack_client_name
    
    def getProjectPath(self):
        if self.prefix_mode == PREFIX_MODE_SESSION_NAME:
            return "%s/%s.%s" % (session.path, session.name, self.client_id)
        elif self.prefix_mode == PREFIX_MODE_CLIENT_NAME:
            return "%s/%s.%s" % (session.path, self.name, self.client_id)
        else:
            return "%s/%s" % (session.path, self.project_path)
    
    def start(self):
        GUIMSG(_translate("GUIMSG", "Launching %s") % self.executable_path)
        os.environ['NSM_URL'] = server.url
        
        self.pending_command = COMMAND_START
        
        if self.arguments_line:
            arguments = shlex.split(self.arguments_line)
            self.process.start(self.executable_path, arguments)
        else:
            self.process.start(self.executable_path)
     
    def terminate(self):
        if self.isRunning():
            self.process.terminate()
        
    def kill(self):
        if self.isRunning():
            self.process.kill()
            
    def isRunning(self):
        return bool(self.process.state() == 2)
    
    def standardError(self):
        standard_error = self.process.readAllStandardError().data().decode('utf-8')
        CLIENT_MESSAGE(standard_error, self.name, self.client_id)
        
    def standardOutput(self):
        standard_output = self.process.readAllStandardOutput().data().decode('utf-8')
        CLIENT_MESSAGE(standard_output, self.name, self.client_id)
    
    def processStarted(self):
        self.stopped_since_long = False
        self.pid    = self.process.pid()
        self.status = CLIENT_STATUS_LAUNCH
        #self.pending_command = COMMAND_NONE
        
        #MESSAGE("Process has pid: %i" % self.pid)
        server.sendClientStatusToGui(self)
        
        if session.osc_src_addr:
            server.send(session.osc_src_addr, "/reply", session.osc_path, ERR_OK, "Launched." )
        
    
    def processFinished(self, exit_code, exit_status):
        self.stopped_timer.stop()
        
        if self.pending_command in (COMMAND_KILL, COMMAND_QUIT):
            GUIMSG(_translate('GUIMSG', "Client %s terminated because we told it to.") % self.name)
        else:
            GUIMSG(_translate('GUIMSG', "Client %s died unexpectedly.") % self.name)
        
        if session.wait_for:
            session.endTimerIfLastExpected(self)
        
        if self.pending_command == COMMAND_QUIT:
            server.sendGui("/ray/gui/client/status", self.client_id, CLIENT_STATUS_REMOVED)
            session.removeClient(self)
            return
        else:
            self.status = CLIENT_STATUS_STOPPED
            server.sendClientStatusToGui(self)
                
        self.pending_command = COMMAND_NONE
        self.active          = False
        self.pid             = 0
        
    def errorInProcess(self, error):
        if error == QProcess.FailedToStart:
            GUIMSG(_translate('GUIMSG', "Failed to start %s") % self.name)
            self.active     = False
            self.pid        = 0
            self.status     = CLIENT_STATUS_STOPPED
            server.sendClientStatusToGui(self)
            self.pending_command = COMMAND_NONE
            
            #if session.osc_src_addr:
                ##Finally, not sure that it's a good idea to display error dialog in this case.
                #server.send(session.osc_src_addr, "/error", session.osc_path, ERR_LAUNCH_FAILED, "Failed to launch process!")
            
            if session.wait_for:
                session.endTimerIfLastExpected(self)
    
    def stoppedSinceLong(self):
        self.stopped_since_long = True
        server.sendGui('/ray/gui/client/still_running', self.client_id)
    
    def tellClientSessionIsLoaded(self):
        if self.active and not self.isDumbClient():
            MESSAGE("Telling client %s that session is loaded." % self.name)
            server.send(self.addr, "/nsm/client/session_is_loaded")
    
    def save(self):
        if self.active:
            MESSAGE("Telling %s to save" % self.name)
            server.send(self.addr, "/nsm/client/save")
            
            self.pending_command = COMMAND_SAVE
            self.status          = CLIENT_STATUS_SAVE
            server.sendClientStatusToGui(self)
        
        elif self.isDumbClient() and self.isRunning():
            self.status = CLIENT_STATUS_NOOP
            server.sendClientStatusToGui(self)
            
    def stop(self):
        GUIMSG(_translate('GUIMSG', "Stopping client %s") % self.name)
        if self.isRunning():
            self.pending_command = COMMAND_KILL
            self.status = CLIENT_STATUS_QUIT
            server.sendClientStatusToGui(self)
            self.process.terminate()
            
            if not self.stopped_timer.isActive():
                self.stopped_timer.start()
    
    def quit(self):
        MESSAGE("Commanding %s to quit" % self.name)
        if self.active:
            self.status = CLIENT_STATUS_QUIT
            self.pending_command = COMMAND_QUIT
            self.terminate()
            server.sendClientStatusToGui(self)
        
        elif self.isDumbClient():
            if self.isRunning():
                self.status = CLIENT_STATUS_QUIT
                self.pending_command = COMMAND_QUIT
                self.terminate()
                server.sendClientStatusToGui(self)
            else:
                server.sendGui("/ray/gui/client/status", self.client_id, CLIENT_STATUS_REMOVED)
    
    def switch(self, new_client):
        old_client_id     = self.client_id
        self.client_id    = new_client.client_id
        self.name         = new_client.name
        self.prefix_mode  = new_client.prefix_mode
        self.project_path = new_client.project_path
        self.label        = new_client.label
        self.icon         = new_client.icon
        
        jack_client_name      = self.getJackClientName()
        client_project_path = self.getProjectPath()
        
        MESSAGE("Commanding %s to switch \"%s\"" % (self.name, client_project_path))
        
        server.send(self.addr, "/nsm/client/open", client_project_path,  session.name, jack_client_name)
        
        self.status          = CLIENT_STATUS_SWITCH
        self.pending_command = COMMAND_OPEN
        
        server.sendClientStatusToGui(self)
            
        server.sendGui("/ray/gui/client/switch", old_client_id, self.client_id)
    
    def sendGuiClientProperties(self):
        ad = '/ray/gui/client/update' if self.sent_to_gui else '/ray/gui/client/new'
            
        server.sendGui(ad,
                        self.client_id, 
                        self.executable_path, 
                        self.name, 
                        self.prefix_mode, 
                        self.project_path,
                        self.label,
                        self.icon,
                        self.capabilities)
        
        self.sent_to_gui = True
    
    def prettyClientId(self):
        wanted = self.client_id
        
        if self.executable_path == 'ray-proxy':
            proxy_file = "%s/ray-proxy.xml" % self.getProjectPath()
            
            if os.path.exists(proxy_file):
                file = open(proxy_file, 'r')
                xml = QDomDocument()
                xml.setContent(file.read())
                file.close()
                
                content = xml.documentElement()
                if content.tagName() == 'RAY-PROXY':
                    executable = content.attribute('executable')
                    if executable:
                        wanted = executable
            
            
        if '_' in wanted:
            begin, udsc, end = wanted.rpartition('_')
            
            if not end:
                return wanted
            
            if not end.isdigit():
                return wanted
            
            return begin
        
        return wanted
    
    def saveAsTemplate(self, template_name):
        #copy files
        if self.prefix_mode != PREFIX_MODE_UNDEF:
            client_files = []
            
            prefix = session.name
            if self.prefix_mode == PREFIX_MODE_CLIENT_NAME:
                prefix = self.name
                
            for filename in os.listdir(session.path):
                if ( (filename == "%s.%s" % (prefix, self.client_id)) or 
                     (filename.startswith("%s.%s." % (prefix, self.client_id))) ):
                    client_files.append(filename)
                        
            template_dir = "%s/%s" % (client_template_local_root, template_name)
            if os.path.exists(template_dir):
                if os.access(template_dir, os.W_OK):
                    shutil.rmtree(template_dir)
                else:
                    #TODO send error
                    return
                
            os.makedirs(template_dir)
            
            for filename in client_files:
                subprocess.run(['cp', '-R', "%s/%s" % (session.path, filename), template_dir])
                
            self.adjustFilesAfterCopy(template_name, TEMPLATE_CLIENT_SAVE)
            
        xml_file = "%s/%s" % (client_template_local_root, 'client_templates.xml')
        
        #security check
        if os.path.exists(xml_file):
            if not os.access(xml_file, os.W_OK):
                return
            
            if os.path.isdir(xml_file):
                #should not be a dir, remove it !
                subprocess.run('rm', '-R', xml_file)
        
        
        if not os.path.isdir(client_template_local_root):
            os.makedirs(client_template_local_root)
        
        print(xml_file)
        #create client_templates.xml if not exists
        if not os.path.isfile(xml_file):
            file = open(xml_file, 'w')
            
            xml = QDomDocument()
            rct = xml.createElement('RAY-CLIENT-TEMPLATES')
            xml.appendChild(rct)
            file.write(xml.toString())
            file.close()
            del xml
            
        file = open(xml_file, 'r')
        xml = QDomDocument()
        xml.setContent(file.read())
        file.close()
        content = xml.documentElement()
                
        if not content.tagName() == 'RAY-CLIENT-TEMPLATES':
            return
        
        
        #remove existing template if it has the same name as the new one
        node = content.firstChild()
        while not node.isNull():
            if node.toElement().tagName() != 'Client-Template':
                node = node.nextSibling()
                continue
            
            print(node.toElement().attribute('template-name'))
            if node.toElement().attribute('template-name') == template_name:
                content.removeChild(node)
            
            node = node.nextSibling()
        
        #create template
        rct = xml.createElement('Client-Template')
        
        rct.setAttribute('template-name', template_name)
        rct.setAttribute('executable', self.executable_path)
        rct.setAttribute('client_id', self.prettyClientId())
        
        if self.name:
            rct.setAttribute('name', self.name)
        
        if self.prefix_mode !=  PREFIX_MODE_SESSION_NAME:
            rct.setAttribute('prefix_mode', self.prefix_mode)
            if self.prefix_mode == PREFIX_MODE_UNDEF:
                rct.setAttribute('project_path', self.project_path)
        
        if self.icon:
            rct.setAttribute('icon', self.icon)
        
        if self.label:
            rct.setAttribute('label', self.label)
            
        if not self.isRunning():
            rct.setAttribute('launched', False)
        
        
        content.appendChild(rct)
        
        file = open(xml_file, 'w')
        file.write(xml.toString())
        file.close()

    
    def adjustFilesAfterCopy(self, new_session_name, template_save=TEMPLATE_NONE):
        if self.prefix_mode != PREFIX_MODE_SESSION_NAME:
            return
            
        old_session_name = session.name
        new_client_id    = self.client_id
        old_client_id    = self.client_id
        xsessionx   = "XXX_SESSION_NAME_XXX"
        xclient_idx = "XXX_CLIENT_ID_XXX"
        
        if template_save == TEMPLATE_NONE:
            spath = "%s/%s" % (session.root, new_session_name)
            
        elif template_save == TEMPLATE_SESSION_SAVE:
            spath = "%s/%s" % (session_template_root, new_session_name)
            new_session_name = xsessionx
            
        elif template_save == TEMPLATE_SESSION_LOAD:
            spath = "%s/%s" % (session.root, new_session_name)
            old_session_name = xsessionx
            
        elif template_save == TEMPLATE_CLIENT_SAVE:
            spath = "%s/%s" % (client_template_local_root, new_session_name)
            new_session_name = xsessionx
            new_client_id    = xclient_idx
           
        elif template_save == TEMPLATE_CLIENT_LOAD:
            spath = session.path
            old_session_name = xsessionx
            old_client_id    = xclient_idx
           
        project_path = "%s/%s.%s" % (spath, old_session_name, old_client_id)
        
        if not os.path.exists(project_path):
            for file in os.listdir(spath):
                if ( file.startswith("%s.%s." %(old_session_name, old_client_id)) or
                     file == "%s.%s" %(old_session_name, old_client_id) ):
                    
                    if not os.access("%s/%s" % (spath, file), os.W_OK):
                        continue
                    
                    endfile = file.replace("%s.%s." %(old_session_name, old_client_id), '', 1)
                    
                    os.rename('%s/%s' %(spath, file), "%s/%s.%s.%s" % (spath, new_session_name, new_client_id, endfile))
            return
        
        if not os.path.isdir(project_path):
            if not os.access(project_path, os.W_OK):
                return
            
            os.rename(project_path, "%s/%s.%s" % (spath, new_session_name, new_client_id))
            return
        
        #only for ardour
        ardour_file  = "%s/%s.ardour"     % (project_path, old_session_name)
        ardour_bak   = "%s/%s.ardour.bak" % (project_path, old_session_name)
        ardour_audio = "%s/interchange/%s.%s" % (project_path, old_session_name, old_client_id)
        
        if os.path.isfile(ardour_file) and os.access(ardour_file, os.W_OK):
            os.rename(ardour_file, "%s/%s.ardour" % (project_path, new_session_name))
        if os.path.isfile(ardour_bak) and os.access(ardour_bak, os.W_OK):
            os.rename(ardour_bak, "%s/%s.ardour.bak" % (project_path, new_session_name))
        if os.path.isdir(ardour_audio and os.access(ardour_audio, os.W_OK)):
            os.rename(ardour_audio, "%s/interchange/%s.%s" % (project_path, new_session_name, new_client_id))
        
        #change last_used snapshot of ardour
        instant_file = "%s/instant.xml" % project_path
        if os.path.isfile(instant_file) and os.access(instant_file, os.W_OK):
            try :
                file = open(instant_file, 'r')
                xml = QDomDocument()
                xml.setContent(file.read())
                content = xml.documentElement()
                
                if content.tagName() == 'instant':
                    node = content.firstChild()
                    while not node.isNull():
                        tag = node.toElement()
                        if tag.tagName() == 'LastUsedSnapshot':
                            if tag.attribute('name') == old_session_name:
                                tag.setAttribute('name', new_session_name)
                                file = open(instant_file, 'w')
                                file.write(xml.toString())
                            break
                            
                        node = node.nextSibling()
                file.close()
            except:
                False
        
        #for ray-proxy, change config_file name
        proxy_file = "%s/ray-proxy.xml" % project_path
        if os.path.isfile(proxy_file):
            try:
                file = open(proxy_file, 'r')
                xml = QDomDocument()
                xml.setContent(file.read())
                content = xml.documentElement()
                
                if content.tagName() == "RAY-PROXY":
                    cte = content.toElement()
                    config_file = cte.attribute('config_file')
                    
                    if ('$NSM_SESSION_NAME' or '${NSM_SESSION_NAME}') in config_file:
                        for env in ('"$NSM_SESSION_NAME"', '"${NSM_SESSION_NAME}"', "$NSM_SESSION_NAME", "${NSM_SESSION_NAME}"):
                            config_file = config_file.replace(env, old_session_name)
                        
                        if config_file and config_file.split('.')[0] == old_session_name:
                            config_file_path = "%s/%s" % (project_path, config_file)
                            
                            if os.path.exists(config_file_path) and os.access(config_file_path, os.W_OK):
                                os.rename(config_file_path, "%s/%s" % (project_path, config_file.replace(old_session_name, new_session_name)))
                                            
                file.close()
                        
            except:
                False
        
        if os.access(project_path, os.W_OK):
            subprocess.run(['mv', project_path, "%s/%s.%s" % (spath, new_session_name, new_client_id)])
    
    def serverAnnounce(self, path, args, src_addr, is_new):
        client_name, capabilities, executable_path, major, minor, pid = args
        
        if self.pending_command in (COMMAND_QUIT, COMMAND_KILL):
            return
        
        if major > NSM_API_VERSION_MAJOR:
            MESSAGE("Client is using incompatible and more recent API version %i.%i" % (major, minor))
            server.send(src_addr, "/error", path, ERR_INCOMPATIBLE_API, "Server is using an incompatible API version." )
            return
        
        self.pid          = pid
        self.capabilities = capabilities
        self.addr         = src_addr
        self.name         = client_name
        self.active       = True
        
        if self.executable_path in known_as_non_active:
            known_as_non_active.remove(self.executable_path)
        
        MESSAGE("Process has pid: %i" % pid )
        MESSAGE("The client \"%s\" at \"%s\" informs us it's ready to receive commands." % (self.name, self.addr.url) )
        server.send(src_addr, "/reply", path, "Well hello, stranger. Welcome to the party." if is_new else "Howdy, what took you so long?", APP_TITLE, ":server-control:broadcast:optional-gui:" )
        
        self.status = CLIENT_STATUS_OPEN
        
        self.sendGuiClientProperties()
        server.sendGui("/ray/gui/client/status", self.client_id, self.status)
        
        if self.isCapableOf(":optional-gui:"):
            server.sendGui("/ray/gui/client/has_optional_gui", self.client_id)
                
        jack_client_name      = self.getJackClientName()
        client_project_path = self.getProjectPath()
        server.send(src_addr, "/nsm/client/open", client_project_path,  session.name, jack_client_name)
        self.pending_command = COMMAND_OPEN
       
class Session(QObject):
    def __init__(self):
        QObject.__init__(self)
        self.clients = []
        self.new_clients = []
        self.removed_clients = []
        self.name    = ""
        self.path    = ""
        self.root    = ""
        
        self.forbidden_ids_list = []
    
    #############
    
    def setRoot(self, session_root):
        if self.name:
            return
        self.root = session_root
    
    def setName(self, session_name):
        self.name = session_name
    
    def setPath(self, session_path):
        self.path = session_path
        self.setName(session_path.rpartition('/')[2])
        
    def newClient(self, executable, client_id=None):
        client = Client()
        client.executable_path = executable
        client.name = os.path.basename(executable)
        client.client_id = client_id if client_id else self.generateClientId(executable)
        self.clients.append(client)
        return client
    
    def removeClient(self, client):
        if not client in self.clients:
            return
        
        self.removed_clients.append(client)
        self.clients.remove(client)
        
    def tellAllClientsSessionIsLoaded(self):
        MESSAGE("Telling all clients that session is loaded...")
        for client in self.clients:
            client.tellClientSessionIsLoaded()
    
    def purgeInactiveClients(self):
        remove_item_list = []
        for i in range(len(self.clients)):
            if not self.clients[i].active:
                server.sendGui("/ray/gui/client/status", session.clients[i].client_id, CLIENT_STATUS_REMOVED)
                remove_item_list.append(i)
        
        remove_item_list.reverse()
        
        for i in remove_item_list:
            self.clients.__delitem__(i)
            
        del remove_item_list
            
    def clientsHaveErrors(self):
        for client in self.clients:
            if client.active and client.hasError():
                return True
        return False
    
    def updateForbiddenIdsList(self):
        if not self.path:
            return
        
        self.forbidden_ids_list.clear()
        
        for file in os.listdir(self.path):
            if os.path.isdir(file) and file.contains('.'):
                client_id = file.rpartition('.')[2]
                if not client_id in self.forbidden_ids_list:
                    self.forbidden_ids_list.append(client_id)
            elif os.path.isfile(file) and '.' in file:
                for string in file.split('.')[1:]:
                    if not string in self.forbidden_ids_list:
                        self.forbidden_ids_list.append(string)
                        
        for client in self.clients + self.removed_clients:
            if not client.client_id in self.forbidden_ids_list:
                self.forbidden_ids_list.append(client.client_id)
    
    def generateClientIdAsNsm(self):
        client_id = 'n'
        for l in range(4):
            client_id += random.choice(string.ascii_uppercase)
            
        return client_id
    
    def generateClientId(self, wanted_id=None):
        self.updateForbiddenIdsList()
        
        if wanted_id:
            for to_rm in ('ray-', 'non-', 'carla-'):
                if wanted_id.startswith(to_rm):
                    wanted_id = wanted_id.replace(to_rm, '', 1)
                    break
            
            wanted_id = wanted_id.replace('jack', '')
            
            #reduce string if contains '-'
            if '-' in wanted_id:
                new_wanted_id = ''
                seplist = wanted_id.split('-')
                for sep in seplist[:-1]:
                    if len(sep) > 0:
                        new_wanted_id += (sep[0] + '_')
                new_wanted_id += seplist[-1]
                wanted_id = new_wanted_id
            
            
            #prevent non alpha numeric characters
            new_wanted_id = ''
            last_is_ = False
            for char in wanted_id:
                if char.isalnum():
                    new_wanted_id += char
                else:
                    if not last_is_:
                        new_wanted_id += '_'
                        last_is_ = True
            
            wanted_id = new_wanted_id
            
            while wanted_id and wanted_id.startswith('_'):
                wanted_id = wanted_id[1:]
            
            while wanted_id and wanted_id.endswith('_'):
                wanted_id = wanted_id[:-1]
            
            if not wanted_id:
                wanted_id = self.generateClientIdAsNsm()
                while wanted_id in self.forbidden_ids_list:
                    wanted_id = self.generateClientIdAsNsm()
            
            #limit string to 10 characters
            if len(wanted_id) >= 10:
                wanted_id = wanted_id[:9]
            
            if not wanted_id in self.forbidden_ids_list:
                self.forbidden_ids_list.append(wanted_id)
                return wanted_id
            
            n=2
            while "%s_%i" % (wanted_id, n) in self.forbidden_ids_list:
                n+=1
            
            self.forbidden_ids_list.append(wanted_id)
            return "%s_%i" % (wanted_id, n)
                
                
        client_id = 'n'
        for l in range(4):
            client_id += random.choice(string.ascii_uppercase)
        
        while client_id in self.forbidden_ids_list:
            client_id = 'n'
            for l in range(4):
                client_id += random.choice(string.ascii_uppercase)
        
        self.forbidden_ids_list.append(client_id)
        return client_id
    
    def getListOfExistingClientIds(self):
        if not self.path:
            return []
        
        client_ids_list = []
        
        for file in os.listdir(self.path):
            if os.path.isdir(file) and file.contains('.'):
                client_ids_list.append(file.rpartition('.')[2])
            elif os.path.isfile(file) and file.contains('.'):
                file_without_extension = file.rpartition('.')[0]
                
    
    def addClient(self, client):
        self.clients.append(client)
        client.sendGuiClientProperties()
        
    def reOrderClients(self, client_ids_list):
        client_newlist  = []
        
        for client_id in client_ids_list:
            for client in self.clients:
                if client.client_id == client_id:
                    client_newlist.append(client)
                    break
        
        if len(client_ids_list) != len(self.clients):
            return
        
        self.clients.clear()
        for client in client_newlist:
            self.clients.append(client)

class OperatingSession(Session):
    #Session is separated in 3 parts only for faster search and modifications.
    def __init__(self):
        Session.__init__(self)
        self.wait_for = WAIT_FOR_NONE
        
        self.timer = QTimer()
        self.expected_clients = []
        
        self.timer_launch = QTimer()
        self.timer_launch.setInterval(100)
        self.timer_launch.timeout.connect(self.timerLaunchTimeOut)
        self.clients_to_launch = []
        
        self.timer_stop = QTimer()
        self.timer_stop.setInterval(100)
        self.timer_stop.timeout.connect(self.timerStopTimeOut)
        self.clients_to_stop = []
        
        self.err_loading = ERR_OK
        self.err_saving  = ERR_OK
        
        self.osc_path     = None
        self.osc_args     = None
        self.osc_src_addr = None
        
        self.process_order = []
        
        self.terminated_yet = False
    
    def rememberOscArgs(self, path, args, src_addr):
        self.osc_path     = path
        self.osc_args     = args
        self.osc_src_addr = src_addr
    
    def waitAndGoTo(self, duration, follow, wait_for, single_shot=True):
        self.timer.stop()
        
        #we need to delete timer to change the timeout connect
        del self.timer
        self.timer = QTimer()
        
        if self.expected_clients:
            if wait_for == WAIT_FOR_ANNOUNCE:
                GUIMSG(_translate('GUIMSG', 'waiting for clients announces...'))
            elif wait_for == WAIT_FOR_STOP:
                GUIMSG(_translate('GUIMSG', 'waiting for clients to die...'))
            
            self.wait_for = wait_for
            self.timer.setSingleShot(True)
            self.timer.timeout.connect(follow)
            self.timer.start(duration)
        else:
            follow()
    
    def endTimerIfLastExpected(self, client):
        if client in self.expected_clients:
            self.expected_clients.remove(client)
        if not self.expected_clients:
            self.timer.setSingleShot(True)
            self.timer.stop()
            self.timer.start(0)
    
    def cleanExpected(self):
        if self.expected_clients:
            client_names = ""
            for client in self.expected_clients:
                client_names += client.name + ', ' 
            
            if self.wait_for == WAIT_FOR_ANNOUNCE:
                GUIMSG(_translate('GUIMSG', "%sdidn't announce") % client_names)
            elif self.wait_for == WAIT_FOR_STOP:
                GUIMSG(_translate('GUIMSG', "%sstill alive !") % client_names)
                
            self.expected_clients.clear()
        else:
            if self.wait_for == WAIT_FOR_ANNOUNCE:
                GUIMSG(_translate('GUIMSG', 'All expected clients are announced'))
            elif self.wait_for == WAIT_FOR_STOP:
                GUIMSG(_translate('GUIMSG', 'All expected clients are died'))
        self.wait_for = WAIT_FOR_NONE
    
    def nextFunction(self):
        if len(self.process_order) > 0:
            next_function = self.process_order[0]
            self.process_order.__delitem__(0)
            next_function()
    
    def timerLaunchTimeOut(self):
        if self.clients_to_launch:
            waitForJack()
            self.clients_to_launch[0].start()
            self.clients_to_launch.__delitem__(0)
            
        if not self.clients_to_launch:
            self.timer_launch.stop()
            
    def timerStopTimeOut(self):
        if self.clients_to_stop:
            waitForJack()
            self.clients_to_stop[0].stop()
            self.clients_to_stop.__delitem__(0)
            
        if not self.clients_to_stop:
            self.timer_stop.stop()
    
    def sendError(self, err, error_message):
        if not (self.osc_src_addr or self.osc_path):
            return
        server.send(self.osc_src_addr, "/error", self.osc_path, err, error_message)
    
    ############################## COMPLEX OPERATIONS ###################
    #all functions are splitted when we need to wait clients for something (announce, reply, quit)
    #for example, at the end of save(), timer is launched, 
    #then, when timer is timeout or when all client replied, save_step1 is launch
        
    def save(self):
        if not self.path:
            self.nextFunction()
            return
        
        server.setServerStatus(SERVER_STATUS_SAVE)
        
        for client in self.clients:
            if client.active:
                self.expected_clients.append(client)
                client.save()
                
        self.waitAndGoTo(10000, self.save_step1, WAIT_FOR_REPLY)
            
    def save_step1(self):
        self.cleanExpected()
        
        if not self.path:
            self.nextFunction()
            return
        
        session_file = self.path + '/raysession.xml'
        if os.path.isfile(session_file) and not os.access(session_file, os.W_OK):
            self.err_saving = ERR_CREATE_FAILED
            self.saveError()
            return
        
        self.err_saving = ERR_OK
        
        contents = ("<?xml version='1.0' encoding='UTF-8'?>\n"
                   "<!DOCTYPE RAYSESSION>\n"
                   "<RAYSESSION VERSION='%s'>\n" % VERSION)
        
        contents += "  <Clients>\n"
        for client in self.clients:
            contents += "    <client id=\"%s\" executable=\"%s\" name=\"%s\" prefix_mode=\"%i\" launched=\"%i\" " % (client.client_id, client.executable_path, client.name, client.prefix_mode, int(bool(client.isRunning())) )
            if client.project_path:
                contents += "project_path=\"%s\" " % client.project_path
            if client.icon:
                contents += "icon=\"%s\" "  % client.icon
            if client.label:
                contents += "label=\"%s\" " % client.label
            
            #remove last space
            contents = contents[:-1]
            contents += "/>\n"
            
        contents += "  </Clients>\n"
        contents += "  <RemovedClients>\n"
        for ex_client in self.removed_clients:
            contents +="     <client id=\"%s\" executable=\"%s\" name=\"%s\" prefix_mode=\"%i\" " % (ex_client.client_id, ex_client.executable_path, ex_client.name, ex_client.prefix_mode )
            if ex_client.project_path:
                contents += "project_path=\"%s\" " % ex_client.project_path
            if ex_client.icon:
                contents += "icon=\"%s\" "  % ex_client.icon
            if ex_client.label:
                contents += "label=\"%s\" " % ex_client.label
                
            #remove last space
            contents = contents[:-1]
            contents += "/>\n"
            
        contents += "  </RemovedClients>\n"
        contents += "</RAYSESSION>"
        
        file = open(session_file, 'w')
        file.write(contents)
        file.close()
        
        GUIMSG(_translate('GUIMSG', "Session saved."))
        MESSAGE("Session saved.")
        self.nextFunction()
    
    def saveDone(self):
        if not self.err_loading:
            MESSAGE("Done.")
            server.send(self.osc_src_addr, "/reply", self.osc_path, "Saved." )
        server.setServerStatus(SERVER_STATUS_READY)
    
    def saveError(self):
        MESSAGE("Failed")
        m = _translate('Load Error', "Unknown error")
        if self.err_saving == ERR_CREATE_FAILED:
            m = _translate('GUIMSG', "Can't save session, session file is unwriteable !")
        
        MESSAGE(m)
        GUIMSG(m)
        server.send(self.osc_src_addr, "/error", self.osc_path, ERR_CREATE_FAILED, m)
        
        self.process_order.clear()
        server.setServerStatus(SERVER_STATUS_READY)
        
    def close(self):
        GUIMSG(_translate('GUIMSG', "Commanding attached clients to quit."))
        
        self.expected_clients.clear()
        self.removed_clients.clear()
        
        if not  self.path:
            self.nextFunction()
            return
        
        server.setServerStatus(SERVER_STATUS_CLOSE)
        
        for client in self.clients:
            if client.isRunning():
                self.expected_clients.append(client)
                client.quit()
        
        self.waitAndGoTo(10000, self.close_step1, WAIT_FOR_STOP)
    
    def close_step1(self):
        for client in self.expected_clients:
            client.kill()
            
        self.waitAndGoTo(1000, self.close_step2, WAIT_FOR_STOP)
    
    def close_step2(self):
        self.cleanExpected()
        
        self.purgeInactiveClients()
        self.clients.clear()
        
        if self.path:
            lock_file =  self.path + '/.lock'
            if os.path.isfile(lock_file):
                os.remove(lock_file)
                
            self.setPath('')
            
        server.sendGui("/ray/gui/session/name", "", "" )
        self.nextFunction()
    
    def closeDone(self):
        server.send(self.osc_src_addr, "/reply", self.osc_path, "Closed.")
        MESSAGE("Done")
        server.setServerStatus(SERVER_STATUS_OFF)
    
    def abortDone(self):
        server.send(self.osc_src_addr, "/reply", self.osc_path, "Aborted.")
        MESSAGE("Done")
        server.setServerStatus(SERVER_STATUS_OFF)
        
    def new(self):
        GUIMSG(_translate('GUIMSG', "Creating new session \"%s\"") % self.osc_args[0])
        spath = self.root + '/' + self.osc_args[0]
        
        try:
            os.makedirs(spath)
        except:
            server.send(self.osc_src_addr, "/error", self.osc_path, ERR_CREATE_FAILED, "Could not create the session directory" )
            return
        
        server.setServerStatus(SERVER_STATUS_NEW)
        self.setPath(spath)
        server.send(self.osc_src_addr, "/reply", self.osc_path, "Created." )
        server.sendGui("/ray/gui/session/session", self.osc_args[0])
        server.sendGui("/ray/gui/session/name", self.osc_args[0], self.osc_args[0])
        
        server.send(self.osc_src_addr, "/reply", self.osc_path, "Session created")
        self.nextFunction()
    
    def newDone(self):
        GUIMSG(_translate('GUIMSG', 'Session is ready'))
        server.setServerStatus(SERVER_STATUS_READY)
    
    def duplicate(self):
        if self.clientsHaveErrors():
            self.sendError(ERR_GENERAL_ERROR, _translate('error', "Some clients could not save"))
            self.process_order.clear()
            return
        
        server.setServerStatus(SERVER_STATUS_DUPLICATE)
        new_session_name = self.osc_args[0]
        spath = self.root + '/' + new_session_name
        subprocess.run(['cp', '-R',  self.path, spath])
        
        for client in self.clients + self.removed_clients:
            client.adjustFilesAfterCopy(new_session_name)
            
        self.nextFunction() #here "load"
    
    def saveSessionTemplate(self):
        if self.clientsHaveErrors():
            self.sendError(ERR_GENERAL_ERROR, _translate('error', "Some clients could not save"))
            self.process_order.clear()
            return
        
        server.setServerStatus(SERVER_STATUS_DUPLICATE)
        session_template_name = self.osc_args[0]
        spath = "%s/%s" % (session_template_root, session_template_name)
        
        #overwrite existing template
        if os.path.isdir(spath):
            if not os.access(spath, os.W_OK):
                self.sendError(ERR_GENERAL_ERROR, _translate("error", "Impossible to save template, unwriteable file !" ))
                server.setServerStatus(SERVER_STATUS_READY)
                return
            shutil.rmtree(spath)
        
        if not os.path.exists(session_template_root):
            os.makedirs(session_template_root)
            
        shutil.copytree(self.path, spath)
        #subprocess.run(['cp', '-R', self.path, spath])
        
        for client in self.clients + self.removed_clients:
            client.adjustFilesAfterCopy(session_template_name, True)
        
        MESSAGE("Done")
        server.send(self.osc_src_addr, "/reply", self.osc_path, "Saved as template.")
        server.setServerStatus(SERVER_STATUS_READY)
    
    def prepareTemplate(self):
        if len(self.osc_args) != 2:
            return
        
        template_name = self.osc_args[1]
        template_path = "%s/%s" % (session_template_root, template_name)
        
        if not os.path.isdir(template_path):
            server.sendError(ERR_GENERAL_ERROR, _translate("error", "No template named %s") % template_name)
            return
        
        new_session_name = self.osc_args[0]
        spath = "%s/%s" % (self.root, new_session_name)
        
        server.setServerStatus(SERVER_STATUS_DUPLICATE)                   
        
        shutil.copytree(template_path, spath)
        
        #create temp clients from raysession.xml to adjust Files after copy
        session_file = "%s/%s" % (spath, "raysession.xml")
        
        try:
            ray_file = open(session_file, 'r')
        except:
            self.nextFunction()
            return
        
        tmp_clients = []
        
        xml = QDomDocument()
        xml.setContent(ray_file.read())

        content = xml.documentElement()
        
        if content.tagName() != "RAYSESSION":
            ray_file.close()
            self.err_loading = ERR_BAD_PROJECT
            self.loadError()
            return
            
        node = content.firstChild()
        while not node.isNull():
            tag_name = node.toElement().tagName()
            if tag_name in ('Clients', 'RemovedClients'):
                client_xml = node.toElement().firstChild()
                while not client_xml.isNull():
                    client = Client()
                    cx = client_xml.toElement()
                    
                    client.client_id  = str(cx.attribute('id'))
                    prefix_mode = str(cx.attribute('prefix_mode'))
                    if prefix_mode.isdigit() and 0 <= int(prefix_mode) <= 2:
                        client.prefix_mode = int(prefix_mode)
                    
                    tmp_clients.append(client)
                    
                    client_xml = client_xml.nextSibling()
                    
            node = node.nextSibling()
        
        ray_file.close()
        
        for client in tmp_clients:
            client.adjustFilesAfterCopy(new_session_name, TEMPLATE_SESSION_LOAD)
        
        self.nextFunction()
    
    def load(self):
        #terminate or switch clients
        spath = self.root + '/' + self.osc_args[0]
            
        MESSAGE("Attempting to open %s" % spath)
        
        session_ray_file = spath + '/raysession.xml'
        session_nsm_file = spath + '/session.nsm'
        session_lock = spath + '/.lock'
        
        self.err_loading = ERR_OK
        
        if os.path.isfile(session_lock):
            WARNING("Session is locked by another process")
            self.err_loading = ERR_SESSION_LOCKED
            self.loadError()
            return
        
        is_ray_file = True
        
        try:
            ray_file = open(session_ray_file, 'r')
        except:
            is_ray_file = False
            
        if not is_ray_file:
            try:
                file = open(session_nsm_file, 'r')
                server.sendGui('/ray/opening_nsm_session')
            except:
                self.err_loading = ERR_CREATE_FAILED
                self.loadError()
                return
        
        GUIMSG(_translate('GUIMSG', "Opening session %s") % self.osc_args[0])
        
        self.removed_clients.clear()
        
        self.new_clients = []
        new_client_executables = []
        
        session.setPath(spath)
        
        if is_ray_file:
            xml = QDomDocument()
            xml.setContent(ray_file.read())

            content = xml.documentElement()
            
            if content.tagName() != "RAYSESSION":
                ray_file.close()
                self.err_loading = ERR_BAD_PROJECT
                self.loadError()
                return
                
            node = content.firstChild()
            while not node.isNull():
                tag_name = node.toElement().tagName()
                if tag_name in ('Clients', 'RemovedClients'):
                    client_xml = node.toElement().firstChild()
                    while not client_xml.isNull():
                        client = Client()
                        cx = client_xml.toElement()
                        
                        client.client_id       = str(cx.attribute('id'))
                        client.name            = str(cx.attribute('name'))
                        client.executable_path = str(cx.attribute('executable'))
                        client.label           = str(cx.attribute('label'))
                        client.icon            = str(cx.attribute('icon'))
                        client.project_path    = str(cx.attribute('project_path'))
                        client.auto_start      = bool(cx.attribute('launched') != '0')
                        
                        prefix_mode = str(cx.attribute('prefix_mode'))
                        if prefix_mode.isdigit() and 0 <= int(prefix_mode) <= 2:
                            client.prefix_mode = int(prefix_mode)
                        
                        if tag_name == 'Clients':
                            if client.auto_start:
                                new_client_executables.append(client.executable_path)
                            
                            self.new_clients.append(client)
                        
                        client_xml = client_xml.nextSibling()
                        
                node = node.nextSibling()
            
            ray_file.close()
        else:
            for line in file.read().split('\n'):
                elements = line.split(':')
                if len(elements) >= 3:
                    client = Client()
                    client.name            = elements[0]
                    client.executable_path = elements[1]
                    client.client_id       = elements[2]
                    client.prefix_mode     = PREFIX_MODE_CLIENT_NAME
                    self.new_clients.append(client)
                    new_client_executables.append(client.executable_path)
                    
            file.close()
        
        MESSAGE("Commanding unneeded and dumb clients to quit")
        
        for client in session.clients:
            if client.active and client.isCapableOf(':switch:') and client.executable_path in new_client_executables:
                new_client_executables.remove(client.executable_path)
            else:
                #client is not capable of switch, or is not wanted in the new session
                if client.isRunning():
                    self.expected_clients.append(client)
                client.quit()
        
        if self.expected_clients:
            server.setServerStatus(SERVER_STATUS_CLEAR)
        
        self.waitAndGoTo(20000, self.load_step1, WAIT_FOR_STOP)
    
    def load_step1(self):
        self.cleanExpected()
        self.purgeInactiveClients()
        
        for client in session.clients:
            client.pre_existing = True
            
        MESSAGE("Commanding smart clients to switch")
        
        has_switch = False
        
        new_client_id_list = []
        
        for new_client in self.new_clients:
            #/* in a duplicated session, clients will have the same
            #* IDs, so be sure to pick the right one to avoid race
            #* conditions in JACK name registration. */
            client = getClientByExecutableAndId(new_client.executable_path, new_client.client_id)
            if not client:
                client = getClientByExecutable(new_client.executable_path)
            
            if client and client.active and client.pre_existing and not client.isReplyPending():
                #since we already shutdown clients not capable of 'switch', we can assume that these are.
                client.switch(new_client)
                has_switch = True
            else:
                #* sleep a little bit because liblo derives its sequence
                #* of port numbers from the system time (second
                #* resolution) and if too many clients start at once they
                #* won't be able to find a free port. */
                self.addClient(new_client)
                if new_client.auto_start:
                    self.clients_to_launch.append(new_client)
                    if not new_client.executable_path in known_as_non_active:
                        self.expected_clients.append(new_client)
            
            new_client_id_list.append(new_client.client_id)
            
        server.sendGui("/ray/gui/session/name",  session.name, session.name)
        
        if has_switch:
            server.setServerStatus(SERVER_STATUS_SWITCH)
        else:
            server.setServerStatus(SERVER_STATUS_LAUNCH) 
        
        
        #* this part is a little tricky... the clients need some time to
        #* send their 'announce' messages before we can send them 'open'
        #* and know that a reply is pending and we should continue waiting
        #* until they finish.

        #* dumb clients will never send an 'announce message', so we need
        #* to give up waiting on them fairly soon. */
        
        self.timer_launch.start()
        #wait_time_announce = 5000 + (len(self.expected_clients)*100)
        
        self.reOrderClients(new_client_id_list)
        server.sendGui('/ray/gui/clients_reordered', *new_client_id_list)
        
        self.waitAndGoTo(5000, self.load_step2, WAIT_FOR_ANNOUNCE)
    
    def load_step2(self):
        for client in self.expected_clients:
            known_as_non_active.append(client.executable_path)
        settings.setValue('deamon/non_active_list', known_as_non_active)
        settings.sync()
        
        self.cleanExpected()
        
        server.setServerStatus(SERVER_STATUS_OPEN)
        
        for client in self.clients:
            if client.active and client.isReplyPending():
                self.expected_clients.append(client)
        self.waitAndGoTo(10000, self.load_step3, WAIT_FOR_REPLY)
        
    def load_step3(self):
        self.cleanExpected()
        self.tellAllClientsSessionIsLoaded()
        MESSAGE('Loaded')
        
        server.sendGui("/ray/gui/session/name",  session.name, session.name)
        server.send(self.osc_src_addr, "/reply", self.osc_path, "Loaded.")
        
        self.nextFunction()
    
    def loadDone(self):
        MESSAGE("Done")
        server.setServerStatus(SERVER_STATUS_READY)
    
    def loadError(self):
        MESSAGE("Failed")
        m = _translate('Load Error', "Unknown error")
        if self.err_loading == ERR_CREATE_FAILED:
            m = _translate('Load Error', "Could not create session file!")
        elif self.err_loading == ERR_SESSION_LOCKED:
            m = _translate('Load Error', "Session is locked by another process!")
        elif self.err_loading == ERR_NO_SUCH_FILE:
            m = _translate('Load Error', "The named session does not exist.")
        elif self.err_loading == ERR_BAD_PROJECT:
            m = _translate('Load Error', "Could not load session file.")
        
        server.send(self.osc_src_addr, "/error", self.osc_path, self.err_loading, m)
        
        if self.name:
            server.setServerStatus(SERVER_STATUS_READY)
        else:
            server.setServerStatus(SERVER_STATUS_OFF)
            
        self.process_order.clear()
    
    def duplicateDone(self):
        MESSAGE("Done")
        server.send(self.osc_src_addr, "/reply", self.osc_path, "Duplicated.")
        server.setServerStatus(SERVER_STATUS_READY)
        
    def exitNow(self):
        MESSAGE("Bye Bye...")
        server.setServerStatus(SERVER_STATUS_OFF)
        app.quit()
        
class SignaledSession(OperatingSession):
    def __init__(self):
        OperatingSession.__init__(self)
        signaler.server_new.connect(self.serverNewSession)
        signaler.server_new_from_tp.connect(self.serverNewSessionFromTemplate)
        signaler.server_open.connect(self.serverOpenSession)
        signaler.server_save.connect(self.serverSaveSession)
        signaler.server_duplicate.connect(self.serverDuplicateSession)
        signaler.server_save_session_template.connect(self.serverSaveSessionTemplate)
        signaler.server_close.connect(self.serverCloseSession)
        signaler.server_abort.connect(self.serverAbortSession)
        signaler.server_list_sessions.connect(self.serverListSessions)
        
        signaler.server_startallclients.connect(self.serverStartAllClients)
        signaler.server_stopallclients.connect(self.serverStopAllClients)
        
        signaler.server_reorder_clients.connect(self.serverReorderClients)
        
        signaler.server_add.connect(self.serverAdd)
        signaler.server_add_proxy.connect(self.serverAddProxy)
        signaler.server_add_user_client_template.connect(self.serverAddUserClientTemplate)
        signaler.server_add_factory_client_template.connect(self.serverAddFactoryClientTemplate)
        
        signaler.server_announce.connect(self.serverAnnounce)
        signaler.server_reply.connect(self.serverReply)
        
        signaler.gui_client_stop.connect(self.guiClientStop)
        signaler.gui_client_kill.connect(self.guiClientKill)
        signaler.gui_client_remove.connect(self.guiClientRemove)
        signaler.gui_client_resume.connect(self.guiClientResume)
        signaler.gui_client_save.connect(self.guiClientSave)
        signaler.gui_client_save_template.connect(self.guiClientSaveTemplate)
        signaler.gui_client_label.connect(self.guiClientLabel)
        signaler.gui_client_icon.connect(self.guiClientIcon)
        
    ############################# FUNCTIONS CONNECTED TO SIGNALS FROM OSC ###############################
    
    def serverNewSession(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, self.close, self.new, self.save, self.newDone]
        self.nextFunction()
        
    def serverNewSessionFromTemplate(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, self.prepareTemplate, self.load, self.loadDone]
        self.nextFunction()
        
    def serverOpenSession(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, self.load, self.loadDone]
        self.nextFunction()
    
    def serverSaveSession(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, self.saveDone]
        self.nextFunction()
        
    def serverCloseSession(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, self.close, self.closeDone]
        self.nextFunction()
    
    def serverDuplicateSession(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, self.duplicate, self.load, self.duplicateDone]
        self.nextFunction()
        
    def serverSaveSessionTemplate(self, path, args, src_addr):
        if self.process_order:
            return
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.save, self.saveSessionTemplate]
        self.nextFunction()
        
    def serverAbortSession(self, path, args, src_addr):
        self.wait_for = WAIT_FOR_NONE
        self.timer.stop()
        
        self.rememberOscArgs(path, args, src_addr)
        self.process_order = [self.close, self.abortDone]
        self.nextFunction()
    
    def serverListSessions(self, path, args, src_addr):
        if not self.root:
            return
        
        for fds in os.walk(self.root):
            folder, folders, files = fds
            if folder == session.root:
                continue
            
            already_send = False
            
            for file in files:
                if file in ('raysession.xml', 'session.nsm'):
                    if not already_send:
                        basefolder = folder.replace(session.root + '/', '')
                        server.send(src_addr, "/reply", "/nsm/server/list", basefolder)
                        already_send = True
                    
        server.send(src_addr, path, ERR_OK, "Done.")
    
    def serverStartAllClients(self):
        MESSAGE('Starting All Clients')
        for client in self.clients:
            if not client.isRunning():
                self.clients_to_launch.append(client)
                
        self.timer_launch.start()
        
    def serverStopAllClients(self):
        MESSAGE('Stopping All Clients')
        for client in session.clients:
            client.stop()
        
    def serverReorderClients(self, path, args):
        client_ids_list = args
        
        self.reOrderClients(client_ids_list)
        
    
    def serverAdd(self, path, args, src_addr):
        self.rememberOscArgs(path, args, src_addr)
        executable = args[0]
        
        client = Client()
        client.executable_path = executable
        client.name            = os.path.basename(executable)
        client.client_id       = self.generateClientId(executable)
        client.icon            = client.name.lower().replace('_', '-')
        
        self.addClient(client)
        client.start()
    
    def serverAddProxy(self, path, args, src_addr):
        self.rememberOscArgs(path, args, src_addr)
        executable = args[0]
        
        client = Client()
        client.executable_path = 'ray-proxy'
        client.arguments_line  = executable
        client.name            = os.path.basename(executable)
        client.client_id       = self.generateClientId(client.name)
        client.icon            = client.name.lower().replace('_', '-')
        
        self.addClient(client)
        client.start()
    
    def addClientTemplate(self, template_name, factory=False):
        if factory:
            templates_root = client_template_factory_root
        else:
            templates_root = client_template_local_root
        
        xml_file = "%s/%s" % (templates_root, 'client_templates.xml')
        file = open(xml_file, 'r')
        xml = QDomDocument()
        xml.setContent(file.read())
        file.close()
        
        if xml.documentElement().tagName() != 'RAY-CLIENT-TEMPLATES':
            return
        
        node = xml.documentElement().firstChild()
        while not node.isNull():
            ct = node.toElement()
            if ct.tagName() != 'Client-Template':
                node = node.nextSibling()
                continue
            
            if ct.attribute('template-name') == template_name:
                client = Client()
                client.executable_path = ct.attribute('executable')
                client.client_id       = self.generateClientId(ct.attribute('client_id'))
                client.name            = ct.attribute('name')
                client.label           = ct.attribute('label')
                client.icon            = ct.attribute('icon')
                
                prefix_mode = ct.attribute('prefix-mode')
                if prefix_mode:
                    client.prefix_mode = int(prefix_mode)
                    if prefix_mode == '0':
                        client.project_path = ct.attribute('project-path')
                
                start = True
                launched = ct.attribute('launched')
                if launched.isdigit():
                    start = bool(int(launched))
                
                needed_version = ct.attribute('needed-version')
                
                if needed_version.startswith('.') or needed_version.endswith('.') or not needed_version.replace('.', '').isdigit():
                    #needed-version not writed correctly, ignores it
                    needed_version = ''
                
                if factory and needed_version:
                    full_program_version = subprocess.check_output([client.executable_path, '--version']).decode()
                    previous_is_digit = False
                    program_version = ''
                    for character in full_program_version:
                        if character.isdigit():
                            program_version+=character
                            previous_is_digit = True
                        elif character == '.':
                            if previous_is_digit:
                                program_version+=character
                            previous_is_digit = False
                        else:
                            if program_version:
                                break
                            
                    if not program_version:
                        node = node.nextSibling()
                        continue
                    
                    
                    neededs = []
                    progvss = []
                    
                    for n in needed_version.split('.'):
                        neededs.append(int(n))
                        
                    for n in program_version.split('.'):
                        progvss.append(int(n))
                    
                    if neededs > progvss:
                        node = node.nextSibling()
                        continue
                
                if not needed_version:
                    template_path = "%s/%s" % (templates_root, template_name)
                    
                    if os.path.isdir(template_path):
                        for file in os.listdir(template_path):
                            subprocess.run(['cp', '-R', "%s/%s" % (template_path, file), self.path])
                        
                    client.adjustFilesAfterCopy(self.name, TEMPLATE_CLIENT_LOAD)
                    
                self.addClient(client)
                if start:
                    client.start()
                
                break
            
            node = node.nextSibling()
    
    def serverAddUserClientTemplate(self, path, args, src_addr):
        self.rememberOscArgs(path, args, src_addr)
        template_name = args[0]
        
        self.addClientTemplate(template_name, False)
        
    def serverAddFactoryClientTemplate(self, path, args, src_addr):
        self.rememberOscArgs(path, args, src_addr)
        template_name = args[0]
        
        self.addClientTemplate(template_name, True)
     
    def serverAnnounce(self, path, args, src_addr):
        client_name, capabilities, executable_path, major, minor, pid = args
        
        if self.wait_for == WAIT_FOR_STOP:
            return
        
        for client in self.clients:
            if (client.executable_path == executable_path
                and not client.active
                and client.pending_command == COMMAND_START):
                    client.serverAnnounce(path, args, src_addr, False)
                    break
        else:
            pass
            #Ray Session won't add clients that aren't launched by Ray Session itself. 
            #client = self.newClient(executable_path)
            #client.serverAnnounce(path, args, src_addr, True)
        
        if self.wait_for == WAIT_FOR_ANNOUNCE:
            self.endTimerIfLastExpected(client)
    
    def serverReply(self, path, args, src_addr):
        if self.wait_for == WAIT_FOR_STOP:
            return
        
        message = args[1]
        client = getClientByAddress(src_addr)
        if client:
            client.setReply(ERR_OK, message)
            #MESSAGE( "Client \"%s\" replied with: %s in %fms" % ( client.name, message, client.milliseconds_since_last_command() ))
            client.pending_command = COMMAND_NONE
            client.status = CLIENT_STATUS_READY
            server.sendClientStatusToGui(client)
            
            if self.wait_for == WAIT_FOR_REPLY:
                self.endTimerIfLastExpected(client)
        else:
            MESSAGE("Reply from unknown client")
            
    def guiClientStop(self, path, args):
        for client in self.clients:
            if client.client_id == args[0]:
                client.stop()
                server.sendGui("/reply", "Client stopped." )
                break
        else:
            server.sendGui("/error", -10, "No such client." )
    
    def guiClientKill(self, path, args):
        for client in self.clients:
            if client.client_id == args[0]:
                client.kill()
                server.sendGui("/reply", "Client killed." )
                break
        else:
            server.sendGui("/error", -10, "No such client." )
    
    def guiClientRemove(self, path, args):
        for client in self.clients:
            if client.client_id == args[0]:
                if not client.isRunning():
                    server.sendGui("/ray/gui/client/status", client.client_id, CLIENT_STATUS_REMOVED)
                    self.removeClient(client)
                    server.sendGui("/reply", "Client removed.")
                break
        else:
            server.sendGui("/error", -10, "No such client.")
    
    def guiClientResume(self, path, args):
        for client in self.clients:
            if client.client_id  == args[0] and not client.isRunning():
                client.start()
                break
    
    def guiClientSave(self, path, args):
        for client in self.clients:
            if client.client_id == args[0] and client.active:
                client.save()
                break
    
    def guiClientSaveTemplate(self, path, args):
        for client in self.clients:
            if client.client_id == args[0]:
                client.saveAsTemplate(args[1])
                break
    
    def guiClientLabel(self, client_id, label):
        for client in self.clients:
            if client.client_id == client_id:
                client.setLabel(label)
                break
            
    def guiClientIcon(self, client_id, icon):
        for client in self.clients:
            if client.client_id == client_id:
                client.setIcon(icon)
                break
    
    def terminate(self):
        if self.terminated_yet:
            return
        
        self.terminated_yet = True
        self.process_order = [self.close, self.exitNow]
        self.nextFunction()
        
def getClientById(client_id):
    for client in session.clients:
        if client.client_id == client_id:
            return client

def getClientByExecutableAndId(executable, client_id):
    for client in session.clients:
        if client.client_id == client_id and client.executable_path == executable:
            return client
        
def getClientByExecutable(executable):
    for client in session.clients:
        if client.executable_path == executable:
            return client
        
def getClientByNameAndId(name, client_id):
    for client in session.clients:
        if client.client_id == client_id and client.name == name:
            return client
        
def getClientByName(client_name):
    for client in session.clients:
        if client.name == client_name:
            return client

def getClientByAddress(addr):
    if not addr:
        return None
    
    for client in session.clients:
        if client.addr and client.addr.url == addr.url:
            return client

def getClientByPid(pid):
    for client in session.clients:
        if client.pid == pid:
            return client
    
def pathIsValid(path):
    return not bool('../' in path)
    
def generateClientId():
    client_id = 'n'
    for l in range(4):
        client_id += random.choice(string.ascii_uppercase)
    
    return client_id

##########################

class Signaler(QObject):
    server_announce  = pyqtSignal(str, list, object)
    server_reply     = pyqtSignal(str, list, object)
    server_duplicate = pyqtSignal(str, list, object)
    server_save_session_template = pyqtSignal(str, list, object)
    server_abort       = pyqtSignal(str, list, object)
    server_close       = pyqtSignal(str, list, object)
    server_new         = pyqtSignal(str, list, object)
    server_new_from_tp = pyqtSignal(str, list, object)
    server_open        = pyqtSignal(str, list, object)
    server_save        = pyqtSignal(str, list, object)
    server_list_sessions   = pyqtSignal(str, list, object)
    server_add = pyqtSignal(str, list, object)
    server_add_proxy = pyqtSignal(str, list, object)
    server_add_user_client_template    = pyqtSignal(str, list, object)
    server_add_factory_client_template = pyqtSignal(str, list, object)
    server_startallclients = pyqtSignal()
    server_stopallclients  = pyqtSignal()
    server_reorder_clients = pyqtSignal(str, list)
    gui_client_stop   = pyqtSignal(str, list)
    gui_client_kill   = pyqtSignal(str, list)
    gui_client_remove = pyqtSignal(str, list)
    gui_client_resume = pyqtSignal(str, list)
    gui_client_save   = pyqtSignal(str, list)
    gui_client_save_template = pyqtSignal(str, list)
    gui_client_label  = pyqtSignal(str, str)
    gui_client_icon   = pyqtSignal(str, str)
    

class OscServerThread(ServerThread):
    def __init__(self, osc_num=0):
        ServerThread.__init__(self, osc_num)
        self.gui_list = []
        self.server_status = SERVER_STATUS_OFF

    @make_method('/nsm/server/announce', None)
    def nsmServerAnnounce(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        if len(args) != 6:
            return
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "Sorry, but there's no session open for this application to join." )
            return
        
        signaler.server_announce.emit(path, args, src_addr)
        
    @make_method('/reply', None)
    def reply(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        signaler.server_reply.emit(path, args, src_addr)
            
    @make_method('/error', None)
    def error(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        client = getClientByAddress(src_addr)
        if not client:
            WARNING("Error from unknown client")
            return
        
        err_code = args[1]
        message  = args[2]
        client.setReply(err_code, message)
        
        MESSAGE( "Client \"%s\" replied with error: %s (%i)" % ( client.name, message, err_code ))
        client.pending_command = COMMAND_NONE
        client.status          = CLIENT_STATUS_ERROR
        
        self.sendClientStatusToGui(client) 

    @make_method('/nsm/client/progress', None)
    def nsmClientProgress(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        client = getClientByAddress(src_addr)
        if client:
            client.progress = args[0]
            
            self.sendGui("/ray/gui/client/progress", client.client_id, client.progress)
    
    @make_method('/nsm/client/is_dirty', None)
    def nsmClientIs_dirty(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        MESSAGE("Client sends dirty")
        
        client = getClientByAddress(src_addr)
        if not client:
            return
        
        client.dirty = 1
        
        self.sendGui("/ray/gui/client/dirty", client.client_id, client.dirty)

    @make_method('/nsm/client/is_clean', None)
    def nsmClientIs_clean(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        MESSAGE("Client sends clean")
        
        client = getClientByAddress(src_addr)
        if not client:
            return
        
        client.dirty = 0
        
        self.sendGui("/ray/gui/client/dirty", client.client_id, client.dirty)
    
    @make_method('/nsm/client/message', None)
    def nsmClientMessage(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        client = getClientByAddress(src_addr)
        if not client:
            return
        
        self.sendGui("/ray/gui/client/message", client.client_id, args[0], args[1])

    @make_method('/nsm/client/gui_is_hidden', None)
    def nsmClientGui_is_hidden(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        MESSAGE("Client sends gui hidden")
        
        client = getClientByAddress(src_addr)
        if not client:
            print('no client at addr')
            return
        
        client.gui_visible = False
        
        self.sendGui("/ray/gui/client/gui_visible", client.client_id, client.gui_visible)

    @make_method('/nsm/client/gui_is_shown', None)
    def nsmClientGui_is_shown(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        MESSAGE("Client sends gui shown")
        
        client = getClientByAddress(src_addr)
        if not client:
            return
        
        client.gui_visible = True
        
        self.sendGui("/ray/gui/client/gui_visible", client.client_id, client.gui_visible)

    @make_method('/nsm/client/label', None)
    def nsmClientLabel(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        client = getClientByAddress(src_addr)
        if not client:
            return
        
        if not type(args[0]) is str:
            return
        
        label = args[0]
        signaler.gui_client_label.emit(client.client_id, label)
        
    @make_method('/ray/client/icon', None)
    def rayClientIcon(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        client = getClientByAddress(src_addr)
        if not client:
            return
        
        if not type(args[0]) is str:
            return
        
        icon = args[0]
        
        signaler.gui_client_icon.emit(client.client_id, icon)
            
    @make_method('/ray/gui/gui_announce', None)
    def nsmGuiGui_announce(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        self.announceGui(src_addr.url, True)

    @make_method('/ray/gui/client/stop', None)
    def nsmGuiClientStop(self, path, args):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        signaler.gui_client_stop.emit(path, args)
    
    @make_method('/ray/gui/client/kill', None)
    def nsmGuiClientKill(self, path, args):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        signaler.gui_client_kill.emit(path, args)            
    
    @make_method('/ray/gui/client/remove', None)
    def nsmGuiClientRemove(self, path, args):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        signaler.gui_client_remove.emit(path, args)
        
    @make_method('/ray/gui/client/resume', None)
    def nsmGuiClientResume(self, path, args):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        signaler.gui_client_resume.emit(path, args)
                
    @make_method('/ray/gui/client/save', None)
    def nsmGuiClientSave(self, path, args):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        signaler.gui_client_save.emit(path, args)

    @make_method('/ray/gui/client/save_as_template', None)
    def rayGuiClientSaveAsTemplate(self, path, args):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        signaler.gui_client_save_template.emit(path, args)
    
    @make_method('/ray/gui/client/show_optional_gui', None)
    def nsmGuiClientShow_optional_gui(self, path, args):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        client = getClientById(args[0])
        
        if client and client.active:
            self.send(client.addr, "/nsm/client/show_optional_gui")

    @make_method('/ray/gui/client/hide_optional_gui', None)
    def nsmGuiClientHide_optional_gui(self, path, args):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        client = getClientById(args[0])
        
        if client and client.active:
            self.send(client.addr, "/nsm/client/hide_optional_gui")

    @make_method('/osc/ping', None)
    def oscPing(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        self.send(src_addr, "/reply", path)

    @make_method('/nsm/server/broadcast', None)
    def nsmServerBroadcast(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        #don't allow clients to broadcast NSM commands
        if args[0].startswith('/nsm/'):
            return
        
        for client in session.clients:
            if not client.addr:
                continue
            
            if client.addr.url != src_addr.url:
                self.send(client.addr, Message(*args))
                
            for gui_addr in self.gui_list:
                #also relay to attached GUI so that the broadcast can be
                #propagated to another NSMD instance
                if gui_addr.url != src_addr.url:
                    self.send(gui_addr, Message(*args))
        
        
    @make_method('/nsm/server/duplicate', None)
    def nsmServerDuplicate(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to duplicate.")
            return
        
        if not pathIsValid(args[0]):
            self.send(src_addr, "/error", path, ERR_CREATE_FAILED, "Invalid session name.")
            return
        
        signaler.server_duplicate.emit(path, args, src_addr)
        
    @make_method('/ray/server/save_session_template', None)
    def nsmServerSaveSessionTemplate(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to save as template.")
            return
        
        if not pathIsValid(args[0]):
            self.send(src_addr, "/error", path, ERR_CREATE_FAILED, "Invalid session name.")
            return
        
        signaler.server_save_session_template.emit(path, args, src_addr)
        
    
    @make_method('/nsm/server/abort', None)
    def nsmServerAbort(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to abort." )
            return
        
        signaler.server_abort.emit(path, args, src_addr)

    @make_method('/nsm/server/list', None)
    def nsmServerList(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        signaler.server_list_sessions.emit(path, args, src_addr)
        
    @make_method('/nsm/server/add', None)
    def nsmServerAdd(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "Cannot add to session because no session is loaded." )
            return
        
        if '/' in args[0]:
            self.send(src_addr, "/error", path, ERR_LAUNCH_FAILED, "Absolute paths are not permitted. Clients must be in $PATH" )
        
        signaler.server_add.emit(path, args, src_addr)

    @make_method('/nsm/server/add_proxy', None)
    def rayServerAddProxy(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "Cannot add to session because no session is loaded." )
            return
        
        signaler.server_add_proxy.emit(path, args, src_addr)

    

    @make_method('/ray/server/add_user_client_template', None)
    def rayServerAddUserClientTemplate(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "Cannot add to session because no session is loaded." )
            return
        
        signaler.server_add_user_client_template.emit(path, args, src_addr)

    @make_method('/ray/server/add_factory_client_template', None)
    def rayServerAddFactoryClientTemplate(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "Cannot add to session because no session is loaded." )
            return
        
        signaler.server_add_factory_client_template.emit(path, args, src_addr)

    
    @make_method('/nsm/server/new', None)
    def nsmServerNew(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not pathIsValid(args[0]):
            self.send(src_addr, "/error", path, ERR_CREATE_FAILED, "Invalid session name.")
            return
        
        signaler.server_new.emit(path, args, src_addr)
    
    @make_method('/ray/server/new_from_template', None)
    def rayServerNewFromTemplate(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        signaler.server_new_from_tp.emit(path, args, src_addr)
    
    @make_method('/nsm/server/save', None)
    def nsmServerSave(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to save.")
            return 0
        
        signaler.server_save.emit(path, args, src_addr)

    @make_method('/nsm/server/open', None)
    def nsmServerOpen(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        signaler.server_open.emit(path, args, src_addr)
            
    @make_method('/nsm/server/close', None)
    def nsmServerClose(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        if self.isOperationPending(src_addr, path):
            return
        
        if not  session.path:
            self.send(src_addr, "/error", path, ERR_NO_SESSION_OPEN, "No session to close.")
            return 0
        
        signaler.server_close.emit(path, args, src_addr)
        
    @make_method('/nsm/server/quit', None)
    def nsmServerQuit(self, path, args):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        sys.exit(0)
    
    ###Additional Ray features###
    
    @make_method('/ray/server/openfolder', None)
    def rayServerOpenFolder(self, path, args):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        if  session.path:
            subprocess.Popen(['xdg-open',  session.path])
    
    @make_method('/ray/server/startallclients', None)
    def rayServerStartAllClients(self, path, args):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        signaler.server_startallclients.emit()
    
    @make_method('/ray/server/stopallclients', None)
    def rayServerStopAllClients(self, path, args):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        signaler.server_stopallclients.emit()
        
    @make_method('/ray/server/reorder_clients', None)
    def rayServerReorderClients(self, path, args):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        signaler.server_reorder_clients.emit(path, args)
        
    @make_method('/ray/server/change_root', None)
    def rayServerChangeRoot(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        if session.path:
            self.send(src_addr, '/reply', "Can't change session_root while a session is running")
            return
        
        session.setRoot(args[0])
    
    @make_method('/ray/server/list_path', None)
    def rayServerListPath(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        exec_list = []
        tmp_exec_list = []
        
        pathlist = os.getenv('PATH').split(':')
        for path in pathlist:
            if os.path.isdir(path):
                listexe = os.listdir(path)
                for exe in listexe:
                    fullexe = path + '/' + exe
                    if os.path.isfile(fullexe) and os.access(fullexe, os.X_OK) and not exe in exec_list:
                        exec_list.append(exe)
                        tmp_exec_list.append(exe)
                        if len(tmp_exec_list) == 100:
                            self.send(src_addr, '/reply_path', *tmp_exec_list)
                            tmp_exec_list.clear()
        
        if tmp_exec_list:
            self.send(src_addr, '/reply_path', *tmp_exec_list)
            
    @make_method('/ray/server/list_session_templates', None)
    def rayServerListSessionTemplates(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        template_list = []
        
        all_files = os.listdir(session_template_root)
        for file in all_files:
            if os.path.isdir("%s/%s" % (session_template_root, file)):
                template_list.append(file)
                
                if len(template_list) == 100:
                    self.send(src_addr, '/reply_session_templates', *template_list)
                    template_list.clear()
                    
        if template_list:
            self.send(src_addr, '/reply_session_templates', *template_list) 
    
    
    @make_method('/ray/server/list_user_client_templates', None)
    def rayServerListUserClientTemplates(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        self.listClientTemplates(src_addr, False)
    
    @make_method('/ray/server/list_factory_client_templates', None)
    def rayServerListFactoryClientTemplates(self, path, args, types, src_addr):
        ifDebug('serverOSC::ray-deamon_receives %s, %s' % (path, str(args)))
        
        self.listClientTemplates(src_addr, True)
    
    def isOperationPending(self, src_addr, path):
        if session.process_order:
            self.send(src_addr, "/error", path, ERR_OPERATION_PENDING, "An operation pending.")
            return True
        
        return False
        
    def sendGui(self, *args):
        for gui_addr in self.gui_list:
            self.send(gui_addr, *args)
    
    def sendClientStatusToGui(self, client):
        self.sendGui("/ray/gui/client/status", client.client_id, client.status)
            
    def setServerStatus(self, server_status):
        self.server_status = server_status
        self.sendGui("/ray/server_status", server_status)
    
    def listClientTemplates(self, src_addr, factory=False):
        template_list = []
        tmp_template_list = []
        
        templates_root    = client_template_local_root
        response_osc_path = '/reply_user_client_templates'
        
        if factory:
            templates_root    = client_template_factory_root
            response_osc_path = '/reply_factory_client_templates'
        
        
        templates_file = "%s/%s" % (templates_root, 'client_templates.xml')
        
        if not os.path.isfile(templates_file):
            return
        
        if not os.access(templates_file, os.R_OK):
            return
        
        file = open(templates_file)
        xml = QDomDocument()
        xml.setContent(file.read())
        file.close()
        
        content = xml.documentElement()
        
        if content.tagName() != "RAY-CLIENT-TEMPLATES":
            return
        
        node = content.firstChild()
        while not node.isNull():
            ct = node.toElement()
            tag_name = ct.tagName()
            if tag_name != 'Client-Template':
                node = node.nextSibling()
                continue
            
            template_name = ct.attribute('template-name')
            
            if not template_name or template_name in template_list:
                node = node.nextSibling()
                continue
            
            executable = ct.attribute('executable') 
            
            if not executable:
                node = node.nextSibling()
                continue
            
            try_exec_line = ct.attribute('try-exec')
            
            try_exec_list = []
            if try_exec_line:
                try_exec_list = ct.attribute('try-exec').split(';')
                
            try_exec_list.append(executable)
            try_exec_ok = True
            
            for try_exec in try_exec_list:
                path = shutil.which(try_exec)
                if not path:
                    try_exec_ok = False
                    break
            
            if not try_exec_ok:
                node = node.nextSibling()
                continue
            
            template_list.append("%s/%s" % (template_name, ct.attribute('icon') ))
            tmp_template_list.append("%s/%s" % (template_name, ct.attribute('icon') ))
            
            if len(tmp_template_list) == 100:
                self.send(src_addr, response_osc_path, *tmp_template_list)
                template_list.clear()
        
            node = node.nextSibling()
        
        if tmp_template_list:
            self.send(src_addr, response_osc_path, *tmp_template_list)
    
    def announceGui(self, url, is_reply):
        gui_addr = Address(url)
        
        if is_reply:
            self.send(gui_addr, "/ray/gui/gui_announce", "hi" )
        else:
            self.send(gui_addr, "/ray/gui/server_announce", "hi" )
        
        self.send(gui_addr, "/ray/server_status", self.server_status)
        self.send(gui_addr, "/ray/gui/session/name",  session.name,  session.path)
        
        for client in session.clients:
            self.send(  gui_addr, 
                        '/ray/gui/client/new',
                        client.client_id, 
                        client.executable_path, 
                        client.name, 
                        client.prefix_mode, 
                        client.project_path,
                        client.label,
                        client.icon,
                        client.capabilities)
            
            self.send(gui_addr, "/ray/gui/client/status", client.client_id,  client.status)
        
        self.gui_list.append(gui_addr)
        MESSAGE("Registered with GUI")
        
    
if __name__ == '__main__':
    session_root = "%s/NSM Sessions" % os.getenv('HOME')
    
    #Add RaySession/src to $PATH to can use ray-proxy and maybe future executables after make, whitout install
    os.environ['PATH']="%s:%s" % (os.path.dirname(sys.argv[0]), os.environ['PATH'])
    
    parser = argparse.ArgumentParser()
    parser.add_argument('--session-root', '-r', help='set root folder for sessions', default=session_root)
    parser.add_argument('--osc-port', type=int, default=16187, help='select OSC port for the deamon')
    parser.add_argument('--gui-url', type=getLibloAddress, help=argparse.SUPPRESS)
    parser.add_argument('--debug','-d',  action='store_true', help='see all OSC messages')
    parser.add_argument('-v', '--version', action='version', version=VERSION)
    parsed_args = parser.parse_args()
    
    debug        = parsed_args.debug
    session_root = parsed_args.session_root
    osc_num      = parsed_args.osc_port
    gui_address  = parsed_args.gui_url
    
    signal.signal(signal.SIGINT,  signalHandler)
    signal.signal(signal.SIGTERM, signalHandler)
    
    app = QCoreApplication(sys.argv)
    app.setApplicationName("RaySession")
    #app.setApplicationVersion(VERSION)
    app.setOrganizationName("RaySession")
    settings = QSettings()
    known_as_non_active = settings.value('deamon/non_active_list', [])
    
    app_config_path = "%s/%s" % (QStandardPaths.writableLocation(QStandardPaths.ConfigLocation), app.organizationName())
    session_template_root = "%s/%s" % (app_config_path, 'session_templates')
    client_template_local_root = "%s/%s" % (app_config_path, 'client_templates')
    client_template_factory_root = "%s/client_templates" % os.path.dirname(os.path.dirname(sys.argv[0]))
    
    ### Translation process
    locale = QLocale.system().name()
    appTranslator = QTranslator()
    if appTranslator.load("%s/locale/raysession_%s" % (os.path.dirname(os.path.dirname(sys.argv[0])), locale)):
        app.installTranslator(appTranslator)
    _translate = app.translate
    init_translation(_translate)
    
    timer = QTimer()
    timer.setInterval(200)
    timer.timeout.connect(lambda: None)
    timer.start()
    
    signaler = Signaler()
    session  = SignaledSession()
    session.setRoot(session_root)
    
    server = OscServerThread(getFreeOscPort(osc_num))
    server.start()
    
    if gui_address:
        server.announceGui(gui_address.url, False)
        
    MESSAGE(server.url)
    
    app.exec()
    
    settings.setValue('deamon/non_active_list', known_as_non_active)
    settings.sync()
    
    server.stop()
    del server
    del session
    del app
    
