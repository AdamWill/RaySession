#!/usr/bin/python3 -u


from PyQt5.QtWidgets import QApplication, QMainWindow, QMenu, QInputDialog, QBoxLayout, QListWidgetItem, QFrame, QDialog, QDialogButtonBox, QFileDialog, QMessageBox, QCompleter, QAction, QToolButton, QAbstractItemView, QLabel, QLineEdit
from PyQt5.QtGui     import QIcon , QCursor, QPalette, QPixmap, QFontDatabase
from PyQt5.QtCore    import QTimer, QProcess, pyqtSignal, pyqtSlot, QObject, QSize, Qt, QSettings, qDebug, QLocale, QTranslator
from PyQt5.QtXml import QDomDocument

import sys
from liblo import *
import subprocess
from signal import signal, SIGINT, SIGTERM, SIGUSR1, SIGUSR2
import signal
import unicodedata
import os
import socket
import time
import argparse

#import UIs
import ui_raysession
import ui_client_slot
import ui_open_session
import ui_new_session
import ui_save_template_session
import ui_nsm_open_info
import ui_abort_session
import ui_about_raysession
import ui_add_application
import ui_new_executable
import ui_error_dialog
import ui_quit_app
import ui_client_properties
import ui_stop_client
import ui_abort_copy
import ui_client_trash
import ui_daemon_url

import resources_rc

from shared import *
from list_widget_clients import *
import nsm_client

#for use on network session under NSM
ERR_NO_ERROR               =  0
ERR_DAEMON_NO_ANNOUNCE     = -1
ERR_DAEMON_NOT_OFF         = -2
ERR_DAEMON_WRONG_ROOT      = -3
ERR_DAEMON_NOT_NSM_LOCKED  = -4
ERR_DAEMON_WRONG_VERSION   = -5 


def str2bool(v):
    return bool(v.lower() == 'true')

def remove_accents(input_str):
    nfkd_form = unicodedata.normalize('NFKD', input_str)
    return u"".join([c for c in nfkd_form if not unicodedata.combining(c)]).lower()    

def signalHandler(sig, frame):
    if sig in (SIGINT, SIGTERM):
        if ray_daemon.launched_before:
            if under_nsm:
                if session.server_status != SERVER_STATUS_OFF:
                    serverOSC.abortSession()
                MainUI.terminate_request = True
            else:
                app.quit()
            return
        
        MainUI.terminate_request = True
        ray_daemon.stop()

def changeRootFolder(parent_window):
    #this function is the only one that takes cares of files present on system. 
    #In a perfect world, this should be done in ray-daemon.
    #But it's more user friendly to use a file picker child of raysession window
    #and if ray-daemon is launched before, with a different session root, 
    #then it gives the advantage to not change the default root.
    
    global default_folder
    root_folder = QFileDialog.getExistingDirectory(parent_window, 
                                                  _translate("root_folder_dialogs", "Choose root folder for sessions"), 
                                                  default_folder, 
                                                  QFileDialog.ShowDirsOnly)
    
    #Security, kde dialogs sends $HOME if user type a folder path that doesn't already exists
    if os.environ['HOME'] and root_folder == os.environ['HOME']:
        return
    
    if root_folder:
        errorDialog = QMessageBox(QMessageBox.Critical, 
                                  _translate('root_folder_dialogs', 'unwritable dir'), 
                                  _translate('root_folder_dialogs', '<p>You have no permissions for %s,<br>choose another directory !</p>') % root_folder)
        
        if not os.path.exists(root_folder):
            try:
                os.makedirs(root_folder)
            except:
                errorDialog.exec()
                return
        
        if not os.access(root_folder, os.W_OK):
            errorDialog.exec()
            return
        
        default_folder = root_folder
        settings.setValue('default_folder', default_folder)
        
        serverOSC.toDaemon('/ray/server/change_root', root_folder)

class Session(object):
    def __init__(self):
        self.client_list     = []
        self.trashed_clients = []
        self.name            = None
        self.is_running      = False
        self.server_status   = SERVER_STATUS_OFF
        
        self.is_renameable = True
    
    def setRunning(self, bool):
        self.is_running = bool
        
    def isRunning(self):
        return bool(self.server_status != SERVER_STATUS_OFF)
    
    def updateServerStatus(self, server_status):
        self.server_status = server_status
    
    def setName(self, session_name):
        self.name = session_name
        
    def getClient(self, client_id):
        for client in self.client_list:
            if client.client_id == client_id:
                return client
        else:
            qDebug("session::getClient client %s not in client_list !!!" % client_id)
    
    def addClient(self, client_data):
        client = Client(client_data)
        self.client_list.append(client)
    
    def removeClient(self, client_id):
        client = self.getClient(client_id)
        if client:
            client.properties_dialog.close()
            self.client_list.remove(client)
            del client
    
    def updateClientProperties(self, client_data):
        client = self.getClient(client_data.client_id)
        if client:
            client.updateClientProperties(client_data)
    
    def updateClientStatus(self, client_id, status):
        client = self.getClient(client_id)
        if client:
            client.setStatus(status)
            
    def setClientHasGui(self, client_id):
        client = self.getClient(client_id)
        if client:
            client.setGuiEnabled()
        
    def setClientGuiState(self, client_id, state):
        client = self.getClient(client_id)
        if client:
            client.setGuiState(state)
        
    def setClientDirtyState(self, client_id, bool_dirty):
        client = self.getClient(client_id)
        if client:
            client.setDirtyState(bool_dirty)
    
    def switchClient(self, old_client_id, new_client_id):
        client = self.getClient(old_client_id)
        if client:
            client.switch(new_client_id)
    
    def clientIsStillRunning(self, client_id):
        client = self.getClient(client_id)
        if client:
            client.allowKill()
    
    def removeAllClients(self):
        self.client_list.clear()
        
    def reOrderClients(self, client_id_list):
        new_client_list = []
        for client_id in client_id_list:
            client = self.getClient(client_id)
            
            if not client:
                return
            
            new_client_list.append(client)
        
        self.client_list.clear()
        MainUI.reCreateListWidget()
        
        self.client_list = new_client_list
        for client in self.client_list:
            client.reCreateWidget()
            client.widget.updateStatus(client.status)
        
class Client(object):
    def __init__(self, client_data, trashed=False):
        self.client_id       = client_data.client_id
        self.executable_path = client_data.executable_path
        self.arguments       = client_data.arguments
        self.name            = client_data.name
        self.prefix_mode     = client_data.prefix_mode
        self.project_path    = client_data.project_path
        self.label           = client_data.label
        self.icon_name       = client_data.icon
        self.capabilities    = client_data.capabilities
        self.check_last_save = client_data.check_last_save
        
        
        self.status      = CLIENT_STATUS_STOPPED
        self.previous_status = CLIENT_STATUS_STOPPED
        self.hasGui      = False
        self.gui_visible = False
        self.has_dirty   = False
        self.dirty_state = True
        self.last_save   = time.time()
        
        self.widget      = MainUI.createClientWidget(self)
        self.properties_dialog = ClientPropertiesDialog(MainUI, self)
        
    def setStatus(self, status):
        self.previous_status = self.status
        self.status = status
        
        if not self.has_dirty:
            if self.status == CLIENT_STATUS_READY and self.previous_status in (CLIENT_STATUS_OPEN, CLIENT_STATUS_SAVE):
                self.last_save = time.time()
        
        self.widget.updateStatus(status)
        
    def setGuiEnabled(self):
        self.hasGui = True
        self.widget.showGuiButton()
        
    def setGuiState(self, state):
        self.gui_state = state
        self.widget.setGuiState(state)
    
    def setDirtyState(self, bool_dirty):
        self.has_dirty = True
        self.dirty_state = bool_dirty
        self.widget.setDirtyState(bool_dirty)
        
    def setProgress(self, progress):
        self.widget.setProgress(progress)
    
    def switch(self, new_client_id):
        self.client_id = new_client_id
        self.widget.updateClientData()
        
    def allowKill(self):
        self.widget.allowKill()
        
    def updateClientProperties(self, client_data):
        self.executable_path = client_data.executable_path
        self.arguments       = client_data.arguments
        self.name            = client_data.name
        self.prefix_mode     = client_data.prefix_mode
        self.project_path    = client_data.project_path
        self.label           = client_data.label
        self.icon_name       = client_data.icon
        self.capabilities    = client_data.capabilities
        self.check_last_save = client_data.check_last_save
        self.widget.updateClientData()
   
    def prettierName(self):
        if self.label:
            return self.label
        
        if self.name:
            return self.name
        
        return self.executable_path
   
    def sendPropertiesToDaemon(self):
        serverOSC.toDaemon('/ray/gui/client/update_properties', 
                           self.client_id,
                           self.executable_path,
                           self.arguments,
                           self.name, 
                           self.prefix_mode, 
                           self.project_path, 
                           self.label, 
                           self.icon_name, 
                           self.capabilities,
                           int(self.check_last_save))
        
    def showPropertiesDialog(self):
        self.properties_dialog.updateContents()
        self.properties_dialog.show()
        self.properties_dialog.activateWindow()
    
    def reCreateWidget(self):
        del self.widget
        self.widget = MainUI.createClientWidget(self)
        self.widget.updateClientData()
        
        if self.hasGui:
            self.setGuiEnabled()
        
    def hasBeenRecentlySaved(self):
        if (time.time() - self.last_save) >= 60: #last save more than 60 seconds ago
            return False
        
        return True

class TrashedClient(object):
    def __init__(self, client_data, menu_action):
        self.data        = client_data
        self.menu_action = menu_action
    
class Signaler(QObject):
    daemon_announce     = pyqtSignal(Address, str, int, int, str)
    daemon_announce_ok  = pyqtSignal()
    daemon_nsm_locked   = pyqtSignal(bool)
    server_copying      = pyqtSignal(bool)
    new_message_sig     = pyqtSignal(str)
    session_name_sig    = pyqtSignal(str, str)
    session_renameable  = pyqtSignal(bool)
    error_message       = pyqtSignal(list)
    
    new_client_added       = pyqtSignal(ClientData)
    new_client_stopped     = pyqtSignal(str, str)
    client_removed         = pyqtSignal(str)
    client_status_changed  = pyqtSignal(str, int)
    client_switched        = pyqtSignal(str, str)
    client_progress        = pyqtSignal(str, float)
    client_dirty_sig       = pyqtSignal(str, bool)
    client_has_gui         = pyqtSignal(str)
    client_gui_visible_sig = pyqtSignal(str, int)
    client_still_running   = pyqtSignal(str)
    client_updated         = pyqtSignal(ClientData)
    add_session_to_list    = pyqtSignal(str)
    new_executable         = pyqtSignal(list)
    session_template_found = pyqtSignal(list)
    user_client_template_found    = pyqtSignal(list)
    factory_client_template_found = pyqtSignal(list)
    server_progress        = pyqtSignal(float)
    server_status_changed  = pyqtSignal(int)
    clients_reordered      = pyqtSignal(list)
    opening_session    = pyqtSignal()
    
    trash_add    = pyqtSignal(ClientData)
    trash_remove = pyqtSignal(str)
    trash_clear  = pyqtSignal()
    trash_dialog = pyqtSignal(str)
    
    daemon_url_request = pyqtSignal(int, str)
    daemon_url_changed = pyqtSignal(str)
    
    def __init__(self):
        QObject.__init__(self)
        
    @pyqtSlot()
    def restoreClient(self):
        try:
            client_id = str(self.sender().data())
        except:
            return
        
        self.trash_dialog.emit(client_id)
        

class OSCServerT(ServerThread):
    def __init__(self):
        ServerThread.__init__(self)
        #signaler = OscSignaler()
    
    @make_method('/error', None)
    def errorFromServer(self, errorpath, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (errorpath, str(args)))
        
        signaler.error_message.emit(args)
    
    @make_method('/reply', 'ss')
    def receiveFromServer(self, path_reply, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path_reply, str(args)))
        
        if args[0] == '/nsm/server/list':
            session_name = args[1]
            signaler.add_session_to_list.emit(session_name)
    
            
    @make_method('/reply_path', None)
    def replyPath(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        if not areTheyAllString(args):
            return
        
        signaler.new_executable.emit(args)
    
    @make_method('/reply_session_templates', None)
    def replySessionTemplates(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        if not areTheyAllString(args):
            return
        
        #if nsm_out_daemon:
            
        
        signaler.session_template_found.emit(args)
    
    @make_method('/reply_user_client_templates', None)
    def replyUserClientTemplates(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        if not areTheyAllString(args):
            return
        
        signaler.user_client_template_found.emit(args)
    
    @make_method('/reply_factory_client_templates', None)
    def replyFactoryClientTemplates(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        if not areTheyAllString(args):
            return
        
        signaler.factory_client_template_found.emit(args)
    
        
    @make_method('/ray/gui/daemon_announce', 'siis')
    def serverAnnounce(self, path, args, types, src_addr):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        if ray_daemon.isAnnounced():
            return
        
        version, server_status, is_nsm_locked, session_root = args
        
        signaler.daemon_announce.emit(src_addr, version, server_status, is_nsm_locked, session_root)
    
    @make_method('/ray/gui/daemon_disannounce', '')
    def serverDisannounce(self, path, args, types, src_addr):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        pass
    
    @make_method('/ray/gui/daemon_nsm_locked', 'i')
    def daemonNsmLocked(self, path, args, types, src_addr):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        nsm_locked = bool(args[0])
        
        signaler.daemon_nsm_locked.emit(nsm_locked)
    
    @make_method('/ray/gui/server/message', 's')
    def serverMessage(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
            
        message = args[0]
        signaler.new_message_sig.emit(message)
    
    @make_method('/ray/gui/server/copying', 'i')
    def guiServerCopying(self, path, args):
        copying = bool(int(args[0]))
        
        signaler.server_copying.emit(copying)
    
    @make_method('/ray/gui/session/name', 'ss')
    def guiSessionName(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
            
        name1, name2 = args
        signaler.session_name_sig.emit(name1, name2)
    
    @make_method('/ray/gui/session/renameable', 'i')
    def guiSessionRenameable(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        renameable = bool(args[0])
        signaler.session_renameable.emit(renameable)
    
    @make_method('/ray/gui/client/new', 'ssssissssi')
    def newClientFromServer(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        client_data = ClientData(*args)
        signaler.new_client_added.emit(client_data)
    
    @make_method('/ray/gui/client/update', 'ssssissssi')
    def updateClientProperties(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        client_data = ClientData(*args)
        signaler.client_updated.emit(client_data)
        
        
    @make_method('/ray/gui/client/status', 'si')
    def guiClientStatus(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
            
        client_id, status = args
            
        if status == CLIENT_STATUS_REMOVED:
            signaler.client_removed.emit(client_id)
            return
        
        signaler.client_status_changed.emit(client_id, status)
        
    @make_method('/ray/gui/client/switch', 'ss')
    def guiClientSwitch(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        old_client_id, new_client_id = args
        
        signaler.client_switched.emit(old_client_id, new_client_id)
        
    @make_method('/ray/gui/client/progress', 'sf')
    def guiClientProgress(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        client_id, progress = args
        
        signaler.client_progress.emit(client_id, progress)
        
    @make_method('/ray/gui/client/dirty', 'si')
    def guiClientDirty(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
            
        client_id, dirty_num = args
        bool_dirty = bool(dirty_num)
        
        signaler.client_dirty_sig.emit(client_id, bool_dirty)
        
    @make_method('/ray/gui/client/has_optional_gui', 's')
    def guiClientHasOptionalGui(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
            
        client_id = args[0]
        signaler.client_has_gui.emit(client_id)
        
    @make_method('/ray/gui/client/gui_visible', 'si')
    def guiClientGuiVisible(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
            
        client_id, state = args
        signaler.client_gui_visible_sig.emit(client_id, bool(state))
      
    @make_method('/ray/gui/client/still_running', 's')
    def guiClientStillRunning(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
            
        client_id = args[0]
        signaler.client_still_running.emit(client_id)
        
    @make_method('/ray/gui/server_progress', 'f')
    def guiServerProgress(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        progress = args[0]
        signaler.server_progress.emit(progress)
    
    @make_method('/ray/server_status', 'i')
    def rayServerStatus(self, path, args):
        server_status = args[0]
        signaler.server_status_changed.emit(server_status)
    
    @make_method('/ray/opening_nsm_session', None)
    def rayOpeningNsmSession(self, path, args):
        signaler.opening_session.emit()
    
    @make_method('/ray/gui/clients_reordered', None)
    def rayGuiReorderClients(self, path, args):
        for arg in args:
            if not type(arg) is str:
                return
        
        signaler.clients_reordered.emit(args)
    
    @make_method('/ray/gui/trash/add', 'ssssissssi')
    def rayGuiTrashAdd(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        client_data = ClientData(*args)
        signaler.trash_add.emit(client_data)
        
    @make_method('/ray/gui/trash/remove', 's')
    def rayGuiTrashRemove(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        client_id = args[0]
        signaler.trash_remove.emit(client_id)
        
    @make_method('/ray/gui/trash/clear', '')
    def rayGuiTrashClear(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        signaler.trash_clear.emit()
    
    def toDaemon(self, *args):
        self.send(ray_daemon.address, *args)
    
    def announce(self):
        ifDebug('serverOSC::raysession_sends announce')
        
        nsm_mode = NSM_MODE_NO_NSM
        
        if under_nsm:
            if nsm_out_daemon:
                nsm_mode = NSM_MODE_NETWORK
            else:
                nsm_mode = NSM_MODE_CHILD
        
        self.send(ray_daemon.address, '/ray/gui/gui_announce', VERSION, int(under_nsm))
    
    def disannounce(self, src_addr):
        ifDebug('serverOSC::raysession_sends disannounce')
        self.send(src_addr, '/ray/gui/gui_disannounce')
    
    def startListSession(self):
        ifDebug('serverOSC::raysession_sends list sessions')
        self.toDaemon('/nsm/server/list')
    
    def newSession(self, session_name):
        ifDebug('serverOSC::raysession_sends new session %s' % remove_accents(session_name))
        self.toDaemon('/nsm/server/new', session_name)
    
    def newSessionFromTemplate(self, session_name, template_name):
        self.toDaemon('/ray/server/new_from_template', session_name, template_name)
    
    def openSession(self, session_name, session_template=''):
        ifDebug('serverOSC::raysession_sends open session %s' % remove_accents(session_name))
        if session_template:
            self.toDaemon('/nsm/server/open', session_name, session_template)
        else:
            self.toDaemon('/nsm/server/open', session_name)
        
    def saveSession(self):
        ifDebug('serverOSC::raysession_sends save session')
        self.toDaemon('/nsm/server/save')
        
    def closeSession(self):
        ifDebug('serverOSC::raysession_sends close session')
        self.toDaemon('/nsm/server/close')
        
    def abortSession(self):
        ifDebug('serverOSC::raysession_sends abort session')
        self.toDaemon('/nsm/server/abort')
        
    def duplicateSession(self, session_name):
        ifDebug('serverOSC::raysession_sends duplication session')
        self.toDaemon('/nsm/server/duplicate', session_name)
    
    def saveTemplateSession(self, session_template_name):
        ifDebug('serverOSC::raysession_sends save template session')
        self.toDaemon('/ray/server/save_session_template', session_template_name)    
    
    def startClient(self, client_id):
        ifDebug('serverOSC::raysession_sends start client %s' % client_id)
        self.toDaemon('/ray/gui/client/resume', client_id)
        
    def stopClient(self, client_id):
        ifDebug('serverOSC::raysession_sends stop client %s' % client_id)
        self.toDaemon('/ray/gui/client/stop', client_id)
        
    def killClient(self, client_id):
        ifDebug('serverOSC::raysession_sends stop client %s' % client_id)
        self.toDaemon('/ray/gui/client/kill', client_id)
        
    def saveClient(self, client_id):
        ifDebug('serverOSC::raysession_sends save client %s' % client_id)
        self.toDaemon('/ray/gui/client/save', client_id)
        
    def removeClient(self, client_id):
        ifDebug('serverOSC::raysession_sends remove client %s' % client_id)
        self.toDaemon('/ray/gui/client/remove', client_id)
    
    def showClientOptionalGui(self, client_id):
        ifDebug('serverOSC::raysession_sends show optional GUI %s' % client_id)
        self.toDaemon('/ray/gui/client/show_optional_gui', client_id)
        
    def hideClientOptionalGui(self, client_id):
        ifDebug('serverOSC::raysession_sends hide optional GUI %s' % client_id)
        self.toDaemon('/ray/gui/client/hide_optional_gui', client_id)
        
    def saveClientTemplate(self, client_id, template_name):
        self.toDaemon('/ray/gui/client/save_as_template', client_id, template_name)
        
    def addClient(self, program_name):
        ifDebug('serverOSC::raysession_sends add Client %s' % program_name)
        self.toDaemon('/nsm/server/add', program_name)
        
    def changeClientOrder(self, client_ids_list):
        self.toDaemon('/ray/server/reorder_clients', *client_ids_list)
        
    def abortCopy(self):
        self.toDaemon('/ray/server/abort_copy')
    #def 

class RayIcon(QIcon):
    def __init__(self, icon_name, dark=False):
        QIcon.__init__(self)
        breeze = 'breeze-dark' if dark else 'breeze'
        self.addPixmap(QPixmap(':scalable/%s/%s' % (breeze, icon_name)), QIcon.Normal, QIcon.Off)
        self.addPixmap(QPixmap(':scalable/%s/disabled/%s' % (breeze, icon_name)), QIcon.Disabled, QIcon.Off)

class MainWindow(QMainWindow):
    def __init__(self):
        QMainWindow.__init__(self)
        self.ui = ui_raysession.Ui_MainWindow()
        self.ui.setupUi(self)
        
        self.mouse_is_inside   = False
        self.terminate_request = False
        
        #timer for keep focus while client opening
        self.timer_raisewin = QTimer()
        self.timer_raisewin.setInterval(50)
        self.timer_raisewin.timeout.connect(self.raiseWindow)
        
        #timer for flashing effect of 'open' status
        self.timer_flicker_open = QTimer()
        self.timer_flicker_open.setInterval(400)
        self.timer_flicker_open.timeout.connect(self.flashOpen)
        self.flash_open_list = []
        self.flash_open_bool = False
        
        self.server_copying = False
        
        #set options with config file, restore geometry
        self.keep_focus = settings.value('keepfocus', True, type=bool)
        self.ui.actionKeepFocus.setChecked(self.keep_focus)
        if settings.value('MainWindow/geometry'):
            self.restoreGeometry(settings.value('MainWindow/geometry'))
        if settings.value('MainWindow/WindowState'):
            self.restoreState(settings.value('MainWindow/WindowState'))
        self.ui.actionShowMenuBar.activate(settings.value('MainWindow/ShowMenuBar', False, type=bool))
        
        #set default action for tools buttons
        self.ui.closeButton.setDefaultAction(self.ui.actionCloseSession)
        self.ui.toolButtonSaveSession.setDefaultAction(self.ui.actionSaveSession)
        self.ui.toolButtonAbortSession.setDefaultAction(self.ui.actionAbortSession)
        self.ui.toolButtonDuplicateSession.setDefaultAction(self.ui.actionDuplicateSession)
        self.ui.toolButtonSaveTemplateSession.setDefaultAction(self.ui.actionSaveTemplateSession)
        self.ui.toolButtonFileManager.setDefaultAction(self.ui.actionOpenSessionFolder)
        self.ui.toolButtonAddApplication.setDefaultAction(self.ui.actionAddApplication)
        self.ui.toolButtonAddExecutable.setDefaultAction(self.ui.actionAddExecutable)
        
        #connect actions
        self.ui.actionNewSession.triggered.connect(self.createNewSession)
        self.ui.actionOpenSession.triggered.connect(self.openSession)
        self.ui.actionQuit.triggered.connect(self.quitApp)
        self.ui.actionSaveSession.triggered.connect(self.saveSession)
        self.ui.actionCloseSession.triggered.connect(self.closeSession)
        self.ui.actionAbortSession.triggered.connect(self.abortSession)
        self.ui.actionRenameSession.triggered.connect(self.renameSessionAction)
        self.ui.actionDuplicateSession.triggered.connect(self.duplicateSession)
        self.ui.actionSaveTemplateSession.triggered.connect(self.saveTemplateSession)
        self.ui.actionOpenSessionFolder.triggered.connect(self.openFileManager)
        self.ui.actionAddApplication.triggered.connect(self.addApplication)
        self.ui.actionAddExecutable.triggered.connect(self.addExecutable)
        self.ui.actionKeepFocus.toggled.connect(self.toggleKeepFocus)
        self.ui.actionAboutRaySession.triggered.connect(self.aboutRaySession)
        self.ui.actionAboutQt.triggered.connect(app.aboutQt)
        
        self.ui.lineEditServerStatus.copyAborted.connect(self.abortCopy)
        self.ui.stackedWidgetSessionName.name_changed.connect(self.renameSession)
        
        #set control menu
        self.controlMenu = QMenu()
        self.controlMenu.addAction(self.ui.actionShowMenuBar)
        self.controlMenu.addAction(self.ui.actionToggleShowMessages)
        self.controlMenu.addSeparator()
        self.controlMenu.addAction(self.ui.actionKeepFocus)
        
        self.controlToolButton = self.ui.toolBar.widgetForAction(self.ui.actionControlMenu)
        self.controlToolButton.setPopupMode(QToolButton.InstantPopup)
        self.controlToolButton.setMenu(self.controlMenu)
        
        self.ui.toolButtonControl2.setPopupMode(QToolButton.InstantPopup)
        self.ui.toolButtonControl2.setMenu(self.controlMenu)
        
        #set trash menu
        self.trashMenu = QMenu()
        self.ui.trashButton.setPopupMode(QToolButton.InstantPopup)
        self.ui.trashButton.setMenu(self.trashMenu)
        
        #connect OSC signals from nsm
        signaler.new_client_added.connect(self.serverAddsClient)
        signaler.client_removed.connect(self.serverRemovesClient)
        signaler.client_status_changed.connect(self.serverUpdatesClientStatus)
        signaler.client_has_gui.connect(self.serverSetsClientHasGui)
        signaler.client_gui_visible_sig.connect(self.serverSetsClientGuiState)
        signaler.client_dirty_sig.connect(self.serverSetsClientDirtyState)
        signaler.client_switched.connect(self.serverSwitchesClient)
        signaler.client_progress.connect(self.serverClientProgress)
        signaler.client_still_running.connect(self.serverStillRunningClient)
        signaler.client_updated.connect(self.serverUpdatesClientProperties)
        signaler.new_message_sig.connect(self.serverPrintsMessage)
        signaler.session_name_sig.connect(self.serverRenamesSession)
        signaler.session_renameable.connect(self.serverSessionRenameable)
        signaler.server_progress.connect(self.serverProgress)
        signaler.server_status_changed.connect(self.serverChangeServerStatus)
        signaler.server_copying.connect(self.serverCopying)
        signaler.error_message.connect(self.serverSendsError)
        signaler.opening_session.connect(self.serverOpensNsmSession)
        signaler.clients_reordered.connect(self.serverReorderClients)
        signaler.trash_add.connect(self.serverTrashAdd)
        signaler.trash_remove.connect(self.serverTrashRemove)
        signaler.trash_clear.connect(self.serverTrashClear)
        signaler.trash_dialog.connect(self.showClientTrashDialog)
        signaler.daemon_url_request.connect(self.showDaemonUrlWindow)
        signaler.daemon_nsm_locked.connect(self.setNsmLocked)
        
        self.connectListWidgetRequests()
        
        if app.palette().brush(2, QPalette.WindowText).color().lightness() > 128:
            self.ui.actionCloseSession.setIcon(RayIcon('window-close', dark=True))
            self.ui.actionAbortSession.setIcon(RayIcon('list-remove', dark=True))
            self.ui.toolButtonSaveSession.setIcon(RayIcon('document-save', dark=True))
        
        self.setNsmLocked(under_nsm)
        
        
        #disable "keep focus" if daemon is not on this machine (it takes no sense in this case)
        if not ray_daemon.is_local:
            self.ui.actionKeepFocus.setChecked(False)
            self.ui.actionKeepFocus.setEnabled(False)
            
    def connectListWidgetRequests(self):
        #connect the listWidget signals to OSC server
        self.ui.listWidget.orderChanged.connect(serverOSC.changeClientOrder)
        self.ui.listWidget.clientStartRequest.connect(serverOSC.startClient)
        self.ui.listWidget.clientStopRequest.connect(self.clientStopRequest)
        self.ui.listWidget.clientKillRequest.connect(serverOSC.killClient)
        self.ui.listWidget.clientSaveRequest.connect(serverOSC.saveClient)
        self.ui.listWidget.clientRemoveRequest.connect(serverOSC.removeClient)
        self.ui.listWidget.clientAbortCopyRequest.connect(self.abortCopyClient)
        self.ui.listWidget.clientHideGuiRequest.connect(serverOSC.hideClientOptionalGui)
        self.ui.listWidget.clientShowGuiRequest.connect(serverOSC.showClientOptionalGui)
        self.ui.listWidget.clientSaveTemplateRequest.connect(self.newClientTemplate)
        self.ui.listWidget.clientPropertiesRequest.connect(self.openClientProperties)
    
    def createClientWidget(self, client):
        return self.ui.listWidget.createClientWidget(client)
    
    def reCreateListWidget(self):
        #this function shouldn't exist, it is a workaround for a bug with python-qt 
        #(when reorder widgets sometimes one widget is totally hidden until user resize the window)
        #It has to be modified when ui_raysession is modified
        self.ui.listWidget.clear()
        self.ui.verticalLayout.removeWidget(self.ui.listWidget)
        del self.ui.listWidget
        self.ui.listWidget = ListWidgetClients(self.ui.frameCurrentSession)
        self.ui.listWidget.setAcceptDrops(True)
        self.ui.listWidget.setStyleSheet("QFrame{border:none}")
        self.ui.listWidget.setDragEnabled(True)
        self.ui.listWidget.setDragDropMode(QAbstractItemView.InternalMove)
        self.ui.listWidget.setSelectionMode(QAbstractItemView.SingleSelection)
        self.ui.listWidget.setUniformItemSizes(True)
        self.ui.listWidget.setBatchSize(80)
        self.ui.listWidget.setObjectName("listWidget")
        self.ui.verticalLayout.addWidget(self.ui.listWidget)
        
        self.connectListWidgetRequests()
    
    def setNsmLocked(self, nsm_locked):
        self.ui.actionNewSession.setEnabled(not nsm_locked)
        self.ui.actionOpenSession.setEnabled(not nsm_locked)
        self.ui.actionDuplicateSession.setEnabled(not nsm_locked)
        self.ui.actionCloseSession.setEnabled(not nsm_locked)
        self.ui.actionAbortSession.setEnabled(not nsm_locked)
        
        self.ui.toolBar.setVisible(not nsm_locked)
        self.ui.toolButtonDuplicateSession.setVisible(not nsm_locked)
        self.ui.toolButtonAbortSession.setVisible(not nsm_locked)
        self.ui.closeButton.setVisible(not nsm_locked)
        self.ui.toolButtonControl2.setVisible(nsm_locked)
        
        self.ui.stackedWidgetSessionName.setEditable(nsm_locked and not nsm_out_daemon)
        self.ui.actionRenameSession.setEnabled(nsm_locked and not nsm_out_daemon)
            
    
    def hideMessagesDock(self):
        self.ui.dockWidgetMessages.setVisible(False)
    
    def openFileManager(self):
        serverOSC.toDaemon('/ray/server/openfolder')
    
    def raiseWindow(self):
        if self.mouse_is_inside:
            self.activateWindow()
    
    def toggleKeepFocus(self, bool):
        self.keep_focus = bool
        if ray_daemon.is_local:
            settings.setValue('keepfocus', self.keep_focus)
        if not bool:
            self.timer_raisewin.stop()
    
    def flashOpen(self):
        for client in session.client_list:
            if client.status == CLIENT_STATUS_OPEN:
                client.widget.flashIfOpen(self.flash_open_bool)
                
        self.flash_open_bool = not self.flash_open_bool
    
    def quitApp(self):
        
        if session.isRunning() and (under_nsm or not ray_daemon.launched_before):
        #if not ray_daemon.launched_before and session.isRunning():
            dialog = quitAppDialog(self)
            dialog.exec()
            if dialog.result():
                QApplication.quit()
            
        else:
            QApplication.quit()
    
    def newClientTemplate(self, client_id):
        dialog = SaveTemplateClientDialog(self)
        dialog.exec()
        if not dialog.result():
            return
        
        template_name = dialog.getTemplateName()
        
        serverOSC.saveClientTemplate(client_id, template_name)
    
    def openClientProperties(self, client_id):
        client = session.getClient(client_id)
        if not client:
            return
        
        client.showPropertiesDialog()
    
    def createNewSession(self):
        self.ui.dockWidgetMessages.setVisible(False)
        dialog = NewSessionDialog(self)
        dialog.exec()
        if not dialog.result():
            return
        
        session_name  = dialog.getSessionName()
        template_name = dialog.getTemplateName()
        
        settings.setValue('last_used_template', template_name)
        
        if template_name:
            serverOSC.newSessionFromTemplate(session_name, template_name)
        else:
            serverOSC.newSession(session_name)
      
    def openSession(self, action):
        dialog = OpenSessionDialog(self)
        dialog.exec()
        if not dialog.result():
            return
        
        if session.isRunning():
            settings.setValue('last_session', session.name)
            
        session_name = dialog.getSelectedSession()
        serverOSC.openSession(session_name)
    
    def closeSession(self):
        settings.setValue('last_session', session.name)
        serverOSC.closeSession()
        
    def abortSession(self):
        dialog = AbortSessionDialog(self)
        dialog.exec()
        
        if dialog.result():
            serverOSC.abortSession()
    
    def renameSessionAction(self):
        if not session.is_renameable:
            QMessageBox.information(self, 
                                    _translate("rename_session", "Rename Session"),
                                    _translate("rename_session", "<p>In order to rename current session,<br>please first stop all clients.<br>then, double click on session name.</p>"))
            return
        
        self.ui.stackedWidgetSessionName.toggleEdit()
    
    def duplicateSession(self):
        dialog = NewSessionDialog(self, True)
        dialog.exec()
        if not dialog.result():
            return
        
        settings.setValue('last_session', session.name)
        
        session_name = dialog.getSessionName()
        serverOSC.duplicateSession(session_name)
       
    def saveTemplateSession(self):
        dialog = SaveTemplateSessionDialog(self)
        dialog.exec()
        if not dialog.result():
            return
        
        session_template_name = dialog.getTemplateName()
        serverOSC.saveTemplateSession(session_template_name)
    
    def aboutRaySession(self):
        dialog = AboutRaySessionDialog(self)
        dialog.exec()
    
    def saveSession(self):
        serverOSC.saveSession()
    
    def addApplication(self):
        if session.server_status in (SERVER_STATUS_CLOSE, SERVER_STATUS_OFF):
            return
        
        dialog = AddApplicationDialog(self)
        dialog.exec()
        dialog.saveCheckBoxes()
        
        if dialog.result():
            template_name = dialog.getSelectedTemplate()
            factory = dialog.isTemplateFactory(template_name)
            
            if factory:
                serverOSC.toDaemon('/ray/server/add_factory_client_template', template_name)
            else:
                serverOSC.toDaemon('/ray/server/add_user_client_template', template_name)
    
    def addExecutable(self):
        if session.server_status in (SERVER_STATUS_CLOSE, SERVER_STATUS_OFF):
            return
        
        dialog = newExecutableDialog(self)
        dialog.exec()
        if not dialog.result():
            return
        
        command = dialog.getExecutableSelected()
        proxy   = dialog.runViaProxy()
        
        if proxy:
            serverOSC.toDaemon('/ray/server/add_proxy', command)
        else:
            serverOSC.addClient(command)
    
    def clientStopRequest(self, client_id):
        client = session.getClient(client_id)
        if not client:
            return
        
        if client.status == CLIENT_STATUS_READY and client.check_last_save:
            if client.has_dirty:
                if client.dirty_state:
                    dialog = StopClientDialog(self, client_id)
                    dialog.exec()
                    if not dialog.result():
                        return
                    
            elif (time.time() - client.last_save) >= 60: #last save (or start) more than 60 seconds ago
                dialog = StopClientDialog(self, client_id)
                dialog.exec()
                if not dialog.result():
                    return
                
        serverOSC.stopClient(client_id)
    
    def abortCopy(self):
        if not self.server_copying:
            return
        
        if not session.server_status in (SERVER_STATUS_PRECOPY, SERVER_STATUS_COPY):
            return
        
        dialog = AbortServerCopyDialog(self)
        dialog.exec()
        
        if not dialog.result():
            return
        
        serverOSC.abortCopy()
    
    def abortCopyClient(self, client_id):
        if not self.server_copying:
            return
        
        client = session.getClient(client_id)
        if not client or not client.status in (CLIENT_STATUS_COPY, CLIENT_STATUS_PRECOPY):
            return
        
        dialog = AbortClientCopyDialog(self, client_id)
        dialog.exec()
        
        if not dialog.result():
            return
        
        serverOSC.abortCopy()
    
    def renameSession(self, new_session_name):
        serverOSC.toDaemon('/ray/server/rename', new_session_name)
    
    def showClientTrashDialog(self, client_id):
        for trashed_client in session.trashed_clients:
            if trashed_client.data.client_id == client_id:
                break
        else:
            return
        
        dialog = ClientTrashDialog(self, trashed_client.data)
        dialog.exec()
        if not dialog.result():
            return
        
        serverOSC.toDaemon('/ray/gui/trash/restore', client_id)
    
    def showDaemonUrlWindow(self, err_code, ex_url=''):
        dialog = DaemonUrlWindow(self, err_code, ex_url)
        dialog.exec()
        if not dialog.result():
            if under_nsm and ray_daemon.launched_before:
                app.quit()
            return
        
        new_url = dialog.getUrl()
        
        tried_urls = getListInSettings(settings, 'network/tried_urls')
        if not new_url in tried_urls:
            tried_urls.append(new_url)
            
        settings.setValue('network/tried_urls', tried_urls)
        
        signaler.daemon_url_changed.emit(new_url)
    
    ###FUNCTIONS RELATED TO SIGNALS FROM OSC SERVER#######
    
    def serverAddsClient(self, client_data):
        session.addClient(client_data)
    
    def serverRemovesClient(self, client_id):
        client = session.getClient(client_id)
        if client:
            self.ui.listWidget.removeClientWidget(client_id)
            session.removeClient(client_id)
    
    def serverSwitchesClient(self, old_client_id, new_client_id):
        session.switchClient(old_client_id, new_client_id)
    
    def serverClientProgress(self, client_id, progress):
        client = session.getClient(client_id)
        if client:
            client.setProgress(progress)
    
    def serverUpdatesClientProperties(self, client_data):
        session.updateClientProperties(client_data)
    
    def serverUpdatesClientStatus(self, client_id, status):
        session.updateClientStatus(client_id, status)
        
        #launch/stop flashing status if 'open'
        for client in session.client_list:
            if client.status == CLIENT_STATUS_OPEN:
                if not self.timer_flicker_open.isActive():
                    self.timer_flicker_open.start()
                break
        else:
            self.timer_flicker_open.stop()
        
        #launch/stop timer_raisewin if keep focus
        if self.keep_focus:
            for client in session.client_list:
                if client.status == CLIENT_STATUS_OPEN:
                    if not self.timer_raisewin.isActive():
                        self.timer_raisewin.start()
                    break
            else:
                self.timer_raisewin.stop()
                if status == CLIENT_STATUS_READY:
                    self.raiseWindow()
            
    def serverSetsClientHasGui(self, client_id):
        session.setClientHasGui(client_id)
        
    def serverSetsClientGuiState(self, client_id, state):
        session.setClientGuiState(client_id, state)
        
    def serverSetsClientDirtyState(self, client_id, bool_dirty):
        session.setClientDirtyState(client_id, bool_dirty)
    
    def serverStillRunningClient(self, client_id):
        session.clientIsStillRunning(client_id)
    
    def serverPrintsMessage(self, message):
        self.ui.textEditMessages.appendPlainText(time.strftime("%H:%M:%S") + '  ' + message)
    
    def serverRenamesSession(self, session_name, session_path):
        session.setName(session_name)
        
        if session_name:
            self.setWindowTitle('%s - %s' % (APP_TITLE, session_name))
            self.ui.stackedWidgetSessionName.setText(session_name)
        else:
            self.setWindowTitle(APP_TITLE)
            self.ui.stackedWidgetSessionName.setText(_translate('main view', 'No Session Loaded'))
     
    def serverSessionRenameable(self, renameable):
        session.is_renameable = renameable
        self.ui.stackedWidgetSessionName.setEditable(renameable and session.server_status == SERVER_STATUS_READY and not nsm_out_daemon)
     
    def serverSendsError(self, args):
        if not len(args) >= 3:
            return
        
        error_dialog = ErrorDialog(self, args)
        error_dialog.exec()
    
    def serverOpensNsmSession(self):
        if not settings.value('OpenNsmSessionInfo', True, type=bool):
            return
        
        dialog = OpenNsmSessionInfoDialog(self)
        dialog.exec()
    
    def serverReorderClients(self, client_id_list):
        session.reOrderClients(client_id_list)
    
    def serverProgress(self, progress):
        self.ui.lineEditServerStatus.setProgress(progress)
    
    def serverCopying(self, copying):
        self.server_copying = copying
        self.serverChangeServerStatus(session.server_status)
        
    def serverChangeServerStatus(self, server_status):
        session.updateServerStatus(server_status)
        print('server statuss szesez', server_status)
        self.ui.lineEditServerStatus.setText(serverStatusString(server_status))
        self.ui.frameCurrentSession.setEnabled(bool(server_status != SERVER_STATUS_OFF))
        
        if server_status == SERVER_STATUS_COPY:
            self.ui.actionSaveSession.setEnabled(False)
            self.ui.actionCloseSession.setEnabled(False)
            self.ui.actionAbortSession.setEnabled(False)
            return
        
        if server_status == SERVER_STATUS_PRECOPY:
            self.ui.actionSaveSession.setEnabled(False)
            self.ui.actionCloseSession.setEnabled(False)
            self.ui.actionAbortSession.setEnabled(True)
            self.ui.actionDuplicateSession.setEnabled(False)
            self.ui.actionSaveTemplateSession.setEnabled(False)
            self.ui.actionAddApplication.setEnabled(False)
            self.ui.actionAddExecutable.setEnabled(False)
            self.ui.actionOpenSessionFolder.setEnabled(True)
            return
            
        close_or_off = bool(server_status in (SERVER_STATUS_CLOSE, SERVER_STATUS_OFF))
        ready        = bool(server_status == SERVER_STATUS_READY)
        
        self.ui.actionSaveSession.setEnabled(ready)
        self.ui.actionCloseSession.setEnabled(ready)
        self.ui.actionAbortSession.setEnabled(not close_or_off)
        self.ui.actionDuplicateSession.setEnabled(not close_or_off)
        self.ui.actionRenameSession.setEnabled(ready)
        self.ui.actionSaveTemplateSession.setEnabled(not close_or_off)
        self.ui.actionAddApplication.setEnabled(not close_or_off)
        self.ui.actionAddExecutable.setEnabled(not close_or_off)
        self.ui.actionOpenSessionFolder.setEnabled(bool(server_status != SERVER_STATUS_OFF))
        
        self.ui.stackedWidgetSessionName.setEditable(ready and session.is_renameable)
        if under_nsm and not nsm_out_daemon and ready and session.is_renameable:
            self.ui.stackedWidgetSessionName.setOnEdit()
            
        
        if self.server_copying:
            self.ui.actionSaveSession.setEnabled(False)
            self.ui.actionCloseSession.setEnabled(False)
            
        if under_nsm:
            self.ui.actionNewSession.setEnabled(False)
            self.ui.actionOpenSession.setEnabled(False)
            self.ui.actionDuplicateSession.setEnabled(False)
            self.ui.actionCloseSession.setEnabled(False)
            self.ui.actionAbortSession.setEnabled(False)
        
        if server_status == SERVER_STATUS_OFF:
            print('server statuss offf')
            if self.terminate_request:
                print('okezork')
                app.quit()
    
    def serverTrashAdd(self, client_data):
        prettier_name = client_data.label if client_data.label else client_data.name
        
        act_x_trashed = self.trashMenu.addAction(QIcon.fromTheme(client_data.icon), prettier_name)
        act_x_trashed.setData(client_data.client_id)
        act_x_trashed.triggered.connect(signaler.restoreClient)
        
        trashed_client = TrashedClient(client_data, act_x_trashed)
        
        session.trashed_clients.append(trashed_client)
        self.ui.trashButton.setEnabled(True)
        
    def serverTrashRemove(self, client_id):
        for trashed_client in session.trashed_clients:
            if trashed_client.data.client_id == client_id:
                break
        else:
            return
        
        self.trashMenu.removeAction(trashed_client.menu_action)
        session.trashed_clients.remove(trashed_client)
        
        if not session.trashed_clients:
            self.ui.trashButton.setEnabled(False)
        
    def serverTrashClear(self):
        session.trashed_clients.clear()
        self.trashMenu.clear()
        self.ui.trashButton.setEnabled(False)
    
    
    def daemonCrash(self):
        QMessageBox.critical(self, _translate('errors', "daemon crash!"), _translate('errors', "ray-daemon crashed, sorry !"))
        app.quit()
    
    def saveWindowSettings(self):
        settings.setValue('MainWindow/geometry', self.saveGeometry())
        settings.setValue('MainWindow/WindowState', self.saveState())
        settings.setValue('MainWindow/ShowMenuBar', self.ui.menuBar.isVisible())
        settings.setValue('MainWindow/ShowMessages', self.ui.dockWidgetMessages.isVisible())
        settings.sync()
    
    #Reimplemented Functions
    
    def closeEvent(self, event):
        self.saveWindowSettings()
        
        self.quitApp()
        event.ignore()
    
    def leaveEvent(self, event):
        if self.isActiveWindow():
            self.mouse_is_inside = False
        QDialog.leaveEvent(self, event)
        
    def enterEvent(self, event):
        self.mouse_is_inside = True
        QDialog.enterEvent(self, event)

class ChildDialog(QDialog):
    def __init__(self, parent):
        QDialog.__init__(self, parent)
        signaler.server_status_changed.connect(self.serverStatusChanged)
        signaler.server_copying.connect(self.serverCopying)
        
        self.server_copying = parent.server_copying
        
    def serverStatusChanged(self, server_status):
        return
    
    def serverCopying(self, bool_copying):
        self.server_copying = bool_copying
        self.serverStatusChanged(session.server_status)
    
    def leaveEvent(self, event):
        if self.isActiveWindow():
            self.parent().mouse_is_inside = False
        QDialog.leaveEvent(self, event)
        
    def enterEvent(self, event):
        self.parent().mouse_is_inside = True
        QDialog.enterEvent(self, event)

class OpenSessionDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_open_session.Ui_DialogOpenSession()
        self.ui.setupUi(self)
        
        self.f_last_session_item = None
        
        self.ui.toolButtonFolder.clicked.connect(self.changeRootFolder)
        self.ui.sessionList.currentItemChanged.connect(self.currentItemChanged)
        self.ui.sessionList.setFocus(Qt.OtherFocusReason)
        self.ui.filterBar.textEdited.connect(self.updateFilteredList)
        self.ui.filterBar.updownpressed.connect(self.updownPressed)
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(False)
        
        self.ui.currentNsmFolder.setText(default_folder)
        
        signaler.add_session_to_list.connect(self.addSession)
        serverOSC.startListSession()
        
        if ray_daemon.launched_before:
            self.ui.toolButtonFolder.setVisible(False)
            self.ui.currentNsmFolder.setVisible(False)
            self.ui.labelNsmFolder.setVisible(False)
            
        self.server_will_accept = False
        self.has_selection      = False
        
        self.serverStatusChanged(session.server_status)
    
    def serverStatusChanged(self, server_status):
        self.ui.toolButtonFolder.setEnabled(bool(server_status == SERVER_STATUS_OFF))
        
        self.server_will_accept = bool(server_status in (SERVER_STATUS_OFF, SERVER_STATUS_READY) and not self.server_copying)
        self.preventOk()
        
    def addSession(self, session_name):
        if session_name == settings.value('last_session', type=str):
            self.f_last_session_item = QListWidgetItem(session_name)
            self.ui.sessionList.addItem(self.f_last_session_item)
            self.ui.sessionList.setCurrentItem(self.f_last_session_item)
        else:
            self.ui.sessionList.addItem(session_name)
        
        self.ui.sessionList.sortItems()
        
        if self.f_last_session_item:
            current_index = self.ui.sessionList.currentIndex()
            self.ui.sessionList.scrollTo(current_index)
        else:
            self.ui.sessionList.setCurrentRow(0)
        
    def updateFilteredList(self, filt):
        filter_text = self.ui.filterBar.displayText()
        
        #show all items
        for i in range(self.ui.sessionList.count()):
            self.ui.sessionList.item(i).setHidden(False)
            
        liist = self.ui.sessionList.findItems(filter_text, Qt.MatchContains)
        
        #hide all non matching items
        for i in range(self.ui.sessionList.count()):
            if self.ui.sessionList.item(i) not in liist:
               self.ui.sessionList.item(i).setHidden(True)
        
        #if selected item not in list, then select the first visible
        if not self.ui.sessionList.currentItem() or self.ui.sessionList.currentItem().isHidden():
            for i in range(self.ui.sessionList.count()):
                if not self.ui.sessionList.item(i).isHidden():
                    self.ui.sessionList.setCurrentRow(i)
                    break
              
              
        if not self.ui.sessionList.currentItem() or self.ui.sessionList.currentItem().isHidden():
            self.ui.filterBar.setStyleSheet("QLineEdit { background-color: red}")
            self.ui.sessionList.setCurrentItem(None)
        else:
            self.ui.filterBar.setStyleSheet("")
            self.ui.sessionList.scrollTo(self.ui.sessionList.currentIndex())
    
    def updownPressed(self, key):
        row = self.ui.sessionList.currentRow()
        if key == Qt.Key_Up:
            if row == 0:
                return
            row-=1
            while self.ui.sessionList.item(row).isHidden():
                if row == 0:
                    return
                row-=1
        elif key == Qt.Key_Down:
            if row == self.ui.sessionList.count() -1:
                return
            row+=1
            while self.ui.sessionList.item(row).isHidden():
                if row == self.ui.sessionList.count() -1:
                    return
                row+=1
        self.ui.sessionList.setCurrentRow(row)
    
    def currentItemChanged(self, item, previous_item):
        self.has_selection = bool(item)
        self.preventOk()
    
    def preventOk(self):
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(bool(self.server_will_accept and self.has_selection))
    
    def changeRootFolder(self):
        changeRootFolder(self)
        self.ui.currentNsmFolder.setText(default_folder)
        self.ui.sessionList.clear()
        serverOSC.startListSession()
            
    def getSelectedSession(self):
        if self.ui.sessionList.currentItem():
            return self.ui.sessionList.currentItem().text()

class NewSessionDialog(ChildDialog):
    def __init__(self, parent, duplicate_window = False):
        ChildDialog.__init__(self, parent)
        self.ui = ui_new_session.Ui_DialogNewSession()
        self.ui.setupUi(self)
        
        self.is_duplicate = bool(duplicate_window)
        
        self.ui.currentNsmFolder.setText(default_folder)
        self.ui.toolButtonFolder.clicked.connect(self.changeRootFolder)
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(False)
        self.ui.lineEdit.setFocus(Qt.OtherFocusReason)
        self.ui.lineEdit.textChanged.connect(self.textChanged)
        
        self.session_list  = []
        self.template_list = []
        
        signaler.server_status_changed.connect(self.serverStatusChanged)
        
        signaler.add_session_to_list.connect(self.addSessionToList)
        serverOSC.startListSession()
        
        signaler.session_template_found.connect(self.addTemplatesToList)
        
        if self.is_duplicate:
            self.ui.labelTemplate.setVisible(False)
            self.ui.comboBoxTemplate.setVisible(False)
        else:
            serverOSC.toDaemon('/ray/server/list_session_templates')
        
        if ray_daemon.launched_before:
            self.ui.toolButtonFolder.setVisible(False)
            self.ui.currentNsmFolder.setVisible(False)
            self.ui.labelNsmFolder.setVisible(False)
        
        self.initComboBox()
        self.setLastTemplateSelected()
        
        self.server_will_accept = False
        self.text_is_valid      = False
        
        self.serverStatusChanged(session.server_status)
    
    def serverStatusChanged(self, server_status):
        self.ui.toolButtonFolder.setEnabled(bool(server_status == SERVER_STATUS_OFF))
        
        self.server_will_accept = bool(server_status in (SERVER_STATUS_OFF, SERVER_STATUS_READY) and not self.server_copying)
        if self.is_duplicate:
            self.server_will_accept = bool(server_status == SERVER_STATUS_READY and not self.server_copying)
            
        self.preventOk()
        
    def initComboBox(self):
        self.ui.comboBoxTemplate.clear()
        self.ui.comboBoxTemplate.addItem(_translate('session_template', "empty"))
        self.ui.comboBoxTemplate.addItem(_translate('session_template', "with JACK patch memory"))
        self.ui.comboBoxTemplate.insertSeparator(2)
    
    def setLastTemplateSelected(self):
        last_used_template = settings.value('last_used_template', type=str)
        
        if last_used_template.startswith('///'):
            if last_used_template == '///withJACKPATCH':
                self.ui.comboBoxTemplate.setCurrentIndex(1)
        else:
            if last_used_template in self.template_list:
                self.ui.comboBoxTemplate.setCurrentText(last_used_template)
            
        if not last_used_template:
            self.ui.comboBoxTemplate.setCurrentIndex(1)
    
    def addSessionToList(self, session_name):
        self.session_list.append(session_name)
    
    def addTemplatesToList(self, template_list):
        for template in template_list:
            if not template in self.template_list:
                self.template_list.append(template)
                
        if not self.template_list:
            return
        
        self.template_list.sort()
        
        self.initComboBox()
        
        for template_name in self.template_list:
            self.ui.comboBoxTemplate.addItem(template_name)
        
        self.setLastTemplateSelected()
    
    def getSessionName(self):
        return self.ui.lineEdit.text()

    def getTemplateName(self):
        if self.ui.comboBoxTemplate.currentIndex() == 0:
            return ""
        
        if self.ui.comboBoxTemplate.currentIndex() == 1:
            return '///withJACKPATCH'
        
        return self.ui.comboBoxTemplate.currentText()
        
    def textChanged(self, text):
        self.text_is_valid = bool(text and not text in self.session_list)
        self.preventOk()
            
    def changeRootFolder(self):
        changeRootFolder(self)
        self.ui.currentNsmFolder.setText(default_folder)
        self.session_list.clear()
        serverOSC.startListSession()
        
    def preventOk(self):
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(bool(self.server_will_accept and self.text_is_valid))

class AbstractSaveTemplateDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_save_template_session.Ui_DialogSaveTemplateSession()
        self.ui.setupUi(self)
        
        self.server_will_accept = False
        
        self.ui.lineEdit.textEdited.connect(self.textEdited)
        self.ui.pushButtonAccept.clicked.connect(self.verifyAndAccept)
        self.ui.pushButtonAccept.setEnabled(False)
        
    def textEdited(self, text):
        if '/' in text:
            self.ui.lineEdit.setText(text.replace('/', '⁄'))
        self.allowOkButton()    
    
    def getTemplateName(self):
        return self.ui.lineEdit.text()
    
    def allowOkButton(self, text=''):
        self.ui.pushButtonAccept.setEnabled(bool(self.server_will_accept and self.ui.lineEdit.text()))
    
    def verifyAndAccept(self):
        template_name = self.getTemplateName()
        if template_name in self.template_list:
            ret = QMessageBox.question(self, 
                                       _translate('session template', 'Overwrite Template ?'),
                                       _translate('session_template', 'Template <strong>%s</strong> already exists.\nOverwrite it ?') % template_name)
            if ret == QMessageBox.No:
                return
        self.accept()
    
class SaveTemplateSessionDialog(AbstractSaveTemplateDialog):
    def __init__(self, parent):
        AbstractSaveTemplateDialog.__init__(self, parent)
        
        self.template_list = []
        
        signaler.session_template_found.connect(self.addTemplatesToList)
        serverOSC.toDaemon('/ray/server/list_session_templates')
        
        self.serverStatusChanged(session.server_status)
    
    def serverStatusChanged(self, server_status):
        self.server_will_accept = bool(server_status == SERVER_STATUS_READY)
        
        if server_status == SERVER_STATUS_OFF:
            self.reject()
        
        self.allowOkButton()
    
    def addTemplatesToList(self, template_list):
        self.template_list += template_list

class SaveTemplateClientDialog(AbstractSaveTemplateDialog):
    def __init__(self, parent):
        AbstractSaveTemplateDialog.__init__(self, parent)
        
        self.template_list = []
        self.ui.pushButtonAccept.setEnabled(False)
        
        self.ui.labelNewTemplateName.setText(_translate('new client template', "New application template name :"))
        
        signaler.user_client_template_found.connect(self.addTemplatesToList)
        
        
        serverOSC.toDaemon('/ray/server/list_user_client_templates')
        
        
        self.serverStatusChanged(session.server_status)
    
    def serverStatusChanged(self, server_status):
        self.server_will_accept = bool(not server_status in (SERVER_STATUS_OFF, SERVER_STATUS_CLOSE) and not self.server_copying)
        
        if server_status == SERVER_STATUS_OFF:
            self.reject()
        
        self.allowOkButton()
    
    def addTemplatesToList(self, template_list):
        for template in template_list:
            self.template_list.append(template.split('/')[0])
  
class ClientPropertiesDialog(ChildDialog):
    def __init__(self, parent, client):
        ChildDialog.__init__(self, parent)
        self.ui = ui_client_properties.Ui_Dialog()
        self.ui.setupUi(self)
        
        self.client = client
        
        self.ui.lineEditIcon.textEdited.connect(self.changeIconwithText)
        self.ui.pushButtonSaveChanges.clicked.connect(self.saveChanges)
        
    def updateContents(self):
        self.ui.labelExecutable.setText(self.client.executable_path)
        self.ui.labelId.setText(self.client.client_id)
        self.ui.labelClientName.setText(self.client.name)
        self.ui.lineEditIcon.setText(self.client.icon_name)
        self.ui.lineEditLabel.setText(self.client.label)
        self.ui.checkBoxSaveStop.setChecked(self.client.check_last_save)
        self.ui.toolButtonIcon.setIcon(QIcon.fromTheme(self.client.icon_name))
        
    def changeIconwithText(self, text):
        self.ui.toolButtonIcon.setIcon(QIcon.fromTheme(text))
        
    def saveChanges(self):
        self.client.label           = self.ui.lineEditLabel.text()
        self.client.icon_name       = self.ui.lineEditIcon.text()
        self.client.check_last_save = self.ui.checkBoxSaveStop.isChecked()
        self.client.sendPropertiesToDaemon()

class ClientTrashDialog(ChildDialog):
    def __init__(self, parent, client_data):
        ChildDialog.__init__(self, parent)
        self.ui = ui_client_trash.Ui_Dialog()
        self.ui.setupUi(self)
        
        self.client_data = client_data
        
        self.ui.labelExecutable.setText(self.client_data.executable_path)
        self.ui.labelId.setText(self.client_data.client_id)
        self.ui.labelClientName.setText(self.client_data.name)
        self.ui.labelClientIcon.setText(self.client_data.icon)
        self.ui.labelClientLabel.setText(self.client_data.label)
        self.ui.checkBoxSaveStop.setChecked(self.client_data.check_last_save)
        self.ui.toolButtonIcon.setIcon(QIcon.fromTheme(self.client_data.icon))
        
        self.ui.pushButtonRemove.clicked.connect(self.removeClient)
        
    def serverStatusChanged(self, server_status):
        if server_status in (SERVER_STATUS_CLOSE, SERVER_STATUS_OFF):
            self.reject()
            
    def removeClient(self):
        serverOSC.toDaemon('/ray/gui/trash/remove_definitely', self.client_data.client_id)
        self.reject()
        
class AbortSessionDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_abort_session.Ui_AbortSession()
        self.ui.setupUi(self)
        
        self.ui.pushButtonAbort.clicked.connect(self.accept)
        self.ui.pushButtonCancel.clicked.connect(self.reject)
        self.ui.pushButtonCancel.setFocus(Qt.OtherFocusReason)
        
        self.serverStatusChanged(session.server_status)
        
    def serverStatusChanged(self, server_status):
        self.ui.pushButtonAbort.setEnabled(not bool(server_status in (SERVER_STATUS_CLOSE, SERVER_STATUS_OFF, SERVER_STATUS_COPY)))
        if server_status == SERVER_STATUS_OFF:
            self.reject()
       
class AbortServerCopyDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_abort_copy.Ui_Dialog()
        self.ui.setupUi(self)
        
        signaler.server_progress.connect(self.setProgress)
        
        self.serverStatusChanged(session.server_status)
        
    def serverStatusChanged(self, server_status):
        if not server_status in (SERVER_STATUS_PRECOPY, SERVER_STATUS_COPY):
            self.reject()
            
    def setProgress(self, progress):
        self.ui.progressBar.setValue(progress*100)
        
class AbortClientCopyDialog(ChildDialog):
    def __init__(self, parent, client_id):
        ChildDialog.__init__(self, parent)
        self.ui = ui_abort_copy.Ui_Dialog()
        self.ui.setupUi(self)
            
        self.client_id = client_id
        
        signaler.client_progress.connect(self.setProgress)
        
    def setProgress(self, client_id, progress):
        if client_id != self.client_id:
            return
        
        self.ui.progressBar.setValue(progress*100)
        
    def serverStatusChanged(self, server_status):
        if not self.server_copying:
            self.reject()
        
class OpenNsmSessionInfoDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_nsm_open_info.Ui_Dialog()
        self.ui.setupUi(self)
        
        self.ui.checkBox.stateChanged.connect(self.showThis)
        
    def showThis(self, state):
        settings.setValue('OpenNsmSessionInfo', not bool(state))

class quitAppDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_quit_app.Ui_DialogQuitApp()
        self.ui.setupUi(self)
        self.ui.pushButtonCancel.setFocus(Qt.OtherFocusReason)
        self.ui.pushButtonSaveQuit.clicked.connect(serverOSC.closeSession)
        self.ui.pushButtonQuitNoSave.clicked.connect(serverOSC.abortSession)
        
        original_text = self.ui.labelExecutable.text()
        self.ui.labelExecutable.setText(original_text % ('<strong>%s</strong>' % session.name))
        
        self.serverStatusChanged(session.server_status)
    
    def serverStatusChanged(self, server_status):
        if server_status == SERVER_STATUS_OFF:
            self.accept()
            return
        
        self.ui.pushButtonSaveQuit.setEnabled(bool(server_status == SERVER_STATUS_READY))
        self.ui.pushButtonQuitNoSave.setEnabled(bool(server_status != SERVER_STATUS_CLOSE))
 
class AboutRaySessionDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_about_raysession.Ui_DialogAboutRaysession()
        self.ui.setupUi(self)
        all_text = self.ui.labelRayAndVersion.text()
        self.ui.labelRayAndVersion.setText(all_text % VERSION)
        
class AddApplicationDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_add_application.Ui_DialogAddApplication()
        self.ui.setupUi(self)
        
        self.ui.checkBoxFactory.setChecked(settings.value('AddApplication/factory_box', True, type=bool))
        self.ui.checkBoxUser.setChecked(settings.value('AddApplication/user_box', True, type=bool))
        
        self.ui.checkBoxFactory.stateChanged.connect(self.factoryBoxChanged)
        self.ui.checkBoxUser.stateChanged.connect(self.userBoxChanged)
        
        
        self.ui.templateList.currentItemChanged.connect(self.currentItemChanged)
        self.ui.templateList.setFocus(Qt.OtherFocusReason)
        self.ui.filterBar.textEdited.connect(self.updateFilteredList)
        self.ui.filterBar.updownpressed.connect(self.updownPressed)
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(False)
        
        signaler.user_client_template_found.connect(self.addUserTemplates)
        signaler.factory_client_template_found.connect(self.addFactoryTemplates)
        serverOSC.toDaemon('/ray/server/list_user_client_templates')
        serverOSC.toDaemon('/ray/server/list_factory_client_templates')
        
        self.user_template_list    = []
        self.factory_template_list = []
            
        self.server_will_accept = False
        self.has_selection      = False
        
        self.serverStatusChanged(session.server_status)
    
    def factoryBoxChanged(self, state):
        if not state:
            self.ui.checkBoxUser.setChecked(True)
            
        self.updateFilteredList()
        
    def userBoxChanged(self, state):
        if not state:
            self.ui.checkBoxFactory.setChecked(True)
            
        self.updateFilteredList()   
    
    def serverStatusChanged(self, server_status):
        self.server_will_accept = bool(not server_status in (SERVER_STATUS_OFF, SERVER_STATUS_CLOSE) and not self.server_copying)
        self.preventOk()
        
    def addUserTemplates(self, template_list):
        for template in template_list:
            template_name = template
            icon_name = ''
            
            if '/' in template:
                template_name = template.split('/')[0]
                icon_name = template.split('/')[1]
            
            self.user_template_list.append(template_name)
            
            self.ui.templateList.addItem(QListWidgetItem(QIcon.fromTheme(icon_name), template_name, self.ui.templateList))
            
            self.ui.templateList.sortItems()
            
        self.updateFilteredList()
            
    def addFactoryTemplates(self, template_list):
        for template in template_list:
            template_name = template
            icon_name = ''
            
            if '/' in template:
                template_name = template.split('/')[0]
                icon_name = template.split('/')[1]
            
            self.factory_template_list.append(template_name)
            
            self.ui.templateList.addItem(QListWidgetItem(QIcon.fromTheme(icon_name), template_name, self.ui.templateList))
            
            self.ui.templateList.sortItems()
            
        self.updateFilteredList()
        
    def updateFilteredList(self, filt=''):
        filter_text = self.ui.filterBar.displayText()
        
        #show all items
        for i in range(self.ui.templateList.count()):
            self.ui.templateList.item(i).setHidden(False)
            
        liist = self.ui.templateList.findItems(filter_text, Qt.MatchContains)
        
        seen_template_list = []
        
        #hide all non matching items
        for i in range(self.ui.templateList.count()):
            template_name = self.ui.templateList.item(i).text()
            
            if self.ui.templateList.item(i) not in liist:
               self.ui.templateList.item(i).setHidden(True)
               continue
            
            if self.ui.checkBoxFactory.isChecked() and self.ui.checkBoxUser.isChecked():
                if template_name in seen_template_list:
                    self.ui.templateList.item(i).setHidden(True)
                else:
                    seen_template_list.append(template_name)
            
            elif self.ui.checkBoxFactory.isChecked():
                if not template_name in self.factory_template_list:
                    self.ui.templateList.item(i).setHidden(True)
                    continue
                
                if template_name in seen_template_list:
                    self.ui.templateList.item(i).setHidden(True)
                else:
                    seen_template_list.append(template_name)
                
            elif self.ui.checkBoxUser.isChecked():
                if not template_name in self.user_template_list:
                    self.ui.templateList.item(i).setHidden(True)
                    
                if template_name in seen_template_list:
                    self.ui.templateList.item(i).setHidden(True)
                else:
                    seen_template_list.append(template_name)
        
        #if selected item not in list, then select the first visible
        if not self.ui.templateList.currentItem() or self.ui.templateList.currentItem().isHidden():
            for i in range(self.ui.templateList.count()):
                if not self.ui.templateList.item(i).isHidden():
                    self.ui.templateList.setCurrentRow(i)
                    break
              
              
        if not self.ui.templateList.currentItem() or self.ui.templateList.currentItem().isHidden():
            self.ui.filterBar.setStyleSheet("QLineEdit { background-color: red}")
            self.ui.templateList.setCurrentItem(None)
        else:
            self.ui.filterBar.setStyleSheet("")
            self.ui.templateList.scrollTo(self.ui.templateList.currentIndex())
    
    def updownPressed(self, key):
        row = self.ui.templateList.currentRow()
        if key == Qt.Key_Up:
            if row == 0:
                return
            row-=1
            while self.ui.templateList.item(row).isHidden():
                if row == 0:
                    return
                row-=1
        elif key == Qt.Key_Down:
            if row == self.ui.templateList.count() -1:
                return
            row+=1
            while self.ui.templateList.item(row).isHidden():
                if row == self.ui.templateList.count() -1:
                    return
                row+=1
        self.ui.templateList.setCurrentRow(row)
    
    def currentItemChanged(self, item, previous_item):
        self.has_selection = bool(item)
        self.preventOk()
    
    def preventOk(self):
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(bool(self.server_will_accept and self.has_selection))
            
    def getSelectedTemplate(self):
        if self.ui.templateList.currentItem():
            return self.ui.templateList.currentItem().text()
        
    def isTemplateFactory(self, template_name):
        if not self.ui.checkBoxUser.isChecked():
            return True 
        
        #If both factory and user boxes are checked, priority to user template
        if template_name in self.user_template_list:
            return False
        
        return True
        
    def saveCheckBoxes(self):
        settings.setValue('AddApplication/factory_box', self.ui.checkBoxFactory.isChecked())
        settings.setValue('AddApplication/user_box'   , self.ui.checkBoxUser.isChecked())
        settings.sync()

class newExecutableDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_new_executable.Ui_DialogNewExecutable()
        self.ui.setupUi(self)
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(False)
        self.ui.lineEdit.setFocus(Qt.OtherFocusReason)
        self.ui.lineEdit.textChanged.connect(self.textChanged)
        
        
        self.ui.checkBoxProxy.stateChanged.connect(self.proxyStateChanged)
        signaler.new_executable.connect(self.addExecutableToCompleter)
        serverOSC.toDaemon('/ray/server/list_path')
        
        self.exec_list = []
        
        self.completer = QCompleter(self.exec_list)
        self.ui.lineEdit.setCompleter(self.completer)
        
        self.ui.lineEdit.returnPressed.connect(self.closeNow)
        
        self.serverStatusChanged(session.server_status)
        
        self.text_will_accept = False
    
    def addExecutableToCompleter(self, executable_list):
        self.exec_list += executable_list
        self.exec_list.sort()
        
        del self.completer
        self.completer = QCompleter(self.exec_list)
        self.ui.lineEdit.setCompleter(self.completer)
    
    def getExecutableSelected(self):
        return self.ui.lineEdit.text()
        
    def runViaProxy(self):
        return bool(self.ui.checkBoxProxy.isChecked())
    
    def proxyStateChanged(self, state):
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(state or self.text_will_accept)
    
    def textChanged(self, text):
        self.text_will_accept = bool(text)
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(self.ui.checkBoxProxy.isChecked() or self.text_will_accept)
   
    def closeNow(self):
       if self.ui.lineEdit.text() in self.exec_list or self.ui.checkBoxProxy.isChecked():
           self.accept()
           
    def serverStatusChanged(self, server_status):
        if server_status in (SERVER_STATUS_CLOSE, SERVER_STATUS_OFF):
            self.reject()

class StopClientDialog(ChildDialog):
    def __init__(self, parent, client_id):
        ChildDialog.__init__(self, parent)
        self.ui = ui_stop_client.Ui_Dialog()
        self.ui.setupUi(self)
        
        self.client_id = client_id
        self.wait_for_save = False
        
        self.client = session.getClient(client_id)
        
        if self.client:
            text = self.ui.label.text() % self.client.prettierName()
        
            if not self.client.has_dirty:
                minutes = int((time.time() - self.client.last_save) / 60)
                text = _translate('client_stop', "<strong>%s</strong> seems to has not been saved for %i minute(s).<br />Do you really want to stop it ?") % (self.client.prettierName(), minutes)
        
            self.ui.label.setText(text)
        
        self.ui.pushButtonSaveStop.clicked.connect(self.saveAndStop)
        self.ui.checkBox.stateChanged.connect(self.checkBoxClicked)
        
        signaler.client_status_changed.connect(self.serverUpdatesClientStatus)
    
    def saveAndStop(self):
        self.wait_for_save = True
        serverOSC.saveClient(self.client_id)
        
    def checkBoxClicked(self, state):
        self.client.check_last_save = not bool(state)
        self.client.sendPropertiesToDaemon()
        
    def serverUpdatesClientStatus(self, client_id, status):
        if client_id != self.client_id:
            return
        
        if status in (CLIENT_STATUS_STOPPED, CLIENT_STATUS_REMOVED):
            self.reject()
            return
        
        if status == CLIENT_STATUS_READY and self.wait_for_save:
            self.wait_for_save = False
            self.accept()
            
class DaemonUrlWindow(ChildDialog):
    def __init__(self, parent, err_code, ex_url):
        ChildDialog.__init__(self, parent)
        self.ui = ui_daemon_url.Ui_Dialog()
        self.ui.setupUi(self)
        
        self.ui.lineEdit.textChanged.connect(self.allowUrl)
        
        error_text = ''
        if err_code == ERR_DAEMON_NO_ANNOUNCE:
            error_text = _translate("url_window", "<p>daemon at<br><strong>%s</strong><br>didn't announce !<br></p>") % ex_url
        elif err_code == ERR_DAEMON_NOT_OFF:
            error_text = _translate("url_window", "<p>daemon at<br><strong>%s</strong><br>has a loaded session.<br>It can't be used for slave session</p>") % ex_url
        elif err_code == ERR_DAEMON_WRONG_ROOT:
            error_text = _translate("url_window", "<p>daemon at<br><strong>%s</strong><br>uses an other session root folder !<.p>") % ex_url
        elif err_code == ERR_DAEMON_WRONG_VERSION:
            error_text = _translate("url_window", "<p>daemon at<br><strong>%s</strong><br>uses an other Ray Session version.<.p>") % ex_url
        
        self.ui.labelError.setText(error_text)
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(False)
        
        self.tried_urls = getListInSettings(settings, 'network/tried_urls')
        
        self.completer = QCompleter(self.tried_urls)
        self.ui.lineEdit.setCompleter(self.completer)
        
    def getDaemonUrl(self):
        return self.ui.lineEdit.text()
    
    def allowUrl(self, text):
        if not text.startswith('osc.udp://'):
            self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(False)
            return
        
        try:
            addr = getLibloAddress(text)
            self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(True)
        except:
            self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(False)
            
    def getUrl(self):
        return self.ui.lineEdit.text()
    
class ErrorDialog(ChildDialog):
    def __init__(self, parent, osc_args):
        ChildDialog.__init__(self, parent)
        self.ui = ui_error_dialog.Ui_Dialog()
        self.ui.setupUi(self)
        
        self.ui.label.setText(osc_args[2])
        
class RayDaemon(object):
    def __init__(self):
        self.executable      = 'ray-daemon'
        self.process         = QProcess()
        
        self.process.finished.connect(self.processFinished)
        if QT_VERSION >= (5, 6):
            self.process.errorOccurred.connect(self.errorInProcess)
        self.process.setProcessChannelMode(QProcess.ForwardedChannels)
        
        self.announce_timer  = QTimer()
        self.announce_timer.setInterval(2000)
        self.announce_timer.setSingleShot(True)
        self.announce_timer.timeout.connect(self.announceTimerOut)
        
        self.stopped_yet     = False
        self.is_local        = True
        self.launched_before = False
        self.address         = None
        self.port            = None
        self.url             = ''
        
        self.is_announced    = False
        self.is_nsm_locked   = False
        
        signaler.daemon_announce.connect(self.receiveAnnounce)
        signaler.daemon_url_changed.connect(self.changeUrl)
    
    
    def processFinished(self, exit_code, exit_status):
        if not MainUI.isHidden():
            MainUI.daemonCrash()
            
    def errorInProcess(self, error):
        MainUI.daemonCrash()
    
    def changeUrl(self, new_url):
        try:
            self.setOscAddress(getLibloAddress(new_url))
        except:
            return
        
        self.callDaemon()
    
    def callDaemon(self):
        if not self.address:
            signaler.daemon_url_request.emit(ERR_NO_ERROR, self.url)
            return
        
        self.announce_timer.start()
        serverOSC.announce()
    
    def announceTimerOut(self):
        if self.launched_before:
            signaler.daemon_url_request.emit(ERR_DAEMON_NO_ANNOUNCE, self.url)
        else:
            sys.stderr.write(_translate('error', "No announce from ray-daemon. RaySession can't works. Sorry.\n"))
            app.quit()
            
    def receiveAnnounce(self, src_addr, version, server_status, nsm_locked, session_root):
        self.announce_timer.stop()
        
        if version != VERSION:
            signaler.daemon_url_request.emit(ERR_DAEMON_WRONG_VERSION, self.url)
            self.disannounce(src_addr)
            return
        
        if net_session_root and session_root != net_session_root:
            signaler.daemon_url_request.emit(ERR_DAEMON_WRONG_ROOT, self.url)
            self.disannounce(src_addr)
            return
                
        if nsm_out_daemon and server_status != SERVER_STATUS_OFF:
            signaler.daemon_url_request.emit(ERR_DAEMON_NOT_OFF, self.url)
            self.disannounce(src_addr)
            return
            
        self.is_announced  = True
        self.address = src_addr
        self.port    = src_addr.port
        self.url     = src_addr.url
        self.is_nsm_locked = nsm_locked
        self.session_root  = session_root
        
        if nsm_locked:
            signaler.daemon_nsm_locked.emit(True)
        elif under_nsm:
            serverOSC.toDaemon('/ray/server/set_nsm_locked')
        
        signaler.daemon_announce_ok.emit()
                
    def disannounce(self, address=None):
        if not address:
            address = self.address
        
        if address:
            serverOSC.disannounce(address)
        self.port = None
        self.url  = ''
        del self.address
        self.address = None
        self.is_announced = False
        
    def setExternal(self):
        self.launched_before = True
    
    def setOscAddress(self, address):
        self.address = address
        self.launched_before = True
        self.port = self.address.port
        self.url  = self.address.url
        
        #if self.address.hostname != socket.gethostname():
            #self.is_local = False
            
        self.is_local = bool(self.address.hostname == socket.gethostname())
    
    def setOscAddressViaUrl(self, url):
        print('zoijoif')
        self.setOscAddress(getLibloAddress(url)) 
    
    def processIsRunning(self):
        return bool(self.process.state() == 2)
    
    def start(self):
        if self.launched_before:
            self.callDaemon()
            return
        
        #start process
        arguments = ['--gui-url'     , str(serverOSC.url), 
                     '--osc-port'    , str(self.port), 
                     '--session-root', default_folder ]
        
        if debug_only:
            arguments.append('--debug-only')
        elif debug:
            arguments.append('--debug')
        
        self.process.start('ray-daemon', arguments)
        #self.process.start('konsole', ['-e', 'ray-daemon'] + arguments) 
        
    def stop(self):
        if self.launched_before:
            self.disannounce()
            return
            
        if self.processIsRunning():
            if not self.stopped_yet:
                self.process.terminate()
                self.stopped_yet = True
            
    def waitEnd(self):
        if not self.processIsRunning():
            return
        
        print('waiting for daemon to die', file=sys.stderr)
        
        for i in range(100):
            if self.processIsRunning():
                return
            time.sleep(0.050)
            
        print('ray-daemon is still running, sorry !', file=sys.stderr)
    
    def setNewOscAddress(self):
        if not (self.address or self.port):
            self.port = getFreeOscPort()
            self.address = Address(self.port)
            
    
        
    def setNsmLocked(self):
        self.is_nsm_locked = True
        
        
    def isAnnounced(self):
        return self.is_announced
    
    def setDisannounced(self):
        serverOSC.disannounce()
        self.port = None
        self.url  = ''
        del self.address
        self.address = None
        self.is_announced = False
    
    def getUrl(self):
        if self.address:
            return self.address.url
        
        return ''

class NSMThread(nsm_client.NSMThread):
    def __init__(self, name, signaler, daemon_address, debug):
        nsm_client.NSMThread.__init__(self, name, signaler, daemon_address, debug)
        
    @make_method('/nsm/client/list_session_templates', '')
    def listSessionTemplates(self, path, args, types, src_addr):
        pass
    
    @make_method('/nsm/client/save_as_template', 's')
    def saveAsTemplate(self, path, args, types, src_addr):
        serverOSC.saveTemplateSession(args[0])
    
    @make_method('/nsm/client/duplicate', 's')
    def duplicate(self, path, args, types, src_addr):
        pass
    

class NSMChild(QObject):
    def __init__(self):
        QObject.__init__(self)
        self.nsm_signaler = nsm_client.NSMSignaler()
        self.nsm_signaler.server_sends_open.connect(self.open)
        self.nsm_signaler.server_sends_save.connect(self.save)
        self.nsm_signaler.show_optional_gui.connect(self.showOptionalGui)
        self.nsm_signaler.hide_optional_gui.connect(self.hideOptionalGui)
        
        self.wait_for_open = False
        self.wait_for_save = False
        self.project_path  = ''
        
        self.serverNSM = NSMThread('raysession_child', self.nsm_signaler, parent_daemon_address, debug)        
        self.serverNSM.start()
        
        signaler.daemon_announce_ok.connect(self.announceToParent)
        signaler.server_status_changed.connect(self.serverStatusChanged)
    
    def announceToParent(self):
        self.serverNSM.announce(_translate('child_session', 'Child Session'), ':switch:optional-gui:', 'raysession')
    
    def serverStatusChanged(self, server_status):
        if server_status == SERVER_STATUS_READY:
            if self.wait_for_open:
                self.serverNSM.openReply()
                self.wait_for_open = False
            
            elif self.wait_for_save:
                self.serverNSM.saveReply()
                self.wait_for_save = False
    
    def open(self, project_path, session_name, jack_client_name):
        self.wait_for_open = True
        self.project_path  = project_path
        
        serverOSC.openSession(project_path)
    
    def save(self):
        MainUI.saveWindowSettings()
        
        self.wait_for_save = True
        serverOSC.saveSession()
        
    def showOptionalGui(self):
        MainUI.show()
        self.serverNSM.sendGuiState(True)
        
    def hideOptionalGui(self):
        MainUI.hide()
        self.serverNSM.sendGuiState(False)
        
class NSMChildOutside(NSMChild):
    def __init__(self):
        NSMChild.__init__(self)
        self.wait_for_close = False
        
        self.session_name = ''
        self.template_name = ''
        
    def announceToParent(self):
        self.serverNSM.announce(_translate('network_session', 'Network Session'), ':switch:optional-gui:ray-network:', 'ray-network')
    
    def save(self):
        self.serverNSM.sendToDaemon('/nsm/client/network_properties', ray_daemon.url, ray_daemon.session_root)
        NSMChild.save(self)
        
    def open(self, project_path, session_name, jack_client_name):
        self.wait_for_open = True
        
        #Here project_path is used for template if needed
        self.template_name = project_path
        self.session_name  = session_name
        
        serverOSC.openSession(self.session_name, self.template_name)
        
    def closeSession(self):
        self.wait_for_close = True
        serverOSC.closeSession()
        
    
if __name__ == '__main__':
    #connect signals
    signal.signal(signal.SIGINT , signalHandler)
    signal.signal(signal.SIGTERM, signalHandler)
    
    #set Qt Application
    app = QApplication(sys.argv)
    app.setApplicationName("RaySession")
    app.setApplicationVersion(VERSION)
    app.setOrganizationName("RaySession")
    app.setWindowIcon(QIcon(':/scalable/raysession.svg'))
    app.setQuitOnLastWindowClosed(False)
    
    ### Translation process
    locale = QLocale.system().name()
    appTranslator = QTranslator()
    if appTranslator.load("%s/locale/raysession_%s" % (os.path.dirname(os.path.dirname(sys.argv[0])), locale)):
        app.installTranslator(appTranslator)
    _translate = app.translate
    init_translation(_translate)
    
    
    QFontDatabase.addApplicationFont(":/fonts/Ubuntu-R.ttf")
    QFontDatabase.addApplicationFont(":fonts/Ubuntu-C.ttf")
    
    #Add RaySession/src to $PATH to can use raysession after make, whitout install
    this_path = os.path.realpath(os.path.dirname(sys.argv[0]))
    if not os.environ['PATH'].startswith("%s:" % this_path):
        os.environ['PATH']="%s:%s" % (this_path, os.environ['PATH'])
    
    #get arguments
    parser = argparse.ArgumentParser(description=_translate('help', 'A session manager based on the Non-Session-Manager API for sound applications.'))
    parser.add_argument('--daemon-url', '-u', type=getLibloAddress, help='connect to this daemon url')
    parser.add_argument('--out-daemon', action='store_true', help=argparse.SUPPRESS)
    parser.add_argument('--debug','-d',  action='store_true', help='display OSC messages')
    parser.add_argument('--debug-only','-do',  action='store_true', help='debug without client messages')
    parser.add_argument('--net-session-root', type=str, default='', help=argparse.SUPPRESS)
    parser.add_argument('-v', '--version', action='version', version=VERSION)
    parsed_args = parser.parse_args()
        
    debug      = parsed_args.debug
    debug_only = parsed_args.debug_only
    if debug_only:
        debug = True
    setDebug(debug)
    
    nsm_out_daemon   = parsed_args.out_daemon
    net_session_root = parsed_args.net_session_root
    
    #needed for signals SIGINT, SIGTERM
    timer = QTimer()
    timer.start(200)
    timer.timeout.connect(lambda: None)
    
    signaler = Signaler()
    
    #build and configure ray_daemon object
    ray_daemon = RayDaemon()
    
    if parsed_args.daemon_url:
        ray_daemon.setOscAddress(parsed_args.daemon_url)
    
    if not nsm_out_daemon:
        ray_daemon.setNewOscAddress()
    
    settings = QSettings()
    
    #get default folder
    default_folder = settings.value('default_folder', "%s/Ray Sessions" % os.getenv('HOME'), type=str )
    
    #build and start liblo server
    serverOSC = OSCServerT()
    serverOSC.start()
    
    #build session
    session = Session()
    
    
    under_nsm = False
    
    if os.getenv('NSM_URL'):
        try:
            parent_daemon_address = getLibloAddress(os.getenv('NSM_URL'))
        except:
            sys.stderr.write('%s is not a valid NSM_URL\n' % os.getenv('NSM_URL'))
            sys.exit(1)
            
        under_nsm = True
        
        if nsm_out_daemon:
            nsm_child = NSMChildOutside()
            ray_daemon.setExternal()
        else:
            nsm_child = NSMChild()
        
        settings = QSettings('%s/child_sessions' % app.organizationName())
    
    
    #build and show Main UI
    MainUI = MainWindow()
    MainUI.show()
    
    #The only way I found to not show Messages Dock by default.
    if not settings.value('MainWindow/ShowMessages', False, type=bool):
        MainUI.hideMessagesDock()
    
    #if ray_daemon.launched_before:
        ##if not nsm_out_daemon:
            ##print('zpeof')
            #ray_daemon.callDaemon()
    #else:
    ray_daemon.start()
        
        
    app.exec()
    
    serverOSC.stop()
    ray_daemon.stop()
    MainUI.hide()
    ray_daemon.waitEnd()
    
    del MainUI
    del app
