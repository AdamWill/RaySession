#!/usr/bin/python3


from PyQt5.QtWidgets import QApplication, QMainWindow, QMenu, QInputDialog, QBoxLayout, QListWidgetItem, QFrame, QDialog, QDialogButtonBox, QFileDialog, QMessageBox, QCompleter, QAction, QToolButton, QAbstractItemView
from PyQt5.QtGui     import QIcon , QCursor, QPalette, QPixmap, QFontDatabase
from PyQt5.QtCore    import QTimer, QProcess, pyqtSignal, QObject, QSize, Qt, QSettings, qDebug, QLocale, QTranslator
import sys
from liblo import *
import subprocess
from signal import signal, SIGINT, SIGTERM, SIGUSR1, SIGUSR2
import signal
import unicodedata
import os
import socket
import time
import argparse

#import UIs
import ui_raysession
import ui_client_slot
import ui_open_session
import ui_new_session
import ui_save_template_session
import ui_nsm_open_info
import ui_abort_session
import ui_about_raysession
import ui_add_application
import ui_new_executable
import ui_error_dialog
import ui_quit_app
import ui_client_properties
import ui_stop_client

import resources_rc

from shared import *

from list_widget_clients import *


ACTION_NONE  = 0
ACTION_OPEN  = 1
ACTION_SAVE  = 2
ACTION_CLOSE = 3
ACTION_ABORT = 4

def str2bool(v):
    return bool(v.lower() == 'true')

def remove_accents(input_str):
    nfkd_form = unicodedata.normalize('NFKD', input_str)
    return u"".join([c for c in nfkd_form if not unicodedata.combining(c)]).lower()    

def signalHandler(sig, frame):
    if sig in (SIGINT, SIGTERM):
        if ray_daemon.launched_before:
            app.quit()
            return
        
        MainUI.terminate_request = True
        ray_daemon.stop()

def changeNsmFolder(parent_window):
    global default_folder
    nsm_folder = QFileDialog.getExistingDirectory(parent_window, "Choose NSM Folder", default_folder, QFileDialog.ShowDirsOnly)
    if nsm_folder:
        if not os.access(nsm_folder, os.W_OK):
            errorDialog = QMessageBox(QMessageBox.Critical, 'unwritable dir', 'You have no permissions for %s,\nchoose another directory !' % nsm_folder)
            errorDialog.exec()
            return
        
        
        default_folder = nsm_folder
        settings.setValue('default_folder', default_folder)
        
        serverOSC.toDaemon('/ray/server/change_root', nsm_folder)

def negate(color):
    red   = 255 - color.red()
    green = 255 - color.green()
    blue  = 255 - color.blue()
    return QColor(red, green, blue)

class Session(object):
    def __init__(self):
        self.client_list   = []
        self.name          = None
        self.is_running    = False
        self.server_status = SERVER_STATUS_OFF
    
    def setRunning(self, bool):
        self.is_running = bool
        
    def isRunning(self):
        return bool(self.server_status != SERVER_STATUS_OFF)
    
    def updateServerStatus(self, server_status):
        self.server_status = server_status
    
    def setName(self, session_name):
        self.name = session_name
        
    def getClient(self, client_id):
        for client in self.client_list:
            if client.client_id == client_id:
                return client
        else:
            qDebug("session::getClient client %s not in client_list !!!" % client_id)
    
    def addClient(self, client_data):
        client = Client(client_data)
        self.client_list.append(client)
    
    def removeClient(self, client_id):
        client = self.getClient(client_id)
        if client:
            client.properties_dialog.close()
            self.client_list.remove(client)
    
    def updateClientProperties(self, client_data):
        client = self.getClient(client_data.client_id)
        if client:
            client.updateClientProperties(client_data)
    
    def updateClientStatus(self, client_id, status):
        client = self.getClient(client_id)
        if client:
            client.setStatus(status)
            
    def setClientHasGui(self, client_id):
        client = self.getClient(client_id)
        if client:
            client.setGuiEnabled()
        
    def setClientGuiState(self, client_id, state):
        client = self.getClient(client_id)
        if client:
            client.setGuiState(state)
        
    def setClientDirtyState(self, client_id, bool_dirty):
        client = self.getClient(client_id)
        if client:
            client.setDirtyState(bool_dirty)
    
    def switchClient(self, old_client_id, new_client_id):
        client = self.getClient(old_client_id)
        if client:
            client.switch(new_client_id)
    
    def clientIsStillRunning(self, client_id):
        client = self.getClient(client_id)
        if client:
            client.allowKill()
    
    def removeAllClients(self):
        self.client_list.clear()
        
    def reOrderClients(self, client_id_list):
        new_client_list = []
        for client_id in client_id_list:
            client = self.getClient(client_id)
            
            if not client:
                return
            
            new_client_list.append(client)
        
        self.client_list.clear()
        MainUI.reCreateListWidget()
        
        self.client_list = new_client_list
        for client in self.client_list:
            client.reCreateWidget()
            client.widget.updateStatus(client.status)
        
class Client(object):
    def __init__(self, client_data):
        self.client_id       = client_data.client_id
        self.executable_path = client_data.executable_path
        self.name            = client_data.name
        self.prefix_mode     = client_data.prefix_mode
        self.project_path    = client_data.project_path
        self.label           = client_data.label
        self.icon_name       = client_data.icon
        self.capabilities    = client_data.capabilities
        self.check_last_save = client_data.check_last_save
        
        self.widget      = MainUI.createClientWidget(self)
        self.status      = CLIENT_STATUS_STOPPED
        self.previous_status = CLIENT_STATUS_STOPPED
        self.hasGui      = False
        self.gui_visible = False
        self.has_dirty   = False
        self.dirty_state = True
        self.last_save   = time.time()
        
        self.properties_dialog = ClientPropertiesDialog(MainUI, self)
        
    def setStatus(self, status):
        self.previous_status = self.status
        self.status = status
        
        if not self.has_dirty:
            if self.status == CLIENT_STATUS_READY and self.previous_status in (CLIENT_STATUS_OPEN, CLIENT_STATUS_SAVE):
                self.last_save = time.time()
        
        self.widget.updateStatus(status)
        
    def setGuiEnabled(self):
        self.hasGui = True
        self.widget.showGuiButton()
        
    def setGuiState(self, state):
        self.gui_state = state
        self.widget.setGuiState(state)
    
    def setDirtyState(self, bool_dirty):
        self.has_dirty = True
        self.dirty_state = bool_dirty
        self.widget.setDirtyState(bool_dirty)
        
    def switch(self, new_client_id):
        self.client_id = new_client_id
        self.widget.updateClientData()
        
    def allowKill(self):
        self.widget.allowKill()
        
    def updateClientProperties(self, client_data):
        self.executable_path = client_data.executable_path
        self.name            = client_data.name
        self.prefix_mode     = client_data.prefix_mode
        self.project_path    = client_data.project_path
        self.label           = client_data.label
        self.icon_name       = client_data.icon
        self.capabilities    = client_data.capabilities
        self.check_last_save = client_data.check_last_save
        self.widget.updateClientData()
   
    def prettierName(self):
        if self.label:
            return self.label
        
        if self.name:
            return self.name
        
        return self.executable_path
   
    def sendPropertiesToDaemon(self):
        serverOSC.toDaemon('/ray/gui/client/update_properties', 
                           self.client_id,
                           self.executable_path, 
                           self.name, 
                           self.prefix_mode, 
                           self.project_path, 
                           self.label, 
                           self.icon_name, 
                           self.capabilities)
        
    def showPropertiesDialog(self):
        self.properties_dialog.updateContents()
        self.properties_dialog.show()
        self.properties_dialog.activateWindow()
    
    def reCreateWidget(self):
        del self.widget
        self.widget = MainUI.createClientWidget(self)
        self.widget.updateClientData()
        
    def hasBeenRecentlySaved(self):
        if (time.time() - self.last_save) >= 60: #last save more than 60 seconds ago
            return False
        
        return True
            
    
class OscSignaler(QObject):
    error_appears    = pyqtSignal()
    
    server_announce_sig = pyqtSignal()
    new_message_sig     = pyqtSignal(str)
    session_sig         = pyqtSignal()
    session_name_sig    = pyqtSignal(str, str)
    session_seems_closed = pyqtSignal()
    session_close_error = pyqtSignal()
    error_message       = pyqtSignal(list)
    
    new_client_added       = pyqtSignal(ClientData)
    new_client_stopped     = pyqtSignal(str, str)
    client_removed         = pyqtSignal(str)
    client_status_changed  = pyqtSignal(str, int)
    client_switched        = pyqtSignal(str, str)
    client_progress_sig    = pyqtSignal()
    client_dirty_sig       = pyqtSignal(str, bool)
    client_has_gui         = pyqtSignal(str)
    client_gui_visible_sig = pyqtSignal(str, int)
    client_still_running   = pyqtSignal(str)
    client_updated         = pyqtSignal(ClientData)
    add_session_to_list    = pyqtSignal(str)
    new_executable         = pyqtSignal(list)
    session_template_found = pyqtSignal(list)
    user_client_template_found    = pyqtSignal(list)
    factory_client_template_found = pyqtSignal(list)
    server_status_changed  = pyqtSignal(int)
    clients_reordered      = pyqtSignal(list)
    opening_session    = pyqtSignal()
    
    def __init__(self):
        QObject.__init__(self)

class OSCServerT(ServerThread):
    def __init__(self):
        ServerThread.__init__(self)
        self.qsig = OscSignaler()
    
    @make_method('/error', None)
    def errorFromServer(self, errorpath, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (errorpath, str(args)))
        
        self.qsig.error_message.emit(args)
    
    @make_method('/reply', 'ss')
    def receiveFromServer(self, path_reply, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path_reply, str(args)))
        
        if args[0] == '/nsm/server/list':
            session_name = args[1]
            self.qsig.add_session_to_list.emit(session_name)
    
            
    @make_method('/reply_path', None)
    def replyPath(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        if not areTheyAllString(args):
            return
        
        self.qsig.new_executable.emit(args)
    
    @make_method('/reply_session_templates', None)
    def replySessionTemplates(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        if not areTheyAllString(args):
            return
        
        self.qsig.session_template_found.emit(args)
    
    @make_method('/reply_user_client_templates', None)
    def replyUserClientTemplates(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        if not areTheyAllString(args):
            return
        
        self.qsig.user_client_template_found.emit(args)
    
    @make_method('/reply_factory_client_templates', None)
    def replyFactoryClientTemplates(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        if not areTheyAllString(args):
            return
        
        self.qsig.factory_client_template_found.emit(args)
    
    @make_method('/ray/gui/server_announce', None)
    def serverAnnounce(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
    
    @make_method('/ray/gui/server/message', 's')
    def serverMessage(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
            
        message = args[0]
        self.qsig.new_message_sig.emit(message)
    
    @make_method('/ray/gui/session/name', 'ss')
    def guiSessionName(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
            
        name1, name2 = args
        self.qsig.session_name_sig.emit(name1, name2)
    
    @make_method('/ray/gui/client/new', 'sssissssi')
    def newClientFromServer(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        client_data = ClientData(*args)
        self.qsig.new_client_added.emit(client_data)
    
    @make_method('/ray/gui/client/update', 'sssissssi')
    def updateClientProperties(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        client_data = ClientData(*args)
        self.qsig.client_updated.emit(client_data)
        
    @make_method('/ray/gui/client/status', 'si')
    def guiClientStatus(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
            
        client_id, status = args
            
        if status == CLIENT_STATUS_REMOVED:
            self.qsig.client_removed.emit(client_id)
            return
        
        self.qsig.client_status_changed.emit(client_id, status)
        
    @make_method('/ray/gui/client/switch', 'ss')
    def guiClientSwitch(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
        old_client_id, new_client_id = args
        
        self.qsig.client_switched.emit(old_client_id, new_client_id)
        
    @make_method('/ray/gui/client/progress', None)
    def guiClientProgress(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
        
    @make_method('/ray/gui/client/dirty', 'si')
    def guiClientDirty(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
            
        client_id, dirty_num = args
        bool_dirty = bool(dirty_num)
        
        self.qsig.client_dirty_sig.emit(client_id, bool_dirty)
        
    @make_method('/ray/gui/client/has_optional_gui', 's')
    def guiClientHasOptionalGui(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
            
        client_id = args[0]
        self.qsig.client_has_gui.emit(client_id)
        
    @make_method('/ray/gui/client/gui_visible', 'si')
    def guiClientGuiVisible(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
            
        client_id, state = args
        self.qsig.client_gui_visible_sig.emit(client_id, bool(state))
      
    @make_method('/ray/gui/client/still_running', 's')
    def guiClientStillRunning(self, path, args):
        ifDebug('serverOSC::raysession_receives %s, %s' % (path, str(args)))
            
        client_id = args[0]
        self.qsig.client_still_running.emit(client_id)
        
      
    @make_method('/ray/server_status', 'i')
    def rayServerStatus(self, path, args):
        server_status = args[0]
        self.qsig.server_status_changed.emit(server_status)
    
    @make_method('/ray/opening_nsm_session', None)
    def rayOpeningNsmSession(self, path, args):
        self.qsig.opening_session.emit()
    
    @make_method('/ray/gui/clients_reordered', None)
    def rayGuiReorderClients(self, path, args):
        for arg in args:
            if not type(arg) is str:
                return
        
        self.qsig.clients_reordered.emit(args)
    
    def toDaemon(self, *args):
        self.send(ray_daemon.address, *args)
    
    def announce(self):
        ifDebug('serverOSC::raysession_sends annouce')
        self.send(ray_daemon.address, '/ray/gui/gui_announce')
    
    def startListSession(self):
        ifDebug('serverOSC::raysession_sends list sessions')
        self.toDaemon('/nsm/server/list')
    
    def newSession(self, session_name):
        ifDebug('serverOSC::raysession_sends new session %s' % remove_accents(session_name))
        self.toDaemon('/nsm/server/new', session_name)
    
    def newSessionFromTemplate(self, session_name, template_name):
        self.toDaemon('/ray/server/new_from_template', session_name, template_name)
    
    def openSession(self, session_name):
        ifDebug('serverOSC::raysession_sends open session %s' % remove_accents(session_name))
        self.toDaemon('/nsm/server/open', session_name)
        
    def saveSession(self):
        ifDebug('serverOSC::raysession_sends save session')
        self.toDaemon('/nsm/server/save')
        
    def closeSession(self):
        ifDebug('serverOSC::raysession_sends close session')
        self.toDaemon('/nsm/server/close')
        
    def abortSession(self):
        ifDebug('serverOSC::raysession_sends abort session')
        self.toDaemon('/nsm/server/abort')
        
    def duplicateSession(self, session_name):
        ifDebug('serverOSC::raysession_sends duplication session')
        self.toDaemon('/nsm/server/duplicate', session_name)
    
    def saveTemplateSession(self, session_template_name):
        ifDebug('serverOSC::raysession_sends save template session')
        self.toDaemon('/ray/server/save_session_template', session_template_name)    
    
    def startClient(self, client_id):
        ifDebug('serverOSC::raysession_sends start client %s' % client_id)
        self.toDaemon('/ray/gui/client/resume', client_id)
        
    def stopClient(self, client_id):
        ifDebug('serverOSC::raysession_sends stop client %s' % client_id)
        self.toDaemon('/ray/gui/client/stop', client_id)
        
    def killClient(self, client_id):
        ifDebug('serverOSC::raysession_sends stop client %s' % client_id)
        self.toDaemon('/ray/gui/client/kill', client_id)
        
    def saveClient(self, client_id):
        ifDebug('serverOSC::raysession_sends save client %s' % client_id)
        self.toDaemon('/ray/gui/client/save', client_id)
        
    def removeClient(self, client_id):
        ifDebug('serverOSC::raysession_sends remove client %s' % client_id)
        self.toDaemon('/ray/gui/client/remove', client_id)
    
    def showClientOptionalGui(self, client_id):
        ifDebug('serverOSC::raysession_sends show optional GUI %s' % client_id)
        self.toDaemon('/ray/gui/client/show_optional_gui', client_id)
        
    def hideClientOptionalGui(self, client_id):
        ifDebug('serverOSC::raysession_sends hide optional GUI %s' % client_id)
        self.toDaemon('/ray/gui/client/hide_optional_gui', client_id)
        
    def saveClientTemplate(self, client_id, template_name):
        self.toDaemon('/ray/gui/client/save_as_template', client_id, template_name)
        
    def addClient(self, program_name):
        ifDebug('serverOSC::raysession_sends add Client %s' % program_name)
        self.toDaemon('/nsm/server/add', program_name)
        
    def changeClientOrder(self, client_ids_list):
        self.toDaemon('/ray/server/reorder_clients', *client_ids_list)
        
    #def 

class RayIcon(QIcon):
    def __init__(self, icon_name, dark=False):
        QIcon.__init__(self)
        breeze = 'breeze-dark' if dark else 'breeze'
        self.addPixmap(QPixmap(':scalable/%s/%s' % (breeze, icon_name)), QIcon.Normal, QIcon.Off)
        self.addPixmap(QPixmap(':scalable/%s/disabled/%s' % (breeze, icon_name)), QIcon.Disabled, QIcon.Off)

class MainWindow(QMainWindow):
    def __init__(self):
        QMainWindow.__init__(self)
        self.ui = ui_raysession.Ui_MainWindow()
        self.ui.setupUi(self)
        
        self.mouse_is_inside   = False
        self.terminate_request = False
        
        #timer for keep focus while client opening
        self.timer_raisewin = QTimer()
        self.timer_raisewin.setInterval(50)
        self.timer_raisewin.timeout.connect(self.raiseWindow)
        
        #timer for flashing effect of 'open' status
        self.timer_flicker_open = QTimer()
        self.timer_flicker_open.setInterval(400)
        self.timer_flicker_open.timeout.connect(self.flashOpen)
        self.flash_open_list = []
        self.flash_open_bool = False
        
        
        
        #set options with config file, restore geometry
        self.keep_focus = settings.value('keepfocus', True, type=bool)
        self.ui.actionKeepFocus.setChecked(self.keep_focus)
        if settings.value('MainWindow/geometry'):
            self.restoreGeometry(settings.value('MainWindow/geometry'))
        if settings.value('MainWindow/WindowState'):
            self.restoreState(settings.value('MainWindow/WindowState'))
        self.ui.actionShowMenuBar.activate(settings.value('MainWindow/ShowMenuBar', False, type=bool))
        
        #set default action for tools buttons
        self.ui.closeButton.setDefaultAction(self.ui.actionCloseSession)
        self.ui.toolButtonSaveSession.setDefaultAction(self.ui.actionSaveSession)
        self.ui.toolButtonAbortSession.setDefaultAction(self.ui.actionAbortSession)
        self.ui.toolButtonDuplicateSession.setDefaultAction(self.ui.actionDuplicateSession)
        self.ui.toolButtonSaveTemplateSession.setDefaultAction(self.ui.actionSaveTemplateSession)
        self.ui.toolButtonFileManager.setDefaultAction(self.ui.actionOpenSessionFolder)
        self.ui.toolButtonAddApplication.setDefaultAction(self.ui.actionAddApplication)
        self.ui.toolButtonAddExecutable.setDefaultAction(self.ui.actionAddExecutable)
        
        #connect actions
        self.ui.actionNewSession.triggered.connect(self.createNewSession)
        self.ui.actionOpenSession.triggered.connect(self.openSession)
        self.ui.actionQuit.triggered.connect(self.quitApp)
        self.ui.actionSaveSession.triggered.connect(self.saveSession)
        self.ui.actionCloseSession.triggered.connect(self.closeSession)
        self.ui.actionAbortSession.triggered.connect(self.abortSession)
        self.ui.actionDuplicateSession.triggered.connect(self.duplicateSession)
        self.ui.actionSaveTemplateSession.triggered.connect(self.saveTemplateSession)
        self.ui.actionOpenSessionFolder.triggered.connect(self.openFileManager)
        self.ui.actionAddApplication.triggered.connect(self.addApplication)
        self.ui.actionAddExecutable.triggered.connect(self.addExecutable)
        self.ui.actionKeepFocus.toggled.connect(self.toggleKeepFocus)
        self.ui.actionAboutRaySession.triggered.connect(self.aboutRaySession)
        self.ui.actionAboutQt.triggered.connect(app.aboutQt)
        
        
        
        #set control menu
        self.controlMenu = QMenu()
        self.controlMenu.addAction(self.ui.actionShowMenuBar)
        self.controlMenu.addAction(self.ui.actionToggleShowMessages)
        self.controlMenu.addSeparator()
        self.controlMenu.addAction(self.ui.actionKeepFocus)
        
        self.controlToolButton = self.ui.toolBar.widgetForAction(self.ui.actionControlMenu)
        self.controlToolButton.setPopupMode(QToolButton.InstantPopup)
        self.controlToolButton.setMenu(self.controlMenu)
        
        #connect OSC signals from nsm
        serverOSC.qsig.new_client_added.connect(self.serverAddsClient)
        serverOSC.qsig.client_removed.connect(self.serverRemovesClient)
        serverOSC.qsig.client_status_changed.connect(self.serverUpdatesClientStatus)
        serverOSC.qsig.client_has_gui.connect(self.serverSetsClientHasGui)
        serverOSC.qsig.client_gui_visible_sig.connect(self.serverSetsClientGuiState)
        serverOSC.qsig.client_dirty_sig.connect(self.serverSetsClientDirtyState)
        serverOSC.qsig.client_switched.connect(self.serverSwitchesClient)
        serverOSC.qsig.client_still_running.connect(self.serverStillRunningClient)
        serverOSC.qsig.client_updated.connect(self.serverUpdatesClientProperties)
        serverOSC.qsig.new_message_sig.connect(self.serverPrintsMessage)
        serverOSC.qsig.session_name_sig.connect(self.serverRenamesSession)
        serverOSC.qsig.server_status_changed.connect(self.serverChangeServerStatus)
        serverOSC.qsig.error_message.connect(self.serverSendsError)
        serverOSC.qsig.opening_session.connect(self.serverOpensNsmSession)
        serverOSC.qsig.clients_reordered.connect(self.serverReorderClients)
        
        self.connectListWidgetRequests()
        
        if app.palette().brush(2, QPalette.WindowText).color().lightness() > 128:
            self.ui.actionCloseSession.setIcon(RayIcon('window-close', dark=True))
            self.ui.actionAbortSession.setIcon(RayIcon('list-remove', dark=True))
            self.ui.toolButtonSaveSession.setIcon(RayIcon('document-save', dark=True))
        
        #disable "keep focus" if daemon is not on this machine (it takes no sense in this case)
        if not ray_daemon.is_local:
            self.ui.actionKeepFocus.setChecked(False)
            self.ui.actionKeepFocus.setEnabled(False)
            
    def connectListWidgetRequests(self):
        #connect the listWidget signals to OSC server
        self.ui.listWidget.orderChanged.connect(serverOSC.changeClientOrder)
        self.ui.listWidget.clientStartRequest.connect(serverOSC.startClient)
        self.ui.listWidget.clientStopRequest.connect(self.clientStopRequest)
        self.ui.listWidget.clientKillRequest.connect(serverOSC.killClient)
        self.ui.listWidget.clientSaveRequest.connect(serverOSC.saveClient)
        self.ui.listWidget.clientRemoveRequest.connect(serverOSC.removeClient)
        self.ui.listWidget.clientHideGuiRequest.connect(serverOSC.hideClientOptionalGui)
        self.ui.listWidget.clientShowGuiRequest.connect(serverOSC.showClientOptionalGui)
        self.ui.listWidget.clientSaveTemplateRequest.connect(self.newClientTemplate)
        self.ui.listWidget.clientPropertiesRequest.connect(self.openClientProperties)
    
    def createClientWidget(self, client):
        return self.ui.listWidget.createClientWidget(client)
    
    def reCreateListWidget(self):
        #this function shouldn't exist, it is a workaround for a bug with python-qt 
        #(when reorder widgets sometimes one widget is totally hidden until user resize the window)
        #It has to be modified when ui_raysession is modified
        self.ui.listWidget.clear()
        self.ui.verticalLayout.removeWidget(self.ui.listWidget)
        del self.ui.listWidget
        self.ui.listWidget = ListWidgetClients(self.ui.frameCurrentSession)
        self.ui.listWidget.setAcceptDrops(True)
        self.ui.listWidget.setStyleSheet("QFrame{border:none}")
        self.ui.listWidget.setDragEnabled(True)
        self.ui.listWidget.setDragDropMode(QAbstractItemView.InternalMove)
        self.ui.listWidget.setSelectionMode(QAbstractItemView.SingleSelection)
        self.ui.listWidget.setUniformItemSizes(True)
        self.ui.listWidget.setBatchSize(80)
        self.ui.listWidget.setObjectName("listWidget")
        self.ui.verticalLayout.addWidget(self.ui.listWidget)
        
        self.connectListWidgetRequests()
    
    def openFileManager(self):
        serverOSC.toDaemon('/ray/server/openfolder')
    
    def raiseWindow(self):
        if self.mouse_is_inside:
            self.activateWindow()
    
    def toggleKeepFocus(self, bool):
        self.keep_focus = bool
        if ray_daemon.is_local:
            settings.setValue('keepfocus', self.keep_focus)
        if not bool:
            self.timer_raisewin.stop()
    
    def flashOpen(self):
        for client in session.client_list:
            if client.status == CLIENT_STATUS_OPEN:
                client.widget.flashIfOpen(self.flash_open_bool)
                
        self.flash_open_bool = not self.flash_open_bool
    
    def quitApp(self):
        if not ray_daemon.launched_before and session.isRunning():
            dialog = quitAppDialog(self)
            dialog.exec()
            if dialog.result():
                QApplication.quit()
            
        else:
            QApplication.quit()
    
    def newClientTemplate(self, client_id):
        dialog = SaveTemplateClientDialog(self)
        dialog.exec()
        if not dialog.result():
            return
        
        template_name = dialog.getTemplateName()
        
        serverOSC.saveClientTemplate(client_id, template_name)
    
    def openClientProperties(self, client_id):
        client = session.getClient(client_id)
        if not client:
            return
        
        client.showPropertiesDialog()
    
    def createNewSession(self):
        self.ui.dockWidgetMessages.setVisible(False)
        dialog = NewSessionDialog(self)
        dialog.exec()
        if not dialog.result():
            return
        
        session_name  = dialog.getSessionName()
        template_name = dialog.getTemplateName()
        
        settings.setValue('last_used_template', template_name)
        
        if template_name:
            serverOSC.newSessionFromTemplate(session_name, template_name)
        else:
            serverOSC.newSession(session_name)
      
    def openSession(self, action):
        dialog = OpenSessionDialog(self)
        dialog.exec()
        if not dialog.result():
            return
        
        if session.isRunning():
            settings.setValue('last_session', session.name)
            
        session_name = dialog.getSelectedSession()
        serverOSC.openSession(session_name)
    
    def closeSession(self):
        settings.setValue('last_session', session.name)
        serverOSC.closeSession()
        
    def abortSession(self):
        dialog = AbortSessionDialog(self)
        dialog.exec()
        
        if dialog.result():
            serverOSC.abortSession()
    
    def duplicateSession(self):
        dialog = NewSessionDialog(self, True)
        dialog.exec()
        if not dialog.result():
            return
        
        settings.setValue('last_session', session.name)
        
        session_name = dialog.getSessionName()
        serverOSC.duplicateSession(session_name)
            
    def saveTemplateSession(self):
        dialog = SaveTemplateSessionDialog(self)
        dialog.exec()
        if not dialog.result():
            return
        
        session_template_name = dialog.getTemplateName()
        serverOSC.saveTemplateSession(session_template_name)
    
    def aboutRaySession(self):
        dialog = AboutRaySessionDialog(self)
        dialog.exec()
    
    def saveSession(self):
        serverOSC.saveSession()
    
    def addApplication(self):
        if session.server_status in (SERVER_STATUS_CLOSE, SERVER_STATUS_OFF):
            return
        
        dialog = AddApplicationDialog(self)
        dialog.exec()
        dialog.saveCheckBoxes()
        
        if dialog.result():
            template_name = dialog.getSelectedTemplate()
            factory = dialog.isTemplateFactory(template_name)
            
            if factory:
                serverOSC.toDaemon('/ray/server/add_factory_client_template', template_name)
            else:
                serverOSC.toDaemon('/ray/server/add_user_client_template', template_name)
    
    def addExecutable(self):
        if session.server_status in (SERVER_STATUS_CLOSE, SERVER_STATUS_OFF):
            return
        
        dialog = newExecutableDialog(self)
        dialog.exec()
        if not dialog.result():
            return
        
        command = dialog.getExecutableSelected()
        proxy   = dialog.runViaProxy()
        
        if proxy:
            serverOSC.toDaemon('/ray/server/add_proxy', command)
        else:
            serverOSC.addClient(command)
    
    def clientStopRequest(self, client_id):
        client = session.getClient(client_id)
        if not client:
            return
        
        if client.has_dirty:
            if client.dirty_state:
                dialog = StopClientDialog(self, client_id)
                dialog.exec()
                if not dialog.result():
                    return
                
        elif client.status == CLIENT_STATUS_READY and (time.time() - client.last_save) >= 60:
            dialog = StopClientDialog(self, client_id)
            dialog.exec()
            if not dialog.result():
                return
                
        serverOSC.stopClient(client_id)
            
    
    ###FUNCTIONS RELATED TO SIGNALS FROM OSC SERVER#######
    
    def serverAddsClient(self, client_data):
        session.addClient(client_data)
    
    def serverRemovesClient(self, client_id):
        client = session.getClient(client_id)
        if client:
            self.ui.listWidget.removeClientWidget(client_id)
            session.removeClient(client_id)
    
    def serverSwitchesClient(self, old_client_id, new_client_id):
        session.switchClient(old_client_id, new_client_id)
    
    def serverUpdatesClientProperties(self, client_data):
        session.updateClientProperties(client_data)
    
    def serverUpdatesClientStatus(self, client_id, status):
        session.updateClientStatus(client_id, status)
        
        #launch/stop flashing status if 'open'
        for client in session.client_list:
            if client.status == CLIENT_STATUS_OPEN:
                if not self.timer_flicker_open.isActive():
                    self.timer_flicker_open.start()
                break
        else:
            self.timer_flicker_open.stop()
        
        #launch/stop timer_raisewin if keep focus
        if self.keep_focus:
            for client in session.client_list:
                if client.status == CLIENT_STATUS_OPEN:
                    if not self.timer_raisewin.isActive():
                        self.timer_raisewin.start()
                    break
            else:
                self.timer_raisewin.stop()
                if status == CLIENT_STATUS_READY:
                    self.raiseWindow()
            
    def serverSetsClientHasGui(self, client_id):
        session.setClientHasGui(client_id)
        
    def serverSetsClientGuiState(self, client_id, state):
        session.setClientGuiState(client_id, state)
        
    def serverSetsClientDirtyState(self, client_id, bool_dirty):
        session.setClientDirtyState(client_id, bool_dirty)
    
    def serverStillRunningClient(self, client_id):
        session.clientIsStillRunning(client_id)
    
    def serverPrintsMessage(self, message):
        self.ui.textEditMessages.appendPlainText(time.strftime("%H:%M:%S") + '  ' + message)
    
    def serverRenamesSession(self, session_name, session_path):
        session.setName(session_name)
        
        if session_name:
            self.setWindowTitle('%s - %s' % (APP_TITLE, session_name))
            self.ui.LabelSessionName.setText(session_name)
        else:
            self.setWindowTitle(APP_TITLE)
            self.ui.LabelSessionName.setText(_translate('main view', 'No Session Loaded'))
            
    def serverSendsError(self, args):
        if not len(args) >= 3:
            return
        
        error_dialog = ErrorDialog(self, args)
        error_dialog.exec()
    
    def serverOpensNsmSession(self):
        if not settings.value('OpenNsmSessionInfo', True, type=bool):
            return
        
        dialog = OpenNsmSessionInfoDialog(self)
        dialog.exec()
    
    def serverReorderClients(self, client_id_list):
        session.reOrderClients(client_id_list)
    
    def serverChangeServerStatus(self, server_status):
        session.updateServerStatus(server_status)
        
        self.ui.lineEditServerStatus.setText(serverStatusString(server_status))
        self.ui.frameCurrentSession.setEnabled(bool(server_status != SERVER_STATUS_OFF))
        
        close_or_off = bool(server_status in (SERVER_STATUS_CLOSE, SERVER_STATUS_OFF))
        ready        = bool(server_status == SERVER_STATUS_READY)
        
        self.ui.actionSaveSession.setEnabled(ready)
        self.ui.actionCloseSession.setEnabled(ready)
        self.ui.actionAbortSession.setEnabled(not close_or_off)
        self.ui.actionDuplicateSession.setEnabled(not close_or_off)
        self.ui.actionSaveTemplateSession.setEnabled(not close_or_off)
        self.ui.actionAddApplication.setEnabled(not close_or_off)
        self.ui.actionAddExecutable.setEnabled(not close_or_off)
        self.ui.actionOpenSessionFolder.setEnabled(bool(server_status != SERVER_STATUS_OFF))
        
        
        if server_status == SERVER_STATUS_OFF:            
            self.ui.listWidget.clear()
            
            if self.terminate_request:
                app.quit()
    
    
    def daemonCrash(self):
        QMessageBox.critical(self, _translate('errors', "daemon crash!"), _translate('errors', "ray-daemon crashed, sorry !"))
        app.quit()
    
    #Reimplemented Functions
    
    def closeEvent(self, event):
        settings.setValue('MainWindow/geometry', self.saveGeometry())
        settings.setValue('MainWindow/WindowState', self.saveState())
        settings.setValue('MainWindow/ShowMenuBar', self.ui.menuBar.isVisible())
        settings.setValue('MainWindow/ShowMessages', self.ui.dockWidgetMessages.isVisible())
        settings.sync()
        
        self.quitApp()
        event.ignore()
        
    def leaveEvent(self, event):
        if self.isActiveWindow():
            self.mouse_is_inside = False
        QDialog.leaveEvent(self, event)
        
    def enterEvent(self, event):
        self.mouse_is_inside = True
        QDialog.enterEvent(self, event)

class ChildDialog(QDialog):
    def __init__(self, parent):
        QDialog.__init__(self, parent)
        serverOSC.qsig.server_status_changed.connect(self.serverStatusChanged)
        
    def serverStatusChanged(self, server_status):
        return
    
    def leaveEvent(self, event):
        if self.isActiveWindow():
            self.parent().mouse_is_inside = False
        QDialog.leaveEvent(self, event)
        
    def enterEvent(self, event):
        self.parent().mouse_is_inside = True
        QDialog.enterEvent(self, event)

class OpenSessionDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_open_session.Ui_DialogOpenSession()
        self.ui.setupUi(self)
        
        self.f_last_session_item = None
        
        self.ui.toolButtonFolder.clicked.connect(self.changeNsmFolder)
        self.ui.sessionList.currentItemChanged.connect(self.currentItemChanged)
        self.ui.sessionList.setFocus(Qt.OtherFocusReason)
        self.ui.filterBar.textEdited.connect(self.updateFilteredList)
        self.ui.filterBar.updownpressed.connect(self.updownPressed)
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(False)
        
        self.ui.currentNsmFolder.setText(default_folder)
        
        serverOSC.qsig.add_session_to_list.connect(self.addSession)
        serverOSC.startListSession()
        
        if ray_daemon.launched_before:
            self.ui.toolButtonFolder.setVisible(False)
            self.ui.currentNsmFolder.setVisible(False)
            self.ui.labelNsmFolder.setVisible(False)
            
        self.server_will_accept = False
        self.has_selection      = False
        
        self.serverStatusChanged(session.server_status)
    
    def serverStatusChanged(self, server_status):
        self.ui.toolButtonFolder.setEnabled(bool(server_status == SERVER_STATUS_OFF))
        
        self.server_will_accept = bool(server_status in (SERVER_STATUS_OFF, SERVER_STATUS_READY))
        self.preventOk()
        
    def addSession(self, session_name):
        if session_name == settings.value('last_session', type=str):
            self.f_last_session_item = QListWidgetItem(session_name)
            self.ui.sessionList.addItem(self.f_last_session_item)
            self.ui.sessionList.setCurrentItem(self.f_last_session_item)
        else:
            self.ui.sessionList.addItem(session_name)
        
        self.ui.sessionList.sortItems()
        
        if self.f_last_session_item:
            current_index = self.ui.sessionList.currentIndex()
            self.ui.sessionList.scrollTo(current_index)
        else:
            self.ui.sessionList.setCurrentRow(0)
        
    def updateFilteredList(self, filt):
        filter_text = self.ui.filterBar.displayText()
        
        #show all items
        for i in range(self.ui.sessionList.count()):
            self.ui.sessionList.item(i).setHidden(False)
            
        liist = self.ui.sessionList.findItems(filter_text, Qt.MatchContains)
        
        #hide all non matching items
        for i in range(self.ui.sessionList.count()):
            if self.ui.sessionList.item(i) not in liist:
               self.ui.sessionList.item(i).setHidden(True)
        
        #if selected item not in list, then select the first visible
        if not self.ui.sessionList.currentItem() or self.ui.sessionList.currentItem().isHidden():
            for i in range(self.ui.sessionList.count()):
                if not self.ui.sessionList.item(i).isHidden():
                    self.ui.sessionList.setCurrentRow(i)
                    break
              
              
        if not self.ui.sessionList.currentItem() or self.ui.sessionList.currentItem().isHidden():
            self.ui.filterBar.setStyleSheet("QLineEdit { background-color: red}")
            self.ui.sessionList.setCurrentItem(None)
        else:
            self.ui.filterBar.setStyleSheet("")
            self.ui.sessionList.scrollTo(self.ui.sessionList.currentIndex())
    
    def updownPressed(self, key):
        row = self.ui.sessionList.currentRow()
        if key == Qt.Key_Up:
            if row == 0:
                return
            row-=1
            while self.ui.sessionList.item(row).isHidden():
                if row == 0:
                    return
                row-=1
        elif key == Qt.Key_Down:
            if row == self.ui.sessionList.count() -1:
                return
            row+=1
            while self.ui.sessionList.item(row).isHidden():
                if row == self.ui.sessionList.count() -1:
                    return
                row+=1
        self.ui.sessionList.setCurrentRow(row)
    
    def currentItemChanged(self, item, previous_item):
        self.has_selection = bool(item)
        self.preventOk()
    
    def preventOk(self):
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(bool(self.server_will_accept and self.has_selection))
    
    def changeNsmFolder(self):
        changeNsmFolder(self)
        self.ui.currentNsmFolder.setText(default_folder)
        self.ui.sessionList.clear()
        serverOSC.startListSession()
            
    def getSelectedSession(self):
        if self.ui.sessionList.currentItem():
            return self.ui.sessionList.currentItem().text()

class NewSessionDialog(ChildDialog):
    def __init__(self, parent, duplicate_window = False):
        ChildDialog.__init__(self, parent)
        self.ui = ui_new_session.Ui_DialogNewSession()
        self.ui.setupUi(self)
        
        self.is_duplicate = bool(duplicate_window)
        
        self.ui.currentNsmFolder.setText(default_folder)
        self.ui.toolButtonFolder.clicked.connect(self.changeNsmFolder)
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(False)
        self.ui.lineEdit.setFocus(Qt.OtherFocusReason)
        self.ui.lineEdit.textChanged.connect(self.textChanged)
        
        self.session_list  = []
        self.template_list = []
        
        serverOSC.qsig.server_status_changed.connect(self.serverStatusChanged)
        
        serverOSC.qsig.add_session_to_list.connect(self.addSessionToList)
        serverOSC.startListSession()
        
        serverOSC.qsig.session_template_found.connect(self.addTemplatesToList)
        
        if self.is_duplicate:
            self.ui.labelTemplate.setVisible(False)
            self.ui.comboBoxTemplate.setVisible(False)
        else:
            serverOSC.toDaemon('/ray/server/list_session_templates')
        
        if ray_daemon.launched_before:
            self.ui.toolButtonFolder.setVisible(False)
            self.ui.currentNsmFolder.setVisible(False)
            self.ui.labelNsmFolder.setVisible(False)
        
        self.initComboBox()
        self.setLastTemplateSelected()
        
        self.server_will_accept = False
        self.text_is_valid      = False
        
        self.serverStatusChanged(session.server_status)
    
    def serverStatusChanged(self, server_status):
        self.ui.toolButtonFolder.setEnabled(bool(server_status == SERVER_STATUS_OFF))
        
        self.server_will_accept = bool(server_status in (SERVER_STATUS_OFF, SERVER_STATUS_READY))
        if self.is_duplicate:
            self.server_will_accept = bool(server_status == SERVER_STATUS_READY)
            
        self.preventOk()
        
    def initComboBox(self):
        self.ui.comboBoxTemplate.clear()
        self.ui.comboBoxTemplate.addItem(_translate('session_template', "empty"))
        self.ui.comboBoxTemplate.addItem(_translate('session_template', "with JACK patch memory"))
        self.ui.comboBoxTemplate.insertSeparator(2)
    
    def setLastTemplateSelected(self):
        last_used_template = settings.value('last_used_template', type=str)
        
        if last_used_template.startswith('///'):
            if last_used_template == '///withJACKPATCH':
                self.ui.comboBoxTemplate.setCurrentIndex(1)
        else:
            if last_used_template in self.template_list:
                self.ui.comboBoxTemplate.setCurrentText(last_used_template)
            
        if not last_used_template:
            self.ui.comboBoxTemplate.setCurrentIndex(1)
    
    def addSessionToList(self, session_name):
        self.session_list.append(session_name)
    
    def addTemplatesToList(self, template_list):
        for template in template_list:
            if not template in self.template_list:
                self.template_list.append(template)
                
        if not self.template_list:
            return
        
        self.template_list.sort()
        
        self.initComboBox()
        
        for template_name in self.template_list:
            self.ui.comboBoxTemplate.addItem(template_name)
        
        self.setLastTemplateSelected()
    
    def getSessionName(self):
        return self.ui.lineEdit.text()

    def getTemplateName(self):
        if self.ui.comboBoxTemplate.currentIndex() == 0:
            return ""
        
        if self.ui.comboBoxTemplate.currentIndex() == 1:
            return '///withJACKPATCH'
        
        return self.ui.comboBoxTemplate.currentText()
        
    def textChanged(self, text):
        self.text_is_valid = bool(text and not text in self.session_list)
        self.preventOk()
            
    def changeNsmFolder(self):
        changeNsmFolder(self)
        self.ui.currentNsmFolder.setText(default_folder)
        self.session_list.clear()
        serverOSC.startListSession()
        
    def preventOk(self):
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(bool(self.server_will_accept and self.text_is_valid))

class AbstractSaveTemplateDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_save_template_session.Ui_DialogSaveTemplateSession()
        self.ui.setupUi(self)
        
        self.server_will_accept = False
        
        self.ui.lineEdit.textEdited.connect(self.textEdited)
        self.ui.pushButtonAccept.clicked.connect(self.verifyAndAccept)
        self.ui.pushButtonAccept.setEnabled(False)
        
    def textEdited(self, text):
        if '/' in text:
            self.ui.lineEdit.setText(text.replace('/', '⁄'))
        self.allowOkButton()    
    
    def getTemplateName(self):
        return self.ui.lineEdit.text()
    
    def allowOkButton(self, text=''):
        self.ui.pushButtonAccept.setEnabled(bool(self.server_will_accept and self.ui.lineEdit.text()))
    
    def verifyAndAccept(self):
        template_name = self.getTemplateName()
        if template_name in self.template_list:
            ret = QMessageBox.question(self, 
                                       _translate('session template', 'Overwrite Template ?'),
                                       _translate('session_template', 'Template <strong>%s</strong> already exists.\nOverwrite it ?') % template_name)
            if ret == QMessageBox.No:
                return
        self.accept()
    
class SaveTemplateSessionDialog(AbstractSaveTemplateDialog):
    def __init__(self, parent):
        AbstractSaveTemplateDialog.__init__(self, parent)
        
        self.template_list = []
        
        serverOSC.qsig.session_template_found.connect(self.addTemplatesToList)
        serverOSC.toDaemon('/ray/server/list_session_templates')
        
        self.serverStatusChanged(session.server_status)
    
    def serverStatusChanged(self, server_status):
        self.server_will_accept = bool(server_status == SERVER_STATUS_READY)
        
        if server_status == SERVER_STATUS_OFF:
            self.reject()
        
        self.allowOkButton()
    
    def addTemplatesToList(self, template_list):
        self.template_list += template_list

class SaveTemplateClientDialog(AbstractSaveTemplateDialog):
    def __init__(self, parent):
        AbstractSaveTemplateDialog.__init__(self, parent)
        
        self.template_list = []
        self.ui.pushButtonAccept.setEnabled(False)
        
        self.ui.labelNewTemplateName.setText(_translate('new client template', "New application template name :"))
        
        serverOSC.qsig.user_client_template_found.connect(self.addTemplatesToList)
        serverOSC.toDaemon('/ray/server/list_user_client_templates')
        
        self.serverStatusChanged(session.server_status)
    
    def serverStatusChanged(self, server_status):
        self.server_will_accept = bool(not server_status in (SERVER_STATUS_OFF, SERVER_STATUS_CLOSE))
        
        if server_status == SERVER_STATUS_OFF:
            self.reject()
        
        self.allowOkButton()
    
    def addTemplatesToList(self, template_list):
        for template in template_list:
            self.template_list.append(template.split('/')[0])
  
class ClientPropertiesDialog(ChildDialog):
    def __init__(self, parent, client):
        ChildDialog.__init__(self, parent)
        self.ui = ui_client_properties.Ui_Dialog()
        self.ui.setupUi(self)
        
        self.client = client
        
        self.ui.lineEditIcon.textEdited.connect(self.changeIconwithText)
        self.ui.pushButtonSaveChanges.clicked.connect(self.saveChanges)
        
    def updateContents(self):
        self.ui.labelExecutable.setText(self.client.executable_path)
        self.ui.labelId.setText(self.client.client_id)
        self.ui.labelClientName.setText(self.client.name)
        self.ui.lineEditIcon.setText(self.client.icon_name)
        self.ui.lineEditLabel.setText(self.client.label)
        self.ui.toolButtonIcon.setIcon(QIcon.fromTheme(self.client.icon_name))
        
    def changeIconwithText(self, text):
        self.ui.toolButtonIcon.setIcon(QIcon.fromTheme(text))
        
    def saveChanges(self):
        self.client.label     = self.ui.lineEditLabel.text()
        self.client.icon_name = self.ui.lineEditIcon.text()
        self.client.sendPropertiesToDaemon()
        
class AbortSessionDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_abort_session.Ui_AbortSession()
        self.ui.setupUi(self)
        
        self.ui.pushButtonAbort.clicked.connect(self.accept)
        self.ui.pushButtonCancel.clicked.connect(self.reject)
        self.ui.pushButtonCancel.setFocus(Qt.OtherFocusReason)
        
        self.serverStatusChanged(session.server_status)
        
    def serverStatusChanged(self, server_status):
        self.ui.pushButtonAbort.setEnabled(not bool(server_status in (SERVER_STATUS_CLOSE, SERVER_STATUS_OFF)))
        if server_status == SERVER_STATUS_OFF:
            self.reject()
        
class OpenNsmSessionInfoDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_nsm_open_info.Ui_Dialog()
        self.ui.setupUi(self)
        
        self.ui.checkBox.stateChanged.connect(self.showThis)
        
    def showThis(self, state):
        settings.setValue('OpenNsmSessionInfo', not bool(state))


class quitAppDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_quit_app.Ui_DialogQuitApp()
        self.ui.setupUi(self)
        self.ui.pushButtonCancel.setFocus(Qt.OtherFocusReason)
        self.ui.pushButtonSaveQuit.clicked.connect(serverOSC.closeSession)
        self.ui.pushButtonQuitNoSave.clicked.connect(serverOSC.abortSession)
        
        original_text = self.ui.labelExecutable.text()
        self.ui.labelExecutable.setText(original_text % ('<strong>%s</strong>' % session.name))
        
        self.serverStatusChanged(session.server_status)
    
    def serverStatusChanged(self, server_status):
        if server_status == SERVER_STATUS_OFF:
            self.accept()
            return
        
        self.ui.pushButtonSaveQuit.setEnabled(bool(server_status == SERVER_STATUS_READY))
        self.ui.pushButtonQuitNoSave.setEnabled(bool(server_status != SERVER_STATUS_CLOSE))
 
class AboutRaySessionDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_about_raysession.Ui_DialogAboutRaysession()
        self.ui.setupUi(self)
        all_text = self.ui.labelRayAndVersion.text()
        self.ui.labelRayAndVersion.setText(all_text % VERSION)
        
class AddApplicationDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_add_application.Ui_DialogAddApplication()
        self.ui.setupUi(self)
        
        self.ui.checkBoxFactory.setChecked(settings.value('AddApplication/factory_box', True, type=bool))
        self.ui.checkBoxUser.setChecked(settings.value('AddApplication/user_box', True, type=bool))
        
        self.ui.checkBoxFactory.stateChanged.connect(self.factoryBoxChanged)
        self.ui.checkBoxUser.stateChanged.connect(self.userBoxChanged)
        
        
        self.ui.templateList.currentItemChanged.connect(self.currentItemChanged)
        self.ui.templateList.setFocus(Qt.OtherFocusReason)
        self.ui.filterBar.textEdited.connect(self.updateFilteredList)
        self.ui.filterBar.updownpressed.connect(self.updownPressed)
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(False)
        
        serverOSC.qsig.user_client_template_found.connect(self.addUserTemplates)
        serverOSC.qsig.factory_client_template_found.connect(self.addFactoryTemplates)
        serverOSC.toDaemon('/ray/server/list_user_client_templates')
        serverOSC.toDaemon('/ray/server/list_factory_client_templates')
        #serverOSC.startListSession()
        
        self.user_template_list    = []
        self.factory_template_list = []
            
        self.server_will_accept = False
        self.has_selection      = False
        
        self.serverStatusChanged(session.server_status)
    
    def factoryBoxChanged(self, state):
        if not state:
            self.ui.checkBoxUser.setChecked(True)
            
        self.updateFilteredList()
        
    def userBoxChanged(self, state):
        if not state:
            self.ui.checkBoxFactory.setChecked(True)
            
        self.updateFilteredList()   
    
    def serverStatusChanged(self, server_status):
        self.server_will_accept = bool(not server_status in (SERVER_STATUS_OFF, SERVER_STATUS_CLOSE))
        self.preventOk()
        
    def addUserTemplates(self, template_list):
        for template in template_list:
            template_name = template
            icon_name = ''
            
            if '/' in template:
                template_name = template.split('/')[0]
                icon_name = template.split('/')[1]
            
            self.user_template_list.append(template_name)
            
            self.ui.templateList.addItem(QListWidgetItem(QIcon.fromTheme(icon_name), template_name, self.ui.templateList))
            
            self.ui.templateList.sortItems()
            
        self.updateFilteredList()
            
    def addFactoryTemplates(self, template_list):
        for template in template_list:
            template_name = template
            icon_name = ''
            
            if '/' in template:
                template_name = template.split('/')[0]
                icon_name = template.split('/')[1]
            
            self.factory_template_list.append(template_name)
            
            self.ui.templateList.addItem(QListWidgetItem(QIcon.fromTheme(icon_name), template_name, self.ui.templateList))
            
            self.ui.templateList.sortItems()
            
        self.updateFilteredList()
        
    def updateFilteredList(self, filt=''):
        filter_text = self.ui.filterBar.displayText()
        
        #show all items
        for i in range(self.ui.templateList.count()):
            self.ui.templateList.item(i).setHidden(False)
            
        liist = self.ui.templateList.findItems(filter_text, Qt.MatchContains)
        
        seen_template_list = []
        
        #hide all non matching items
        for i in range(self.ui.templateList.count()):
            template_name = self.ui.templateList.item(i).text()
            
            if self.ui.templateList.item(i) not in liist:
               self.ui.templateList.item(i).setHidden(True)
               continue
            
            if self.ui.checkBoxFactory.isChecked() and self.ui.checkBoxUser.isChecked():
                if template_name in seen_template_list:
                    self.ui.templateList.item(i).setHidden(True)
                else:
                    seen_template_list.append(template_name)
            
            elif self.ui.checkBoxFactory.isChecked():
                if not template_name in self.factory_template_list:
                    self.ui.templateList.item(i).setHidden(True)
                    continue
                
                if template_name in seen_template_list:
                    self.ui.templateList.item(i).setHidden(True)
                else:
                    seen_template_list.append(template_name)
                
            elif self.ui.checkBoxUser.isChecked():
                if not template_name in self.user_template_list:
                    self.ui.templateList.item(i).setHidden(True)
                    
                if template_name in seen_template_list:
                    self.ui.templateList.item(i).setHidden(True)
                else:
                    seen_template_list.append(template_name)
        
        #if selected item not in list, then select the first visible
        if not self.ui.templateList.currentItem() or self.ui.templateList.currentItem().isHidden():
            for i in range(self.ui.templateList.count()):
                if not self.ui.templateList.item(i).isHidden():
                    self.ui.templateList.setCurrentRow(i)
                    break
              
              
        if not self.ui.templateList.currentItem() or self.ui.templateList.currentItem().isHidden():
            self.ui.filterBar.setStyleSheet("QLineEdit { background-color: red}")
            self.ui.templateList.setCurrentItem(None)
        else:
            self.ui.filterBar.setStyleSheet("")
            self.ui.templateList.scrollTo(self.ui.templateList.currentIndex())
    
    def updownPressed(self, key):
        row = self.ui.templateList.currentRow()
        if key == Qt.Key_Up:
            if row == 0:
                return
            row-=1
            while self.ui.templateList.item(row).isHidden():
                if row == 0:
                    return
                row-=1
        elif key == Qt.Key_Down:
            if row == self.ui.templateList.count() -1:
                return
            row+=1
            while self.ui.templateList.item(row).isHidden():
                if row == self.ui.templateList.count() -1:
                    return
                row+=1
        self.ui.templateList.setCurrentRow(row)
    
    def currentItemChanged(self, item, previous_item):
        self.has_selection = bool(item)
        self.preventOk()
    
    def preventOk(self):
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(bool(self.server_will_accept and self.has_selection))
            
    def getSelectedTemplate(self):
        if self.ui.templateList.currentItem():
            return self.ui.templateList.currentItem().text()
        
    def isTemplateFactory(self, template_name):
        if not self.ui.checkBoxUser.isChecked():
            return True 
        
        #If both factory and user boxes are checked, priority to user template
        if template_name in self.user_template_list:
            return False
        
        return True
        
    def saveCheckBoxes(self):
        settings.setValue('AddApplication/factory_box', self.ui.checkBoxFactory.isChecked())
        settings.setValue('AddApplication/user_box'   , self.ui.checkBoxUser.isChecked())
        settings.sync()

class newExecutableDialog(ChildDialog):
    def __init__(self, parent):
        ChildDialog.__init__(self, parent)
        self.ui = ui_new_executable.Ui_DialogNewExecutable()
        self.ui.setupUi(self)
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(False)
        self.ui.lineEdit.setFocus(Qt.OtherFocusReason)
        self.ui.lineEdit.textChanged.connect(self.textChanged)
        
        
        self.ui.checkBoxProxy.stateChanged.connect(self.proxyStateChanged)
        serverOSC.qsig.new_executable.connect(self.addExecutableToCompleter)
        serverOSC.toDaemon('/ray/server/list_path')
        
        self.exec_list = []
        
        self.completer = QCompleter(self.exec_list)
        self.ui.lineEdit.setCompleter(self.completer)
        
        self.ui.lineEdit.returnPressed.connect(self.closeNow)
        
        self.serverStatusChanged(session.server_status)
        
        self.text_will_accept = False
    
    def addExecutableToCompleter(self, executable_list):
        self.exec_list += executable_list
        self.exec_list.sort()
        
        del self.completer
        self.completer = QCompleter(self.exec_list)
        self.ui.lineEdit.setCompleter(self.completer)
    
    def getExecutableSelected(self):
        return self.ui.lineEdit.text()
        
    def runViaProxy(self):
        return bool(self.ui.checkBoxProxy.isChecked())
    
    def proxyStateChanged(self, state):
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(state or self.text_will_accept)
    
    def textChanged(self, text):
        self.text_will_accept = bool(text and text in self.exec_list)
        self.ui.buttonBox.button(QDialogButtonBox.Ok).setEnabled(self.ui.checkBoxProxy.isChecked() or self.text_will_accept)
   
    def closeNow(self):
       if self.ui.lineEdit.text() in self.exec_list or self.ui.checkBoxProxy.isChecked():
           self.accept()
           
    def serverStatusChanged(self, server_status):
        if server_status in (SERVER_STATUS_CLOSE, SERVER_STATUS_OFF):
            self.reject()

class StopClientDialog(ChildDialog):
    def __init__(self, parent, client_id):
        ChildDialog.__init__(self, parent)
        self.ui = ui_stop_client.Ui_Dialog()
        self.ui.setupUi(self)
        
        self.client_id = client_id
        self.wait_for_save = False
        
        client = session.getClient(client_id)
        
        text = self.ui.label.text() % client.prettierName()
        
        if not client.has_dirty:
            minutes = int((time.time() - client.last_save) / 60)
            text = _translate('client_stop', "<strong>%s</strong> seems to has not been saved for %i minute(s).<br />Do you really want to stop it ?") % (client.prettierName(), minutes)
        
        self.ui.label.setText(text)
        
        self.ui.pushButtonSaveStop.clicked.connect(self.saveAndStop)
        
        serverOSC.qsig.client_status_changed.connect(self.serverUpdatesClientStatus)
    
    def saveAndStop(self):
        self.wait_for_save = True
        serverOSC.saveClient(self.client_id)
        
    def serverUpdatesClientStatus(self, client_id, status):
        if client_id != self.client_id:
            return
        
        if status in (CLIENT_STATUS_STOPPED, CLIENT_STATUS_REMOVED):
            self.reject()
            return
        
        if status == CLIENT_STATUS_READY and self.wait_for_save:
            self.wait_for_save = False
            self.accept()
            
        
        
        
    
class ErrorDialog(ChildDialog):
    def __init__(self, parent, osc_args):
        ChildDialog.__init__(self, parent)
        self.ui = ui_error_dialog.Ui_Dialog()
        self.ui.setupUi(self)
        
        self.ui.label.setText(osc_args[2])
        

class RayDaemon(object):
    def __init__(self):
        self.executable      = 'ray-daemon'
        self.process         = QProcess()
        self.process.finished.connect(self.processFinished)
        self.process.errorOccurred.connect(self.errorInProcess)
        self.process.setProcessChannelMode(QProcess.ForwardedChannels)
        self.stopped_yet     = False
        self.is_local        = True
        self.launched_before = False
        self.address         = None
        self.port            = None
    
    def processFinished(self, exit_code, exit_status):
        if not MainUI.isHidden():
            MainUI.daemonCrash()
            
    
    def errorInProcess(self, error):
        MainUI.daemonCrash()
    
    def setOscAddress(self, address):
        self.address = address
        self.launched_before = True
        if self.address.hostname != socket.gethostname():
            self.is_local = False
            
    def processIsRunning(self):
        return bool(self.process.state() == 2)
    
    def start(self):
        #start process
        arguments = ['--gui-url'     , str(serverOSC.url), 
                     '--osc-port'    , str(self.port), 
                     '--session-root', default_folder ]
        if debug:
            arguments.append('--debug')
        
        self.process.start('ray-daemon', arguments)
        
    def stop(self):
        if self.processIsRunning():
            if not self.stopped_yet:
                self.process.terminate()
                self.stopped_yet = True
            
    def waitEnd(self):
        if not self.processIsRunning():
            return
        
        print('waiting for daemon to die', file=sys.stderr)
        
        for i in range(100):
            if self.processIsRunning():
                return
            time.sleep(0.050)
            
        print('ray-daemon is still running, sorry !', file=sys.stderr)
    
    def setNewOscAddress(self):
        if not (self.address or self.port):
            self.port = getFreeOscPort()
            self.address = Address(self.port)
  
if __name__ == '__main__':
    #connect signals
    signal.signal(signal.SIGINT , signalHandler)
    signal.signal(signal.SIGTERM, signalHandler)
    
    #set Qt Application
    app = QApplication(sys.argv)
    app.setApplicationName("RaySession")
    app.setApplicationVersion(VERSION)
    app.setOrganizationName("RaySession")
    app.setWindowIcon(QIcon(':/scalable/raysession.svg'))
    
    ### Translation process
    locale = QLocale.system().name()
    appTranslator = QTranslator()
    if appTranslator.load("%s/locale/raysession_%s" % (os.path.dirname(os.path.dirname(sys.argv[0])), locale)):
        app.installTranslator(appTranslator)
    _translate = app.translate
    init_translation(_translate)
    
    
    QFontDatabase.addApplicationFont(":/fonts/Ubuntu-R.ttf")
    QFontDatabase.addApplicationFont(":fonts/Ubuntu-C.ttf")
    
    #Add RaySession/src to $PATH to can use raysession after make, whitout install
    os.environ['PATH']="%s:%s" % (os.path.realpath(os.path.dirname(sys.argv[0])), os.environ['PATH'])
    
    #get arguments
    parser = argparse.ArgumentParser(description=_translate('help', 'A session manager based on the Non-Session-Manager API for sound applications.'))
    parser.add_argument('--daemon-url', '-u', type=getLibloAddress, help='connect to this daemon url')
    parser.add_argument('--debug','-d',  action='store_true', help='display OSC messages')
    parser.add_argument('-v', '--version', action='version', version=VERSION)
    parsed_args = parser.parse_args()
    
    ray_daemon = RayDaemon()
    
    if parsed_args.daemon_url:
        ray_daemon.setOscAddress(parsed_args.daemon_url)
        
    debug = parsed_args.debug
    setDebug(debug)
    
    #needed for signals SIGINT, SIGTERM
    timer = QTimer()
    timer.start(200)
    timer.timeout.connect(lambda: None)
    
    settings = QSettings()
    
    #get default folder
    default_folder = settings.value('default_folder', "%s/Ray Sessions" % os.getenv('HOME'), type=str )
    
    ray_daemon.setNewOscAddress()
    
    serverOSC = OSCServerT()
    serverOSC.start()
    
    session = Session()
    
    MainUI = MainWindow()
    MainUI.show()
    
    if ray_daemon.launched_before:
        serverOSC.announce()
    else:
        ray_daemon.start()
    
    app.exec()
    
    serverOSC.stop()
    ray_daemon.stop()
    MainUI.hide()
    ray_daemon.waitEnd()
    
    del MainUI
    del app
